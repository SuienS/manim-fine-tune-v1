Generated Description,Reviewed Description,Code,Type,Split
Display 3D axes and a circle. Set the camera orientation to a specific angle. Begin rotating the camera around the scene at a fast rate to create an illusion effect. Stop the camera rotation after a quarter turn. ,Display 3D axes and a circle. Set the camera orientation to a specific angle. Begin rotating the camera around 3D space of the scene at a fast rate to create an illusion effect of the 3D space. Stop the camera rotation after a quarter turn. ,"from manim import *

class ThreeDCameraIllusionRotation(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        circle=Circle()
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        self.add(circle,axes)
        self.begin_3dillusion_camera_rotation(rate=2)
        self.wait(PI/2)
        self.stop_3dillusion_camera_rotation()",Intermediate,train
,"Display the Manim logo banner alongside a title that reads “Manim version *x.y.z*”, where *x.y.z* is the current version of the Manim library being used. Both elements appear centered on the screen.","from manim import *

import manim

class TitleExample(Scene):
    def construct(self):
        banner = ManimBanner()
        title = Title(f""Manim version {manim.__version__}"")
        self.add(banner, title)",Basic,train
,"Display a 2×2 decimal matrix:  
\[
\left\{
\begin{array}{cc}
3.46 & 2.12 \\
33.22 & 12.00 \\
\end{array}
\right\}
\]  
Each element is rounded to two decimal places, and the matrix is enclosed in curly braces. It appears on screen without animation.","from manim import *

class DecimalMatrixExample(Scene):
    def construct(self):
        m0 = DecimalMatrix(
            [[3.456, 2.122], [33.2244, 12]],
            element_to_mobject_config={""num_decimal_places"": 2},
            left_bracket=""\\{"",
            right_bracket=""\\}"")
        self.add(m0)",Basic,train
,Display a square centered on the screen. Animate the square moving upward over a duration of three seconds. Then pause for one second.,"from manim import *

class RunTime(Scene):
    def construct(self):
        square = Square()
        self.add(square)
        self.play(square.animate.shift(UP), run_time=3)
        self.wait(1)",Basic,train
,"Display a set of coordinate axes with a cosine curve plotted. A yellow square is positioned exactly at the point on the curve where \( x = \pi \), visually marking that location on the graph.","from manim import *

class InputToGraphPointExample(Scene):
    def construct(self):
        ax = Axes()
        curve = ax.plot(lambda x : np.cos(x))

        # move a square to PI on the cosine curve.
        position = ax.input_to_graph_point(x=PI, graph=curve)
        sq = Square(side_length=1, color=YELLOW).move_to(position)

        self.add(ax, curve, sq)",Intermediate,train
,"Display a directed graph with five labeled nodes arranged in a circular layout, but with all arrows styled to appear undirected by removing their tips. One edge, from node 3 to node 4, is colored red for emphasis. After the graph is created, several nodes animate to new positions in 3D space: node 1 moves to the upper right, node 2 to the upper left and forward, node 3 to the lower left and back, and node 4 to the lower right and back. The edges dynamically adjust to maintain the connections between the repositioned nodes.","from manim import *

class UndirectedMovingDiGraph(Scene):
    def construct(self):
        vertices = [i for i in range(5)]
        edges = [
            (0, 1),
            (1, 2),
            (3, 2),
            (3, 4),
        ]

        edge_config = {
            ""stroke_width"": 2,
            ""tip_config"": {""tip_length"": 0, ""tip_width"": 0},
            (3, 4): {""color"": RED},
        }

        g = DiGraph(
            vertices,
            edges,
            labels=True,
            layout=""circular"",
            edge_config=edge_config,
        ).scale(1.4)

        self.play(Create(g))
        self.wait()

        self.play(
            g[1].animate.move_to([1, 1, 1]),
            g[2].animate.move_to([-1, 1, 2]),
            g[3].animate.move_to([-1.5, -1.5, -1]),
            g[4].animate.move_to([1, -2, -1]),
        )
        self.wait()",Intermediate,train
,"Display a 3D coordinate system using axes, with a 3D arrow originating from the origin (0, 0, 0) and pointing to the point (2, 2, 2). The arrow is rendered with a smooth resolution, and the camera is set at a 75° vertical angle and a 30° horizontal angle to provide a clear, tilted view of the arrow in 3D space.","from manim import *

class ExampleArrow3D(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        arrow = Arrow3D(
            start=np.array([0, 0, 0]),
            end=np.array([2, 2, 2]),
            resolution=8
        )
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        self.add(axes, arrow)",Basic,train
,"Display a solid red square on the left and a solid blue circle overlapping it from the top right. On the right side of the screen, show a green shape representing the union—combining the full areas of both the square and the circle into a single merged shape.","from manim import *

class UnionExample(Scene):
    def construct(self):
        sq = Square(color=RED, fill_opacity=1)
        sq.move_to([-2, 0, 0])
        cr = Circle(color=BLUE, fill_opacity=1)
        cr.move_to([-1.3, 0.7, 0])
        un = Union(sq, cr, color=GREEN, fill_opacity=1)
        un.move_to([1.5, 0.3, 0])
        self.add(sq, cr, un)",Basic,train
,"Display a thick parametric sine curve and a version of the same curve shifted upward, with its color smoothly transitioning from blue to red along its length. The gradient visually emphasizes the direction and flow of the curve.","from manim import *

class LineGradientExample(Scene):
    def construct(self):
        curve = ParametricFunction(lambda t: [t, np.sin(t), 0], t_range=[-PI, PI, 0.01], stroke_width=10)
        new_curve = CurvesAsSubmobjects(curve)
        new_curve.set_color_by_gradient(BLUE, RED)
        self.add(new_curve.shift(UP), curve)",Basic,train
"Display a 2×2 table with row and column labels. The first column’s text is colored red, the second column’s text is colored blue, and all labels are colored green, making each section visually distinct.","Display a 2×2 table with row and column labels. The row heading text is colored red-blue gradient, the first column’s text is colored green, others are white, making each section visually distinct.","from manim import *

class SetColumnColorsExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")]
        ).set_column_colors([RED,BLUE], GREEN)
        self.add(table)",Basic,train
,"Display the text “Alice and Bob” in large font on the screen, then animate it being erased in reverse, as if unwriting it.","from manim import *

class UnwriteReverseTrue(Scene):
    def construct(self):
        text = Tex(""Alice and Bob"").scale(3)
        self.add(text)
        self.play(Unwrite(text))",Basic,train
,"Display a five-pointed star (pentagram) with evenly spaced points, sized with a radius of 2 units. The star is centered on the screen and shown with default styling.","from manim import *

class RegularPolygramExample(Scene):
    def construct(self):
        pentagram = RegularPolygram(5, radius=2)
        self.add(pentagram)",Basic,train
,"Display a square by fading it in. Then, rotate the square 45 degrees. Finally, fade the square out and pause for one second.","from manim import *

class SomeAnimations(Scene):
    def construct(self):
        square = Square()

        # some animations display mobjects, ...
        self.play(FadeIn(square))

        # ... some move or rotate mobjects around...
        self.play(Rotate(square, PI/4))

        # some animations remove mobjects from the screen
        self.play(FadeOut(square))

        self.wait(1)",Basic,train
,"Display three large rectangles vertically aligned on the left side of the screen. After they fade in, each rectangle transforms into a small filled circle on the right side using different fade styles:

- The top rectangle stretches as it fades into the circle.
- The middle rectangle fades into the circle without stretching and without dimming to match the target.
- The bottom rectangle fades into the circle without stretching but dims to match the target's brightness.

Finally, all objects fade out together.","from manim import *

class DifferentFadeTransforms(Scene):
    def construct(self):
        starts = [Rectangle(width=4, height=1) for _ in range(3)]
        VGroup(*starts).arrange(DOWN, buff=1).shift(3*LEFT)
        targets = [Circle(fill_opacity=1).scale(0.25) for _ in range(3)]
        VGroup(*targets).arrange(DOWN, buff=1).shift(3*RIGHT)

        self.play(*[FadeIn(s) for s in starts])
        self.play(
            FadeTransform(starts[0], targets[0], stretch=True),
            FadeTransform(starts[1], targets[1], stretch=False, dim_to_match=0),
            FadeTransform(starts[2], targets[2], stretch=False, dim_to_match=1)
        )

        self.play(*[FadeOut(mobj) for mobj in self.mobjects])",Intermediate,train
,"Display a set of coordinate axes with a blue curve representing the implicit equation \( y(x - y)^2 - 4x - 8 = 0 \). The curve is plotted based on the relationship between \( x \) and \( y \) without explicitly solving for one variable in terms of the other, illustrating the shape defined by the implicit function.","from manim import *

class ImplicitExample(Scene):
    def construct(self):
        ax = Axes()
        a = ax.plot_implicit_curve(
            lambda x, y: y * (x - y) ** 2 - 4 * x - 8, color=BLUE
        )
        self.add(ax, a)",Intermediate,train
,"Display five horizontal groups of four dots each, labeled with different `lag_ratio` values: 0, 0.1, 0.5, 1, and 2. Each group shifts downward with a staggered animation based on its `lag_ratio`—lower values animate more simultaneously, while higher values animate more sequentially. Then, all groups shift upward together with a slight delay between each group due to a recursive `lag_ratio`.","from manim import *

class LagRatios(Scene):
    def construct(self):
        ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios

        # Create dot groups
        group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()
        groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)
        self.add(groups)

        # Label groups
        self.add(Text(""lag_ratio = "", font_size=36).next_to(groups, UP, buff=1.5))
        for group, ratio in zip(groups, ratios):
            self.add(Text(str(ratio), font_size=36).next_to(group, UP))

        #Animate groups with different lag_ratios
        self.play(AnimationGroup(*[
            group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)
            for group, ratio in zip(groups, ratios)
        ]))

        # lag_ratio also works recursively on nested submobjects:
        self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))",Intermediate,train
,"Display a red-filled square on the screen. Animate the square changing its fill color to white. Then, simultaneously move the square upward and rotate it 60 degrees. Pause for one second after each animation.","from manim import *

class AnimateExample(Scene):
    def construct(self):
        square = Square().set_fill(RED, opacity=1.0)
        self.add(square)

        # animate the change of color
        self.play(square.animate.set_fill(WHITE))
        self.wait(1)

        # animate the change of position and the rotation at the same time
        self.play(square.animate.shift(UP).rotate(PI / 3))
        self.wait(1)",Basic,train
,"Display a row of green quarter-circle arcs, each with a thick stroke and a different cap style (such as butt, round, or square). The arcs are evenly spaced horizontally, and each one is labeled below with the name of its corresponding cap style, helping to visually compare the stroke end variations.","from manim import *

class CapStyleVariants(Scene):
    def construct(self):
        arcs = VGroup(*[
            Arc(
                radius=1,
                start_angle=0,
                angle=TAU / 4,
                stroke_width=20,
                color=GREEN,
                cap_style=cap_style,
            )
            for cap_style in CapStyleType
        ])
        arcs.arrange(RIGHT, buff=1)
        self.add(arcs)
        for arc in arcs:
            label = Text(arc.cap_style.name, font_size=24).next_to(arc, DOWN)
            self.add(label)",Basic,train
,"Display four colored arcs of varying sizes and angles, each paired with a brace that curves along its outer edge:

- A red arc with a left-facing brace.
- A yellow arc with a standard brace.
- A blue arc with a semicircular shape and a brace.
- A green arc forming three-quarters of a circle with a brace.

All arc-brace pairs are arranged in a grid layout with ample spacing and centered on the screen.","from manim import *

class ArcBraceExample(Scene):
    def construct(self):
        arc_1 = Arc(radius=1.5,start_angle=0,angle=2*PI/3).set_color(RED)
        brace_1 = ArcBrace(arc_1,LEFT)
        group_1 = VGroup(arc_1,brace_1)

        arc_2 = Arc(radius=3,start_angle=0,angle=5*PI/6).set_color(YELLOW)
        brace_2 = ArcBrace(arc_2)
        group_2 = VGroup(arc_2,brace_2)

        arc_3 = Arc(radius=0.5,start_angle=-0,angle=PI).set_color(BLUE)
        brace_3 = ArcBrace(arc_3)
        group_3 = VGroup(arc_3,brace_3)

        arc_4 = Arc(radius=0.2,start_angle=0,angle=3*PI/2).set_color(GREEN)
        brace_4 = ArcBrace(arc_4)
        group_4 = VGroup(arc_4,brace_4)

        arc_group = VGroup(group_1, group_2, group_3, group_4).arrange_in_grid(buff=1.5)
        self.add(arc_group.center())",Intermediate,train
"Display an orange dot at the left end of a horizontal line. As the dot moves smoothly along the line to the right, an orange line dynamically extends from the left endpoint to the moving dot, visually tracing its path in real time.","Display an orange dot at the left end of a horizontal line. As the dot moves smoothly along the line to the right, an orange line dynamically extends from the left endpoint to the moving dot, visually tracing its path in real time similar to a filling progress bar.","from manim import *

class MoveAlongPathExample(Scene):
    def construct(self):
        d1 = Dot().set_color(ORANGE)
        l1 = Line(LEFT, RIGHT)
        l2 = VMobject()
        self.add(d1, l1, l2)
        l2.add_updater(lambda x: x.become(Line(LEFT, d1.get_center()).set_color(ORANGE)))
        self.play(MoveAlongPath(d1, l1), rate_func=linear)",Intermediate,train
,"Display a set of coordinate axes with labeled ticks, then plot the curve \( y = \frac{\sin(x)}{e^{2x}} \). From \( x = 0 \) to \( x = 4 \), 30 evenly spaced vertical blue lines are drawn from the x-axis up to the curve, visually illustrating the shape and behavior of the function over that interval.","from manim import *

class GetVerticalLinesToGraph(Scene):
    def construct(self):
        ax = Axes(
            x_range=[0, 8.0, 1],
            y_range=[-1, 1, 0.2],
            axis_config={""font_size"": 24},
        ).add_coordinates()

        curve = ax.plot(lambda x: np.sin(x) / np.e ** 2 * x)

        lines = ax.get_vertical_lines_to_graph(
            curve, x_range=[0, 4], num_lines=30, color=BLUE
        )

        self.add(ax, curve, lines)",Intermediate,train
,"Display two intersecting lines forming an angle at their crossing point. A curved arc marks the angle between them, and a numerical label showing the angle’s value in degrees is placed just above and to the right of the arc.","from manim import *

class GetValueExample(Scene):
    def construct(self):
        line1 = Line(LEFT+(1/3)*UP, RIGHT+(1/3)*DOWN)
        line2 = Line(DOWN+(1/3)*RIGHT, UP+(1/3)*LEFT)

        angle = Angle(line1, line2, radius=0.4)

        value = DecimalNumber(angle.get_value(degrees=True), unit=r""^{\circ}"")
        value.next_to(angle, UR)

        self.add(line1, line2, angle, value)",Basic,train
Display 3D axes and a circle. Set the camera orientation to a specific angle. Begin rotating the camera around the scene at a slow rate. Stop the camera rotation and reset the camera to the original orientation.,Display 3D axes and a circle. Set the camera orientation to a specific angle. Begin rotating the camera around the scene horizontally at a slow rate. Stop the camera rotation and reset the camera to the original orientation.,"from manim import *

class ThreeDCameraRotation(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        circle=Circle()
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        self.add(circle,axes)
        self.begin_ambient_camera_rotation(rate=0.1)
        self.wait()
        self.stop_ambient_camera_rotation()
        self.move_camera(phi=75 * DEGREES, theta=30 * DEGREES)
        self.wait()",Intermediate,train
,"Display a coordinate grid with default x- and y-axes. The x-axis is labeled with a scaled-down LaTeX-rendered label ""x-axis,"" and the y-axis is labeled with a smaller plain text label ""y-axis."" Both labels are positioned near the ends of their respective axes.","from manim import *

class GetAxisLabelsExample(Scene):
    def construct(self):
        ax = Axes()
        labels = ax.get_axis_labels(
            Tex(""x-axis"").scale(0.7), Text(""y-axis"").scale(0.45)
        )
        self.add(ax, labels)",Basic,train
,"Display a group of 15 blue dots randomly scattered and slightly shifted upward. Below them, a red copy of the same dots is shown, but this time the dots are neatly arranged in a row using default spacing. Both groups are centered on the screen, with the blue dots above and the red dots below.","from manim import *

class ArrangeSumobjectsExample(Scene):
    def construct(self):
        s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])
        s.shift(UP).set_color(BLUE)
        s2= s.copy().set_color(RED)
        s2.arrange_submobjects()
        s2.shift(DOWN)
        self.add(s,s2)",Intermediate,train
,"Display the text ""Hello World!"" at the center of the screen, then animate its color gradually fading into red, creating a smooth transition effect.","from manim import *

class FadeToColorExample(Scene):
    def construct(self):
        self.play(FadeToColor(Text(""Hello World!""), color=RED))",Basic,train
,"Display a circle positioned two units to the left of the center. Place a square to the left of the circle with a small gap between them. Then, position a triangle so that its left edge aligns with the left edge of the circle. Show all three shapes on screen and pause for one second.","from manim import *

class MobjectPlacement(Scene):
    def construct(self):
        circle = Circle()
        square = Square()
        triangle = Triangle()

        # place the circle two units left from the origin
        circle.move_to(LEFT * 2)
        # place the square to the left of the circle
        square.next_to(circle, LEFT)
        # align the left border of the triangle to the left border of the circle
        triangle.align_to(circle, LEFT)

        self.add(circle, square, triangle)
        self.wait(1)",Basic,train
,"Display a 4×4 math table with outer borders. The top row and leftmost column serve as headers, with the top-left cell containing a plus sign. The remaining cells show the sums of the corresponding row and column headers.","from manim import *

class MathTableExample(Scene):
    def construct(self):
        t0 = MathTable(
            [[""+"", 0, 5, 10],
            [0, 0, 5, 10],
            [2, 2, 7, 12],
            [4, 4, 9, 14]],
            include_outer_lines=True)
        self.add(t0)",Basic,train
,"Display a square centered on the screen. Rotate the square 45 degrees, then transform it into a circle. Finally, change the circle’s fill to pink with 50% transparency.","from manim import *

class AnimatedSquareToCircle(Scene):
    def construct(self):
        circle = Circle()  # create a circle
        square = Square()  # create a square

        self.play(Create(square))  # show the square on screen
        self.play(square.animate.rotate(PI / 4))  # rotate the square
        self.play(Transform(square, circle))  # transform the square into a circle
        self.play(
            square.animate.set_fill(PINK, opacity=0.5)
        )  # color the circle on screen",Basic,train
,"Display a set of axes. Plot the graph of the function \( f(x) = \frac{k}{x} \) in yellow. Show a blue rectangle with yellow edges that dynamically updates its size based on the value of \( t \). Display a dot that moves along the graph, updating its position as \( t \) changes.","from manim import *

class PolygonOnAxes(Scene):
    def get_rectangle_corners(self, bottom_left, top_right):
        return [
            (top_right[0], top_right[1]),
            (bottom_left[0], top_right[1]),
            (bottom_left[0], bottom_left[1]),
            (top_right[0], bottom_left[1]),
        ]

    def construct(self):
        ax = Axes(
            x_range=[0, 10],
            y_range=[0, 10],
            x_length=6,
            y_length=6,
            axis_config={""include_tip"": False},
        )

        t = ValueTracker(5)
        k = 25

        graph = ax.plot(
            lambda x: k / x,
            color=YELLOW_D,
            x_range=[k / 10, 10.0, 0.01],
            use_smoothing=False,
        )

        def get_rectangle():
            polygon = Polygon(
                *[
                    ax.c2p(*i)
                    for i in self.get_rectangle_corners(
                        (0, 0), (t.get_value(), k / t.get_value())
                    )
                ]
            )
            polygon.stroke_width = 1
            polygon.set_fill(BLUE, opacity=0.5)
            polygon.set_stroke(YELLOW_B)
            return polygon

        polygon = always_redraw(get_rectangle)

        dot = Dot()
        dot.add_updater(lambda x: x.move_to(ax.c2p(t.get_value(), k / t.get_value())))
        dot.set_z_index(10)

        self.add(ax, graph, dot)
        self.play(Create(polygon))
        self.play(t.animate.set_value(10))
        self.play(t.animate.set_value(k / 10))
        self.play(t.animate.set_value(5))",Intermediate,train
,"Display the text “Welcome to” at the center of the screen, followed by the Manim logo banner appearing below it. The text is written with a smooth animation that continues updating as it's being drawn, and after a short pause, the banner expands into view with a quick animation, completing the welcoming scene.","from manim import *

class WelcomeToManim(Scene):
    def construct(self):
        words = Text(""Welcome to"")
        banner = ManimBanner().scale(0.5)
        VGroup(words, banner).arrange(DOWN)

        turn_animation_into_updater(Write(words, run_time=0.9))
        self.add(words)
        self.wait(0.5)
        self.play(banner.expand(), run_time=0.5)",Basic,train
,"Display a set of axes with labels \(\Delta Q\) for the x-axis and \(T[^\circ C]\) for the y-axis. Plot a line graph with points at (0, 20), (8, 0), (38, 0), and (39, -5).","from manim import *

class HeatDiagramPlot(Scene):
    def construct(self):
        ax = Axes(
            x_range=[0, 40, 5],
            y_range=[-8, 32, 5],
            x_length=9,
            y_length=6,
            x_axis_config={""numbers_to_include"": np.arange(0, 40, 5)},
            y_axis_config={""numbers_to_include"": np.arange(-5, 34, 5)},
            tips=False,
        )
        labels = ax.get_axis_labels(
            x_label=Tex(r""$\Delta Q$""), y_label=Tex(r""T[$^\circ C$]"")
        )

        x_vals = [0, 8, 38, 39]
        y_vals = [20, 0, 0, -5]
        graph = ax.plot_line_graph(x_values=x_vals, y_values=y_vals)

        self.add(ax, labels, graph)",Intermediate,train
,"Display two semi-transparent squares: a blue one on the left and a green one on the right. Over two seconds, rotate the blue square 180 degrees using an animation tied to its position, and simultaneously rotate the green square 180 degrees using a direct rotation. Then pause.","from manim import *

class DifferentRotations(Scene):
    def construct(self):
        left_square = Square(color=BLUE, fill_opacity=0.7).shift(2 * LEFT)
        right_square = Square(color=GREEN, fill_opacity=0.7).shift(2 * RIGHT)
        self.play(
            left_square.animate.rotate(PI), Rotate(right_square, angle=PI), run_time=2
        )
        self.wait()",Basic,train
,Display a mathematical expression representing the Taylor series expansion of \( e^x \). All instances of the variable \( x \) in the equation are colored yellow.,"from manim import *

class IncorrectLaTeXSubstringColoring(Scene):
    def construct(self):
        equation = MathTex(
            r""e^x = x^0 + x^1 + \frac{1}{2} x^2 + \frac{1}{6} x^3 + \cdots + \frac{1}{n!} x^n + \cdots""
        )
        equation.set_color_by_tex(""x"", YELLOW)
        self.add(equation)",Basic,train
,"Display a six-pointed star (hexagram) formed by two overlapping triangles—one pointing upward and the other downward. A dot appears and smoothly moves along the outline of the star, tracing its shape over time before disappearing.","from manim import *

import numpy as np

class PolygramExample(Scene):
    def construct(self):
        hexagram = Polygram(
            [[0, 2, 0], [-np.sqrt(3), -1, 0], [np.sqrt(3), -1, 0]],
            [[-np.sqrt(3), 1, 0], [0, -2, 0], [np.sqrt(3), 1, 0]],
        )
        self.add(hexagram)

        dot = Dot()
        self.play(MoveAlongPath(dot, hexagram), run_time=5, rate_func=linear)
        self.remove(dot)
        self.wait()",Basic,train
,"Display a 3D coordinate system with a straight line extending from the origin (0, 0, 0) to the point (2, 2, 2). The line is rendered in 3D space, showing its diagonal orientation across all three axes. The camera is set at a 75° vertical angle and a 30° horizontal angle, providing a tilted perspective that clearly reveals the line’s direction and depth.","from manim import *

class ExampleLine3D(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        line = Line3D(start=np.array([0, 0, 0]), end=np.array([2, 2, 2]))
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        self.add(axes, line)",Basic,train
,"Display a set of coordinate axes with a cyan-colored parametric curve in the shape of a cardioid. The curve is traced using the parametric equations involving exponential and trigonometric functions, forming a heart-like shape that loops around the origin.","from manim import *

class ParametricCurveExample(Scene):
    def construct(self):
        ax = Axes()
        cardioid = ax.plot_parametric_curve(
            lambda t: np.array(
                [
                    np.exp(1) * np.cos(t) * (1 - np.cos(t)),
                    np.exp(1) * np.sin(t) * (1 - np.cos(t)),
                    0,
                ]
            ),
            t_range=[0, 2 * PI],
            color=""#0FF1CE"",
        )
        self.add(ax, cardioid)",Intermediate,train
,"Display a 2×2 table with row and column labels. All four cell entries are colored with randomly chosen bright colors, and the bottom-right cell is additionally rotated upside down.","from manim import *

class GetEntriesExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        ent = table.get_entries()
        for item in ent:
            item.set_color(random_bright_color())
        table.get_entries((2,2)).rotate(PI)
        self.add(table)",Basic,train
,"Display a filled square and a triangle side by side, with the square on the left. As the animation begins, the square continuously shifts to the right at a steady pace. Meanwhile, the triangle gradually becomes visible by increasing its fill opacity. The square keeps moving as long as the animation is active.","from manim import *

class ShiftingSquare(Scene):
    def construct(self):
        sq = Square().set_fill(opacity=1)
        tri = Triangle()
        VGroup(sq, tri).arrange(LEFT)

        # construct a square which is continuously
        # shifted to the right
        always_shift(sq, RIGHT, rate=5)

        self.add(sq)
        self.play(tri.animate.set_fill(opacity=1))",Basic,train
,"Display a red 3D helical spring-like curve winding upward along the z-axis, defined by the parametric equations \((1.2 \cos(u), 1.2 \sin(u), 0.05u)\) for \(u\) ranging from \(-3\tau\) to \(5\tau\), overlaid on a 3D coordinate axis. The camera is set to an angled perspective, and the scene appears without animation.","from manim import *

class ThreeDParametricSpring(ThreeDScene):
    def construct(self):
        curve1 = ParametricFunction(
            lambda u: (
                1.2 * np.cos(u),
                1.2 * np.sin(u),
                u * 0.05
            ), color=RED, t_range = (-3*TAU, 5*TAU, 0.01)
        ).set_shade_in_3d(True)
        axes = ThreeDAxes()
        self.add(axes, curve1)
        self.set_camera_orientation(phi=80 * DEGREES, theta=-60 * DEGREES)
        self.wait()",Intermediate,train
,"Display a vertical list of the text “Open Sans” in various font weights, arranged from lightest to heaviest. Each line uses the corresponding weight style (e.g., Thin, Light, Regular, Bold, Black) to visually demonstrate the differences in font thickness. The entire group is scaled down to fit neatly on the screen.","from manim import *

class DifferentWeight(Scene):
    def construct(self):
        import manimpango

        g = VGroup()
        weight_list = dict(
            sorted(
                {
                    weight: manimpango.Weight(weight).value
                    for weight in manimpango.Weight
                }.items(),
                key=lambda x: x[1],
            )
        )
        for weight in weight_list:
            g += Text(weight.name, weight=weight.name, font=""Open Sans"")
        self.add(g.arrange(DOWN).scale(0.5))",Intermediate,train
,"Display a streamlines vector field where each line flows continuously according to a sine and cosine-based function. The streamlines animate smoothly across the screen at a moderate speed, simulating fluid motion for a duration determined by the virtual time and flow speed settings.","from manim import *

class ContinuousMotion(Scene):
    def construct(self):
        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT
        stream_lines = StreamLines(func, stroke_width=3, max_anchors_per_line=30)
        self.add(stream_lines)
        stream_lines.start_animation(warm_up=False, flow_speed=1.5)
        self.wait(stream_lines.virtual_time / stream_lines.flow_speed)",Intermediate,train
,"Display a graph with five connected nodes initially arranged in a straight horizontal line. After being created, the graph smoothly transitions into a circular layout, repositioning the nodes evenly around a circle while maintaining their connections.","from manim import *

class ChangeGraphLayout(Scene):
    def construct(self):
        G = Graph([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)],
                  layout={1: [-2, 0, 0], 2: [-1, 0, 0], 3: [0, 0, 0],
                          4: [1, 0, 0], 5: [2, 0, 0]}
                  )
        self.play(Create(G))
        self.play(G.animate.change_layout(""circular""))
        self.wait()",Intermediate,train
,"Display a coordinate axes system with a blue parabola representing the function \( y = \frac{1}{4}x^2 \). At the point where \( x = 2 \), a red secant line is drawn to approximate the slope over an interval of \( dx = 1.0 \). A green horizontal line represents the change in \( x \), labeled “dx = 1.0”, and a vertical line represents the change in \( y \), labeled “dy”. These elements together illustrate the concept of a secant slope on the curve.","from manim import *

class GetSecantSlopeGroupExample(Scene):
    def construct(self):
        ax = Axes(y_range=[-1, 7])
        graph = ax.plot(lambda x: 1 / 4 * x ** 2, color=BLUE)
        slopes = ax.get_secant_slope_group(
            x=2.0,
            graph=graph,
            dx=1.0,
            dx_label=Tex(""dx = 1.0""),
            dy_label=""dy"",
            dx_line_color=GREEN_B,
            secant_line_length=4,
            secant_line_color=RED_D,
        )

        self.add(ax, graph, slopes)",Intermediate,train
,"Display four overlapping objects with different colors and vertical positions, each assigned a specific `z_index` to control their layering:

- A red text reading “z_index = 3” appears at the top and is visually in front of all other objects.
- A solid blue square is layered behind the text.
- A blue LaTeX-style text reading “zIndex = 1” appears below the square and is layered behind it.
- A green filled circle, with no specified `z_index` (defaulting to 0), appears behind all other objects.

The visual stacking order is determined by the `z_index` values, from highest (front) to lowest (back).","from manim import *

class SetZIndex(Scene):
    def construct(self):
        text = Text('z_index = 3', color = PURE_RED).shift(UP).set_z_index(3)
        square = Square(2, fill_opacity=1).set_z_index(2)
        tex = Tex(r'zIndex = 1', color = PURE_BLUE).shift(DOWN).set_z_index(1)
        circle = Circle(radius = 1.7, color = GREEN, fill_opacity = 1) # z_index = 0

        # Displaying order is now defined by z_index values
        self.add(text)
        self.add(square)
        self.add(tex)
        self.add(circle)",Intermediate,train
,"Display the word ""Hello"" in which all letters except the first and last are blue, positioned to the left. Next to it on the right, display the word ""World"" with the letters ""r"" and ""l"" in red.","from manim import *

class Textt2cExample(Scene):
    def construct(self):
        t2cindices = Text('Hello', t2c={'[1:-1]': BLUE}).move_to(LEFT)
        t2cwords = Text('World',t2c={'rl':RED}).next_to(t2cindices, RIGHT)
        self.add(t2cindices, t2cwords)",Basic,train
,"Display a block of placeholder text (""Lorem ipsum..."") in two formats:

1. Initially, the text appears left-aligned under the title ""Not Justified"".
2. Then, the left-aligned text and its title fade out while a new version of the same text fades in, now fully justified (aligned evenly along both left and right margins), under the title ""Justified"".

The transition visually contrasts the difference between non-justified and justified text formatting.","from manim import *

class JustifyText(Scene):
    def construct(self):
        ipsum_text = (
            ""Lorem ipsum dolor sit amet, consectetur adipiscing elit.""
            ""Praesent feugiat metus sit amet iaculis pulvinar. Nulla posuere ""
            ""quam a ex aliquam, eleifend consectetur tellus viverra. Aliquam ""
            ""fermentum interdum justo, nec rutrum elit pretium ac. Nam quis ""
            ""leo pulvinar, dignissim est at, venenatis nisi.""
        )
        justified_text = MarkupText(ipsum_text, justify=True).scale(0.4)
        not_justified_text = MarkupText(ipsum_text, justify=False).scale(0.4)
        just_title = Title(""Justified"")
        njust_title = Title(""Not Justified"")
        self.add(njust_title, not_justified_text)
        self.play(
            FadeOut(not_justified_text),
            FadeIn(justified_text),
            FadeOut(njust_title),
            FadeIn(just_title),
        )
        self.wait(1)",Intermediate,train
,"Display the Tamil greeting ""வணக்கம்"" (meaning ""Hello"") in a sans-serif font. The text is written onto the screen with a smooth animation effect, then remains visible for two seconds.","from manim import *

class PangoRender(Scene):
    def construct(self):
        morning = Text(""வணக்கம்"", font=""sans-serif"")
        self.play(Write(morning))
        self.wait(2)",Basic,train
,"Display two colored sectors on screen: a red sector with a full 360-degree angle centered on the right, and a pink sector with a 60-degree angle positioned to the left.","from manim import *

class ExampleSector(Scene):
    def construct(self):
        sector = Sector(radius=2)
        sector2 = Sector(radius=2.5, angle=60*DEGREES).move_to([-3, 0, 0])
        sector.set_color(RED)
        sector2.set_color(PINK)
        self.add(sector, sector2)",Basic,train
,"Display a bulleted list with three items—“Item 1,” “Item 2,” and “Item 3”—arranged within a 2×2 area. Each item is colored differently: “Item 1” in red, “Item 2” in green, and “Item 3” in blue. The list appears centered on the screen.","from manim import *

class BulletedListExample(Scene):
    def construct(self):
        blist = BulletedList(""Item 1"", ""Item 2"", ""Item 3"", height=2, width=2)
        blist.set_color_by_tex(""Item 1"", RED)
        blist.set_color_by_tex(""Item 2"", GREEN)
        blist.set_color_by_tex(""Item 3"", BLUE)
        self.add(blist)",Basic,train
,"Display a 3D coordinate system with two lines:

1. A red line extending from the point (2, 0, 0) to the point (0, 1, 1), angled diagonally through space.
2. A blue line that is perpendicular to the red line, automatically generated to intersect it at a right angle.

The camera is set at a vertical angle of \( \frac{\pi}{3} \) and a horizontal angle of \( -\frac{\pi}{4} \), providing a tilted view that clearly shows the perpendicular relationship between the two lines in 3D space.","from manim import *

class PerpLineExample(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(PI / 3, -PI / 4)
        ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)
        line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)
        line2 = Line3D.perpendicular_to(line1, color=BLUE)
        self.add(ax, line1, line2)",Basic,train
"Display a large pi symbol, a green filled circle, and a blue filled square grouped together. Then animate the entire group spiraling into view onto the screen.","Display a green filled circle, and a blue filled square grouped together. Then animate the entire group spiraling into view onto the screen.","from manim import *

class SpiralInExample(Scene):
    def construct(self):
        pi = MathTex(r""\pi"").scale(7)
        pi.shift(2.25 * LEFT + 1.5 * UP)
        circle = Circle(color=GREEN_C, fill_opacity=1).shift(LEFT)
        square = Square(color=BLUE_D, fill_opacity=1).shift(UP)
        shapes = VGroup(pi, circle, square)
        self.play(SpiralIn(shapes))",Basic,train
,"Display a bipartite graph with four nodes arranged in two partitions. Nodes 0 and 1 are placed on one side, and nodes 2 and 3 on the other. Edges connect node 0 to nodes 2 and 3, and node 1 to node 2, visually emphasizing the two-part structure of the graph.","from manim import *

import networkx as nx

class PartiteGraph(Scene):
    def construct(self):
        G = nx.Graph()
        G.add_nodes_from([0, 1, 2, 3])
        G.add_edges_from([(0, 2), (0,3), (1, 2)])
        graph = Graph(list(G.nodes), list(G.edges), layout=""partite"", partitions=[[0, 1]])
        self.play(Create(graph))",Basic,train
,"Display a graph with six labeled nodes arranged in three vertical partitions: nodes 1 and 2 in the first column, nodes 3 and 4 in the second, and nodes 5 and 6 in the third. The nodes are connected by a mix of sequential and cross-partition edges, forming a complex, interconnected structure that spans across all three partitions.","from manim import *

class PartiteLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout=""partite"",
            layout_config={""partitions"": [[1,2],[3,4],[5,6]]},
            labels=True
        )
        self.add(graph)",Intermediate,train
,"Display three styled shapes with specific layering: a pink-filled triangle with 50% transparency on the right, a fully yellow-filled square above the center, and a circle with a thick green outline on the left. The triangle appears on top, followed by the square, and the circle is at the bottom layer. Pause for one second.","from manim import *

class MobjectZOrder(Scene):
    def construct(self):
        circle = Circle().shift(LEFT)
        square = Square().shift(UP)
        triangle = Triangle().shift(RIGHT)

        circle.set_stroke(color=GREEN, width=20)
        square.set_fill(YELLOW, opacity=1.0)
        triangle.set_fill(PINK, opacity=0.5)

        self.add(triangle, square, circle)
        self.wait(1)",Basic,train
,"Display a complex plane with a red point cloud dot centered on it. After a brief pause, animate the dot as it transforms according to the complex exponential function \( f(z) = e^z \), creating a dynamic visual effect that warps the dot's shape across the plane.","from manim import *

class PointCloudDotExample2(Scene):
    def construct(self):
        plane = ComplexPlane()
        cloud = PointCloudDot(color=RED)
        self.add(
            plane, cloud
        )
        self.wait()
        self.play(
            cloud.animate.apply_complex_function(lambda z: np.exp(z))
        )",Intermediate,train
,"Display the text “Circum- scribe” in large font. Then animate several variations of the circumscribe effect around the text:

1. Draw a default border around the text.
2. Draw a circular border instead of the default shape.
3. Draw a border that fades out after appearing.
4. Animate a slower border drawing with a longer duration.
5. Draw a circular border that fades out after appearing.","from manim import *

class UsingCircumscribe(Scene):
    def construct(self):
        lbl = Tex(r""Circum-\\scribe"").scale(2)
        self.add(lbl)
        self.play(Circumscribe(lbl))
        self.play(Circumscribe(lbl, Circle))
        self.play(Circumscribe(lbl, fade_out=True))
        self.play(Circumscribe(lbl, time_width=2))
        self.play(Circumscribe(lbl, Circle, True))",Basic,train
,"Display a tree graph with seven labeled nodes arranged hierarchically. Node 1 is the root at the top, branching into nodes 2 and 3. Node 2 further branches into nodes 4 and 5, while node 3 branches into nodes 6 and 7. The layout clearly shows the parent-child relationships in a balanced tree structure.","from manim import *

class TreeLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6, 7],
            [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],
            layout=""tree"",
            layout_config={""root_vertex"": 1},
            labels=True
        )
        self.add(graph)",Intermediate,train
,"Display a set of axes with labels ""x"" and ""f(x)"". Plot the function \( f(x) = 2(x - 5)^2 \) in maroon. Show a dot on the graph that moves to the minimum point of the function.","from manim import *

class ArgMinExample(Scene):
    def construct(self):
        ax = Axes(
            x_range=[0, 10], y_range=[0, 100, 10], axis_config={""include_tip"": False}
        )
        labels = ax.get_axis_labels(x_label=""x"", y_label=""f(x)"")

        t = ValueTracker(0)

        def func(x):
            return 2 * (x - 5) ** 2
        graph = ax.plot(func, color=MAROON)

        initial_point = [ax.coords_to_point(t.get_value(), func(t.get_value()))]
        dot = Dot(point=initial_point)

        dot.add_updater(lambda x: x.move_to(ax.c2p(t.get_value(), func(t.get_value()))))
        x_space = np.linspace(*ax.x_range[:2],200)
        minimum_index = func(x_space).argmin()

        self.add(ax, labels, graph, dot)
        self.play(t.animate.set_value(x_space[minimum_index]))
        self.wait()",Intermediate,train
,"Display a large circle with two tangent lines:

1. A blue tangent line touching the circle on the right side.
2. A green tangent line touching the circle at an upper-left point.

Both lines extend outward from their points of contact, illustrating tangents at different positions on the circle.","from manim import *

class TangentLineExample(Scene):
    def construct(self):
        circle = Circle(radius=2)
        line_1 = TangentLine(circle, alpha=0.0, length=4, color=BLUE_D) # right
        line_2 = TangentLine(circle, alpha=0.4, length=4, color=GREEN) # top left
        self.add(circle, line_1, line_2)",Basic,train
,"Display three groups of arrows demonstrating different arrow properties:

1. The first group shows two gold arrows pointing left—one with a default triangular tip and one with a square tip—stacked vertically.
2. The second group shows two right-pointing arrows near a maroon square—one with default spacing from the square and one with no spacing (buff), placed just above the first group.
3. The third group shows two vertical arrows on the left side—one long arrow extending from the center to the top of the screen, and one shorter arrow with a smaller tip and thinner stroke, both aligned vertically.

All three groups are arranged horizontally with space between them.","from manim import *

from manim.mobject.geometry.tips import ArrowSquareTip
class ArrowExample(Scene):
    def construct(self):
        arrow_1 = Arrow(start=RIGHT, end=LEFT, color=GOLD)
        arrow_2 = Arrow(start=RIGHT, end=LEFT, color=GOLD, tip_shape=ArrowSquareTip).shift(DOWN)
        g1 = Group(arrow_1, arrow_2)

        # the effect of buff
        square = Square(color=MAROON_A)
        arrow_3 = Arrow(start=LEFT, end=RIGHT)
        arrow_4 = Arrow(start=LEFT, end=RIGHT, buff=0).next_to(arrow_1, UP)
        g2 = Group(arrow_3, arrow_4, square)

        # a shorter arrow has a shorter tip and smaller stroke width
        arrow_5 = Arrow(start=ORIGIN, end=config.top).shift(LEFT * 4)
        arrow_6 = Arrow(start=config.top + DOWN, end=config.top).shift(LEFT * 3)
        g3 = Group(arrow_5, arrow_6)

        self.add(Group(g1, g2, g3).arrange(buff=2))",Intermediate,train
,"Display two lines of text arranged vertically:

1. The first line shows the word ""floating"" where ""float"" begins with the ""fl"" ligature (a combined character), and ""oat"" is styled with a red-to-green gradient.
2. The second line displays the same word ""floating"", but with ligatures disabled—so ""f"" and ""l"" appear as separate characters. The ""oat"" portion still has the red-to-green gradient.

This comparison highlights the visual difference between using and disabling ligatures in styled text.","from manim import *

class NoLigaturesExample(Scene):
    def construct(self):
        text1 = MarkupText('fl<gradient from=""RED"" to=""GREEN"">oat</gradient>ing')
        text2 = MarkupText('fl<gradient from=""RED"" to=""GREEN"">oat</gradient>ing', disable_ligatures=True)
        group = VGroup(text1, text2).arrange(DOWN)
        self.add(group)",Basic,train
,Display the text “Noto Sans” centered on the screen using the “Noto Sans” font.,"from manim import *

class FontsExample(Scene):
    def construct(self):
        ft = Text(""Noto Sans"", font=""Noto Sans"")
        self.add(ft)",Basic,train
Display 3D axes. Show a red checkerboard-patterned sphere. Move the light source to a new position. Set the camera orientation to a specific angle. ,Display 3D axes. Show a red checkerboard-patterned sphere. Place the light source above the sphere. Set the camera orientation to a specific angle. ,"from manim import *

class ThreeDLightSourcePosition(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        sphere = Surface(
            lambda u, v: np.array([
                1.5 * np.cos(u) * np.cos(v),
                1.5 * np.cos(u) * np.sin(v),
                1.5 * np.sin(u)
            ]), v_range=[0, TAU], u_range=[-PI / 2, PI / 2],
            checkerboard_colors=[RED_D, RED_E], resolution=(15, 32)
        )
        self.renderer.camera.light_source.move_to(3*IN) # changes the source of the light
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        self.add(axes, sphere)",Intermediate,train
,"Display three circles arranged horizontally across the screen: a plain black circle on the left, a larger green-outlined circle in the center, and a fully filled blue circle on the right.","from manim import *

class CircleExample(Scene):
    def construct(self):
        circle_1 = Circle(radius=1.0)
        circle_2 = Circle(radius=1.5, color=GREEN)
        circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)

        circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)
        self.add(circle_group)",Basic,train
,"Display a pink circle with 50% transparency centered on the screen. Then, show a blue square with 50% transparency positioned to the right of the circle, with a small gap between them.","
from manim import *

class SquareAndCircle(Scene):
    def construct(self):
        circle = Circle()  # create a circle
        circle.set_fill(PINK, opacity=0.5)  # set the color and transparency

        square = Square()  # create a square
        square.set_fill(BLUE, opacity=0.5)  # set the color and transparency

        square.next_to(circle, RIGHT, buff=0.5)  # set the position
        self.play(Create(circle), Create(square))  # show the shapes on screen",Basic,train
,Display the text “Focusing on the dot below:” at the top of the screen with a yellow dot positioned below it. Then animate a spotlight effect that highlights and draws attention to the dot.,"from manim import *

class UsingFocusOn(Scene):
    def construct(self):
        dot = Dot(color=YELLOW).shift(DOWN)
        self.add(Tex(""Focusing on the dot below:""), dot)
        self.play(FocusOn(dot))
        self.wait()",Basic,train
,"Create a closed shape by connecting four points in a square-like path using lines. Display text in the top-right corner showing the start, end, and center coordinates of the shape. Highlight the start point with a yellow dot, the end point with a red dot, the topmost point with a light green dot, the bottommost point with a dark green dot, the center with a blue dot, and the midpoint of the shape with an orange dot. Also, place small dots at every point that makes up the shape’s outline. Finally, display the shape itself.","from manim import *

class MobjectExample(Scene):
    def construct(self):
        p1 = [-1,-1, 0]
        p2 = [ 1,-1, 0]
        p3 = [ 1, 1, 0]
        p4 = [-1, 1, 0]
        a  = Line(p1,p2).append_points(Line(p2,p3).points).append_points(Line(p3,p4).points)
        point_start  = a.get_start()
        point_end    = a.get_end()
        point_center = a.get_center()
        self.add(Text(f""a.get_start() = {np.round(point_start,2).tolist()}"", font_size=24).to_edge(UR).set_color(YELLOW))
        self.add(Text(f""a.get_end() = {np.round(point_end,2).tolist()}"", font_size=24).next_to(self.mobjects[-1],DOWN).set_color(RED))
        self.add(Text(f""a.get_center() = {np.round(point_center,2).tolist()}"", font_size=24).next_to(self.mobjects[-1],DOWN).set_color(BLUE))

        self.add(Dot(a.get_start()).set_color(YELLOW).scale(2))
        self.add(Dot(a.get_end()).set_color(RED).scale(2))
        self.add(Dot(a.get_top()).set_color(GREEN_A).scale(2))
        self.add(Dot(a.get_bottom()).set_color(GREEN_D).scale(2))
        self.add(Dot(a.get_center()).set_color(BLUE).scale(2))
        self.add(Dot(a.point_from_proportion(0.5)).set_color(ORANGE).scale(2))
        self.add(*[Dot(x) for x in a.points])
        self.add(a)",Intermediate,train
,"Display a line of text in red that reads: ""double green underline in red text except this"". The phrase ""double green underline"" is underlined with a double green line, and the words ""except this"" are colored yellow.","from manim import *

class MarkupTest(Scene):
    def construct(self):
        text = MarkupText(
            f'<span underline=""double"" underline_color=""green"">double green underline</span> in red text<span fgcolor=""{YELLOW}""> except this</span>',
            color=RED,
            font_size=34
        )
        self.add(text)",Basic,train
,"Display a vector field using arrows, where each arrow's direction is determined by a sine and cosine-based function. Initially, the arrows are evenly spaced along the x-axis from -7 to 7 with default lengths. Then, the arrows smoothly transform to new lengths based on a custom scaling function, making them shorter or longer depending on their original magnitude.","from manim import *

class SizingAndSpacing(Scene):
    def construct(self):
        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT
        vf = ArrowVectorField(func, x_range=[-7, 7, 1])
        self.add(vf)
        self.wait()

        length_func = lambda x: x / 3
        vf2 = ArrowVectorField(func, x_range=[-7, 7, 1], length_func=length_func)
        self.play(vf.animate.become(vf2))
        self.wait()",Basic,train
,"Display the Pythagorean identity \( x^2 + y^2 = z^2 \) in large font, rendered using a French cursive LaTeX math font style.","from manim import *

class LaTeXMathFonts(Scene):
    def construct(self):
        tex = Tex(
            r""$x^2 + y^2 = z^2$"",
            tex_template=TexFontTemplates.french_cursive,
            font_size=144,
        )
        self.add(tex)",Basic,train
,"Display a diagonal line slanting upward from left to right, positioned toward the left side of the screen. Then, a flipped copy of the line appears, mirrored vertically, creating a symmetrical shape with the original.","from manim import *

class FlipExample(Scene):
    def construct(self):
        s= Line(LEFT, RIGHT+UP).shift(4*LEFT)
        self.add(s)
        s2= s.copy().flip()
        self.add(s2)",Basic,train
,Display a pink circle with 50% transparency centered on the screen.,"from manim import *

class CreateCircle(Scene):
    def construct(self):
        circle = Circle()  # create a circle
        circle.set_fill(PINK, opacity=0.5)  # set the color and transparency
        self.play(Create(circle))  # show the circle on screen",Basic,train
,"Display a square using a custom class that overrides the default `FadeIn` animation. Instead of fading in, the square is drawn using the `Create` animation when the scene plays.","from manim import *

class MySquare(Square):
    @override_animation(FadeIn)
    def _fade_in_override(self, **kwargs):
        return Create(self, **kwargs)

class OverrideAnimationExample(Scene):
    def construct(self):
        self.play(FadeIn(MySquare()))",Basic,train
,"Display four colored dots in the corners of a square: blue at top-left, maroon at bottom-left, green at bottom-right, and yellow at top-right. Then animate each dot moving in succession to the position of the next: blue moves to maroon’s position, maroon to green’s, green to yellow’s, and yellow to blue’s original position.","from manim import *

class SuccessionExample(Scene):
    def construct(self):
        dot1 = Dot(point=LEFT * 2 + UP * 2, radius=0.16, color=BLUE)
        dot2 = Dot(point=LEFT * 2 + DOWN * 2, radius=0.16, color=MAROON)
        dot3 = Dot(point=RIGHT * 2 + DOWN * 2, radius=0.16, color=GREEN)
        dot4 = Dot(point=RIGHT * 2 + UP * 2, radius=0.16, color=YELLOW)
        self.add(dot1, dot2, dot3, dot4)

        self.play(Succession(
            dot1.animate.move_to(dot2),
            dot2.animate.move_to(dot3),
            dot3.animate.move_to(dot4),
            dot4.animate.move_to(dot1)
        ))",Intermediate,train
,"Display a dot positioned at the upper left. Then animate the text “FadeOut with shift or target_position and scale” disappearing in four parts: the first part fades out normally, the second fades out while shifting downward, the third fades out while moving toward the dot, and the fourth fades out while scaling down. Each part disappears with a delay between them.","from manim import *

class FadeInExample(Scene):
    def construct(self):
        dot = Dot(UP * 2 + LEFT)
        self.add(dot)
        tex = Tex(
            ""FadeOut with "", ""shift "", r"" or target\_position"", "" and scale""
        ).scale(1)
        animations = [
            FadeOut(tex[0]),
            FadeOut(tex[1], shift=DOWN),
            FadeOut(tex[2], target_position=dot),
            FadeOut(tex[3], scale=0.5),
        ]
        self.play(AnimationGroup(*animations, lag_ratio=0.5))",Basic,train
,"Display a mathematical formula centered on screen:  
$$\int_a^b f'(x)\, dx = f(b) - f(a)$$  
This represents the Fundamental Theorem of Calculus, showing the relationship between a function’s derivative and its definite integral.","from manim import *

class Formula(Scene):
    def construct(self):
        t = MathTex(r""\int_a^b f'(x) dx = f(b)- f(a)"")
        self.add(t)",Basic,train
,"Animate the creation of a 2×2 table with row and column labels and outer borders. The table appears gradually on screen, then remains visible during a brief pause.","from manim import *

class CreateTableExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")],
            include_outer_lines=True)
        self.play(table.create())
        self.wait()",Basic,train
,"Display a large blue square with red edges, featuring four smaller shapes cut out from it: a triangle in the lower right, a small square in the upper right, a pentagon in the lower left, and a hexagon in the upper left. The cutouts create transparent holes in the larger square, revealing the background.","from manim import *

class CutoutExample(Scene):
    def construct(self):
        s1 = Square().scale(2.5)
        s2 = Triangle().shift(DOWN + RIGHT).scale(0.5)
        s3 = Square().shift(UP + RIGHT).scale(0.5)
        s4 = RegularPolygon(5).shift(DOWN + LEFT).scale(0.5)
        s5 = RegularPolygon(6).shift(UP + LEFT).scale(0.5)
        c = Cutout(s1, s2, s3, s4, s5, fill_opacity=1, color=BLUE, stroke_color=RED)
        self.play(Write(c), run_time=4)
        self.wait()",Intermediate,train
,"Display a 3D scene with the camera angled slightly from above and to the side. Show three colored spheres: a small red sphere positioned to the right, a large green sphere placed in the lower-left area, and a large blue sphere located in the upper-left area. All spheres appear simultaneously and remain static in the scene.","from manim import *

class ExampleSphere(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=PI / 6, theta=PI / 6)
        sphere1 = Sphere(
            center=(3, 0, 0),
            radius=1,
            resolution=(20, 20),
            u_range=[0.001, PI - 0.001],
            v_range=[0, TAU]
        )
        sphere1.set_color(RED)
        self.add(sphere1)
        sphere2 = Sphere(center=(-1, -3, 0), radius=2, resolution=(18, 18))
        sphere2.set_color(GREEN)
        self.add(sphere2)
        sphere3 = Sphere(center=(-1, 2, 0), radius=2, resolution=(16, 16))
        sphere3.set_color(BLUE)
        self.add(sphere3)",Basic,train
,"Display the Manim logo banner animation:  
- First, the banner is drawn on screen.  
- Then, it expands in size.  
- After a brief pause, the banner is smoothly removed using an unwrite animation.","from manim import *

class DarkThemeBanner(Scene):
    def construct(self):
        banner = ManimBanner()
        self.play(banner.create())
        self.play(banner.expand())
        self.wait()
        self.play(Unwrite(banner))",Basic,train
,"Display a graph with four connected nodes in a default layout. After being created, each node animates to a new position forming a square: node 1 moves to the upper right, node 2 to the upper left, node 3 to the lower right, and node 4 to the lower left. The edges adjust accordingly to maintain the connections between the repositioned nodes.","from manim import *

class MovingVertices(Scene):
    def construct(self):
        vertices = [1, 2, 3, 4]
        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]
        g = Graph(vertices, edges)
        self.play(Create(g))
        self.wait()
        self.play(g[1].animate.move_to([1, 1, 0]),
                  g[2].animate.move_to([-1, 1, 0]),
                  g[3].animate.move_to([1, -1, 0]),
                  g[4].animate.move_to([-1, -1, 0]))
        self.wait()",Intermediate,train
,"Display the word “Deleting” in purple text on the left side of the screen, with a grey cursor positioned at the start. Animate the text being erased character by character with the cursor moving along, then make the cursor blink twice.","from manim import *

class DeletingTextExample(Scene):
    def construct(self):
        text = Text(""Deleting"", color=PURPLE).scale(1.5).to_edge(LEFT)
        cursor = Rectangle(
            color = GREY_A,
            fill_color = GREY_A,
            fill_opacity = 1.0,
            height = 1.1,
            width = 0.5,
        ).move_to(text[0]) # Position the cursor

        self.play(UntypeWithCursor(text, cursor))
        self.play(Blink(cursor, blinks=2))",Basic,train
,"Display a 3D coordinate system and render a colorful surface defined by the equation \( z = 2\sin(x) + 2\cos(y) \). The surface spans from \(-3\) to \(3\) along both the x- and y-axes and is colored using a gradient from blue to red. The camera is angled to provide a clear view of the surface’s undulating, wave-like shape.","from manim import *

class PlotSurfaceExample(ThreeDScene):
    def construct(self):
        resolution_fa = 16
        self.set_camera_orientation(phi=75 * DEGREES, theta=-60 * DEGREES)
        axes = ThreeDAxes(x_range=(-3, 3, 1), y_range=(-3, 3, 1), z_range=(-5, 5, 1))
        def param_trig(u, v):
            x = u
            y = v
            z = 2 * np.sin(x) + 2 * np.cos(y)
            return z
        trig_plane = axes.plot_surface(
            param_trig,
            resolution=(resolution_fa, resolution_fa),
            u_range = (-3, 3),
            v_range = (-3, 3),
            colorscale = [BLUE, GREEN, YELLOW, ORANGE, RED],
            )
        self.add(axes, trig_plane)",Advanced,train
,"Display the text ""Hello World!"" at the center of the screen, then animate it scaling up to twice its original size while remaining anchored in place.","from manim import *

class ScaleInPlaceExample(Scene):
    def construct(self):
        self.play(ScaleInPlace(Text(""Hello World!""), 2))",Basic,train
,"Display a streamlines vector field where each line represents the flow of a custom vector function that subtly rotates and scales position vectors. The streamlines illustrate the continuous motion and direction of the field across the screen, without animation.","from manim import *

class BasicUsage(Scene):
    def construct(self):
        func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3
        self.add(StreamLines(func))",Basic,train
,"Display a multi-line mathematical derivation using the LaTeX align environment. The expression shows the function \( f(x) \) being simplified step by step: first as \( 3 + 2 + 1 \), then \( 5 + 1 \), and finally \( 6 \), with each step aligned at the equals sign.","from manim import *

class LaTeXAlignEnvironment(Scene):
    def construct(self):
        tex = MathTex(r'f(x) &= 3 + 2 + 1\\ &= 5 + 1 \\ &= 6', font_size=96)
        self.add(tex)",Basic,train
,"Display the text ""Hello World!"" at the center of the screen, then animate it shrinking rapidly into a single point at the center, creating a disappearing effect as if it's collapsing inward.","from manim import *

class ShrinkToCenterExample(Scene):
    def construct(self):
        self.play(ShrinkToCenter(Text(""Hello World!"")))",Basic,train
,"Display a solid red square at the center of the screen with four labeled dots placed around its corners:  
- A red-labeled dot with ""42"" at the upper left,  
- A green-labeled dot with ""a"" at the upper right,  
- A blue-labeled dot with ""ii"" at the lower left,  
- A default-labeled dot with ""3"" at the lower right.","from manim import *

class SeveralLabeledDots(Scene):
    def construct(self):
        sq = Square(fill_color=RED, fill_opacity=1)
        self.add(sq)
        dot1 = LabeledDot(Tex(""42"", color=RED))
        dot2 = LabeledDot(MathTex(""a"", color=GREEN))
        dot3 = LabeledDot(Text(""ii"", color=BLUE))
        dot4 = LabeledDot(""3"")
        dot1.next_to(sq, UL)
        dot2.next_to(sq, UR)
        dot3.next_to(sq, DL)
        dot4.next_to(sq, DR)
        self.add(dot1, dot2, dot3, dot4)",Basic,train
,"Display a solid red square on the left and a solid blue circle overlapping it from the top right. On the right side of the screen, show a green shape representing the exclusion—highlighting the non-overlapping regions of both the square and the circle, with the intersecting area removed.","from manim import *

class IntersectionExample(Scene):
    def construct(self):
        sq = Square(color=RED, fill_opacity=1)
        sq.move_to([-2, 0, 0])
        cr = Circle(color=BLUE, fill_opacity=1)
        cr.move_to([-1.3, 0.7, 0])
        un = Exclusion(sq, cr, color=GREEN, fill_opacity=1)
        un.move_to([1.5, 0.4, 0])
        self.add(sq, cr, un)",Basic,train
,"Display a complex plane with a dot initially positioned at the complex number \(-2 + 1i\). As the animation progresses, the dot moves smoothly to new positions based on updates to a complex value tracker:

1. Moves to \(3 + 2i\),
2. Rotates 90° counterclockwise by multiplying the value by \(i\),
3. Moves downward by subtracting \(2i\),
4. Finally, shifts again by dividing the current value by \(-2 + 3i\).

Each movement reflects the corresponding complex arithmetic operation visually on the plane.","from manim import *

class ComplexValueTrackerExample(Scene):
    def construct(self):
        tracker = ComplexValueTracker(-2+1j)
        dot = Dot().add_updater(
            lambda x: x.move_to(tracker.points)
        )

        self.add(NumberPlane(), dot)

        self.play(tracker.animate.set_value(3+2j))
        self.play(tracker.animate.set_value(tracker.get_value() * 1j))
        self.play(tracker.animate.set_value(tracker.get_value() - 2j))
        self.play(tracker.animate.set_value(tracker.get_value() / (-2 + 3j)))",Basic,train
,"Display a square at the center of the screen. First, the square is drawn. Then, it shifts to the right, doubles in size, rotates 90 degrees counterclockwise, and finally disappears.","from manim import *

class AnimateExample(Scene):
    def construct(self):
        s = Square()
        self.play(Create(s))
        self.play(s.animate.shift(RIGHT))
        self.play(s.animate.scale(2))
        self.play(s.animate.rotate(PI / 2))
        self.play(Uncreate(s))",Basic,train
,"Display three elbow-shaped connectors arranged horizontally:

1. The first is a standard elbow with default size and angle.
2. The second is a wider elbow with increased width.
3. The third is also wide but rotated to point diagonally downward to the left, showing a different angle.","from manim import *

class ElbowExample(Scene):
    def construct(self):
        elbow_1 = Elbow()
        elbow_2 = Elbow(width=2.0)
        elbow_3 = Elbow(width=2.0, angle=5*PI/4)

        elbow_group = Group(elbow_1, elbow_2, elbow_3).arrange(buff=1)
        self.add(elbow_group)",Basic,train
,"Display a semicircular arc centered on screen, starting from the right and sweeping counterclockwise to the left.","from manim import *

class ArcExample(Scene):
    def construct(self):
        self.add(Arc(angle=PI))",Basic,train
,Display a square at the center of the screen that continuously rotates clockwise at a rate of 90 degrees per second for two seconds.,"from manim import *

class DtUpdater(Scene):
    def construct(self):
        square = Square()

        #Let the square rotate 90° per second
        square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))
        self.add(square)
        self.wait(2)",Basic,train
,"Display three sample space rectangles arranged horizontally:

- The first is a large, fully opaque rectangle with thick borders.
- The second is a medium-sized rectangle with thinner borders and semi-transparent fill.
- The third is a small, nearly transparent square divided vertically into three segments with proportions 37%, 13%, and 50%, filled with black, white, and gray respectively.

All shapes appear on screen simultaneously without animation.","from manim import *

class ExampleSampleSpace(Scene):
    def construct(self):
        poly1 = SampleSpace(stroke_width=15, fill_opacity=1)
        poly2 = SampleSpace(width=5, height=3, stroke_width=5, fill_opacity=0.5)
        poly3 = SampleSpace(width=2, height=2, stroke_width=5, fill_opacity=0.1)
        poly3.divide_vertically(p_list=np.array([0.37, 0.13, 0.5]), colors=[BLACK, WHITE, GRAY], vect=RIGHT)
        poly_group = VGroup(poly1, poly2, poly3).arrange()
        self.add(poly_group)",Intermediate,train
,"Display a square at the center of the screen. Four braces are added to one side of the square, each with a different sharpness value ranging from 0.1 to 1.0. Next to each brace, a label indicates its corresponding sharpness value. All braces and labels are then arranged vertically with slight spacing between them.","from manim import *

class BraceExample(Scene):
    def construct(self):
        s = Square()
        self.add(s)
        for i in np.linspace(0.1,1.0,4):
            br = Brace(s, sharpness=i)
            t = Text(f""sharpness= {i}"").next_to(br, RIGHT)
            self.add(t)
            self.add(br)
        VGroup(*self.mobjects).arrange(DOWN, buff=0.2)",Basic,train
,"Display a row of evenly spaced dots extending horizontally across the screen. Below it, a second row appears, which is a shuffled version of the first—containing the same dots but in a random order. Both rows are written onto the screen simultaneously.","from manim import *

class ShuffleSubmobjectsExample(Scene):
    def construct(self):
        s= VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])
        s2= s.copy()
        s2.shuffle_submobjects()
        s2.shift(DOWN)
        self.play(Write(s), Write(s2))",Basic,train
,"Display a red circle defined by three specific points: one to the left, one diagonally up-left, and one directly above. The three defining points are marked with black dots, and a coordinate grid (NumberPlane) is shown in the background.","from manim import *

class CircleFromPointsExample(Scene):
    def construct(self):
        circle = Circle.from_three_points(LEFT, LEFT + UP, UP * 2, color=RED)
        dots = VGroup(
            Dot(LEFT),
            Dot(LEFT + UP),
            Dot(UP * 2),
        )
        self.add(NumberPlane(), circle, dots)",Basic,train
,"Display a 2×2 table with row and column labels. Each label—both row and column—is colored differently using blue, green, yellow, and red, making them visually distinct from the table entries.","from manim import *

class GetLabelsExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        lab = table.get_labels()
        colors = [BLUE, GREEN, YELLOW, RED]
        for k in range(len(colors)):
            lab[k].set_color(colors[k])
        self.add(table)",Basic,train
,"Display a row of six shapes arranged horizontally: a square, a circle, a triangle, and three dots. These shapes are added to a `VGroup` using a mix of individual objects, a list, and a generator expression, demonstrating that various iterable types can be combined into a single group.","from manim import *

class AddIterableToVGroupExample(Scene):
    def construct(self):
        v = VGroup(
            Square(),               # Singular VMobject instance
            [Circle(), Triangle()], # List of VMobject instances
            Dot(),
            (Dot() for _ in range(2)), # Iterable that generates VMobjects
        )
        v.arrange()
        self.add(v)",Basic,train
,"Display a grayscale image created from a 2×4 pixel array, where each pixel's brightness corresponds to its value. The image is scaled to a height of 7 units and shown centered on the screen.","from manim import *

class ImageFromArray(Scene):
    def construct(self):
        image = ImageMobject(np.uint8([[0, 100, 30, 200],
                                       [255, 0, 5, 33]]))
        image.height = 7
        self.add(image)",Basic,train
,"Display a complex labeled polygram composed of three nested polygonal rings:  
- A large outer ring with 20 connected points forming an irregular shape,  
- A medium inner ring forming a closed loop with 8 points,  
- A small triangular ring with 3 points.  

The polygram is labeled “Pole” in sans-serif font, and a white circle is drawn around it, centered at the polygram’s pole. The outer polygon is semi-transparent, while the two inner shapes are filled solid black.","from manim import *

class LabeledPolygramExample(Scene):
    def construct(self):
        # Define Rings
        ring1 = [
            [-3.8, -2.4, 0], [-2.4, -2.5, 0], [-1.3, -1.6, 0], [-0.2, -1.7, 0],
            [1.7, -2.5, 0], [2.9, -2.6, 0], [3.5, -1.5, 0], [4.9, -1.4, 0],
            [4.5, 0.2, 0], [4.7, 1.6, 0], [3.5, 2.4, 0], [1.1, 2.5, 0],
            [-0.1, 0.9, 0], [-1.2, 0.5, 0], [-1.6, 0.7, 0], [-1.4, 1.9, 0],
            [-2.6, 2.6, 0], [-4.4, 1.2, 0], [-4.9, -0.8, 0], [-3.8, -2.4, 0]
        ]
        ring2 = [
            [0.2, -1.2, 0], [0.9, -1.2, 0], [1.4, -2.0, 0], [2.1, -1.6, 0],
            [2.2, -0.5, 0], [1.4, 0.0, 0], [0.4, -0.2, 0], [0.2, -1.2, 0]
        ]
        ring3 = [[-2.7, 1.4, 0], [-2.3, 1.7, 0], [-2.8, 1.9, 0], [-2.7, 1.4, 0]]

        # Create Polygons (for reference)
        p1 = Polygon(*ring1, fill_opacity=0.75)
        p2 = Polygon(*ring2, fill_color=BLACK, fill_opacity=1)
        p3 = Polygon(*ring3, fill_color=BLACK, fill_opacity=1)

        # Create Labeled Polygram
        polygram = LabeledPolygram(
            *[ring1, ring2, ring3],
            label=Text('Pole', font='sans-serif'),
            precision=0.01,
        )

        # Display Circle (for reference)
        circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)

        self.add(p1, p2, p3)
        self.add(polygram)
        self.add(circle)",Intermediate,train
,"Display three regular polygons arranged horizontally and scaled up:

1. A standard hexagon.
2. A green hexagon rotated by 30 degrees.
3. A red decagon (10-sided polygon).

Each shape is evenly spaced from the others.","from manim import *

class RegularPolygonExample(Scene):
    def construct(self):
        poly_1 = RegularPolygon(n=6)
        poly_2 = RegularPolygon(n=6, start_angle=30*DEGREES, color=GREEN)
        poly_3 = RegularPolygon(n=10, color=RED)

        poly_group = Group(poly_1, poly_2, poly_3).scale(1.5).arrange(buff=1)
        self.add(poly_group)",Basic,train
,"Display two rounded rectangles arranged horizontally:

1. A standard-sized rectangle with mildly rounded corners.
2. A larger square-shaped rectangle with more prominently rounded corners, giving it a softer, more circular appearance.","from manim import *

class RoundedRectangleExample(Scene):
    def construct(self):
        rect_1 = RoundedRectangle(corner_radius=0.5)
        rect_2 = RoundedRectangle(corner_radius=1.5, height=4.0, width=4.0)

        rect_group = Group(rect_1, rect_2).arrange(buff=1)
        self.add(rect_group)",Basic,train
,"Display the phrase ""Hello \LaTeX"" in large blue text, with the LaTeX logo rendered using LaTeX typesetting.","from manim import *

class LaTeXAttributes(Scene):
    def construct(self):
        tex = Tex(r'Hello \LaTeX', color=BLUE, font_size=144)
        self.add(tex)",Basic,train
,"Display a 3×3 grid of point cloud dots, each created with the same density and radius but progressively thinned out from left to right and top to bottom. As the scale factor increases, more points are removed from each dot, making them appear increasingly sparse across the grid.","from manim import *

class PMobjectExample(Scene):
    def construct(self):

        pG = PGroup()  # This is just a collection of PMobject's

        # As the scale factor increases, the number of points
        # removed increases.
        for sf in range(1, 9 + 1):
            p = PointCloudDot(density=20, radius=1).thin_out(sf)
            # PointCloudDot is a type of PMobject
            # and can therefore be added to a PGroup
            pG.add(p)

        # This organizes all the shapes in a grid.
        pG.arrange_in_grid()

        self.add(pG)",Basic,train
,"Display a 3D cone oriented diagonally in space, pointing in the direction of the vector (1, 1, 2). The cone is placed within a 3D coordinate system defined by axes. The camera is set at a vertical angle of \( \frac{5\pi}{11} \) and a horizontal angle of \( \frac{\pi}{9} \), providing a tilted and dynamic view of the cone's shape and orientation.","from manim import *

class ExampleCone(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        cone = Cone(direction=X_AXIS+Y_AXIS+2*Z_AXIS, resolution=8)
        self.set_camera_orientation(phi=5*PI/11, theta=PI/9)
        self.add(axes, cone)",Basic,train
,"Display the equation “x² + y² = z²” at the center of the screen. After a short pause, the variables are replaced with “a² + b² = c²” using a smooth transformation that matches corresponding parts. Then, the equation rearranges into “a² = c² - b²,” again transforming matching components to visually demonstrate the algebraic manipulation.","from manim import *

class MatchingEquationParts(Scene):
    def construct(self):
        variables = VGroup(MathTex(""a""), MathTex(""b""), MathTex(""c"")).arrange_submobjects().shift(UP)

        eq1 = MathTex(""{{x}}^2"", ""+"", ""{{y}}^2"", ""="", ""{{z}}^2"")
        eq2 = MathTex(""{{a}}^2"", ""+"", ""{{b}}^2"", ""="", ""{{c}}^2"")
        eq3 = MathTex(""{{a}}^2"", ""="", ""{{c}}^2"", ""-"", ""{{b}}^2"")

        self.add(eq1)
        self.wait(0.5)
        self.play(TransformMatchingTex(Group(eq1, variables), eq2))
        self.wait(0.5)
        self.play(TransformMatchingTex(eq2, eq3))
        self.wait(0.5)",Intermediate,train
,"Display a 3D coordinate system with labeled axes. The x-axis is labeled “x-axis” in slightly larger text, while the y-axis and z-axis are labeled “y-axis” and “z-axis” in smaller text. The camera is angled to provide a clear 3D perspective, allowing all three axes and their labels to be easily visible.","from manim import *

class GetAxisLabelsExample(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)
        axes = ThreeDAxes()
        labels = axes.get_axis_labels(
            Text(""x-axis"").scale(0.7), Text(""y-axis"").scale(0.45), Text(""z-axis"").scale(0.45)
        )
        self.add(axes, labels)",Basic,train
,"Display four squares arranged in a row. Animate each square growing outward from a different edge: the first from the bottom, the second from the right, the third from the upper right corner, and the fourth from the top with its starting edge highlighted in red.","from manim import *

class GrowFromEdgeExample(Scene):
    def construct(self):
        squares = [Square() for _ in range(4)]
        VGroup(*squares).set_x(0).arrange(buff=1)
        self.play(GrowFromEdge(squares[0], DOWN))
        self.play(GrowFromEdge(squares[1], RIGHT))
        self.play(GrowFromEdge(squares[2], UR))
        self.play(GrowFromEdge(squares[3], UP, point_color=RED))",Basic,train
,Display a mathematical expression representing the Taylor series expansion of \( e^x \). All instances of the variable \( x \) are correctly isolated and colored yellow using LaTeX substring isolation.,"from manim import *

class CorrectLaTeXSubstringColoring(Scene):
    def construct(self):
        equation = MathTex(
            r""e^x = x^0 + x^1 + \frac{1}{2} x^2 + \frac{1}{6} x^3 + \cdots + \frac{1}{n!} x^n + \cdots"",
            substrings_to_isolate=""x""
        )
        equation.set_color_by_tex(""x"", YELLOW)
        self.add(equation)",Basic,train
"Display a 2×2 table with row and column labels. The first row’s text is colored red, the second row’s text is colored blue, and all labels are colored green, creating a clear visual distinction between rows and labels.","Display a 2×2 table with row and column labels. The column heading text is colored red-blue gradient, the first row’s text is colored gree, and all other labels are coloured white, creating a clear visual distinction between rows and labels.","from manim import *

class SetRowColorsExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")]
        ).set_row_colors([RED,BLUE], GREEN)
        self.add(table)",Basic,train
,"Display a fully opaque circle with a sheen effect applied. The sheen has a subtle reflective highlight that appears to come from the down-right (bottom-right) direction, giving the circle a slightly glossy, three-dimensional appearance.","from manim import *

class SetSheen(Scene):
    def construct(self):
        circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)
        self.add(circle)",Basic,train
,"Display a line of Arabic text with each character or diacritic styled in different colors: the first character ""ا"" in purple, followed by red, blue, and green diacritics and letters forming the word ""العربية"" with colorful emphasis on pronunciation marks. The entire text is centered on the screen.","from manim import *

class MarkupElaborateExample(Scene):
    def construct(self):
        text = MarkupText(
            '<span foreground=""purple"">ا</span><span foreground=""red"">َ</span>'
            'ل<span foreground=""blue"">ْ</span>ع<span foreground=""red"">َ</span>ر'
            '<span foreground=""red"">َ</span>ب<span foreground=""red"">ِ</span>ي'
            '<span foreground=""green"">ّ</span><span foreground=""red"">َ</span>ة'
            '<span foreground=""blue"">ُ</span>'
        )
        self.add(text)",Intermediate,train
,"Display two vertical groups of numbers side by side: on the left, the numbers 1, 2, and 3 with a red label ""ReplacementTransform""; on the right, the numbers 4, 5, and 6 with a blue label ""Transform"".

In the left group, each number transforms into the next using `ReplacementTransform`, meaning the previous number is completely replaced and disappears during the transition.

In the right group, each number transforms into the next using `Transform`, so the previous number remains visible during the transition, resulting in overlapping numbers as the animation progresses.","from manim import *

class ReplacementTransformOrTransform(Scene):
    def construct(self):
        # set up the numbers
        r_transform = VGroup(*[Integer(i) for i in range(1,4)])
        text_1 = Text(""ReplacementTransform"", color=RED)
        r_transform.add(text_1)

        transform = VGroup(*[Integer(i) for i in range(4,7)])
        text_2 = Text(""Transform"", color=BLUE)
        transform.add(text_2)

        ints = VGroup(r_transform, transform)
        texts = VGroup(text_1, text_2).scale(0.75)
        r_transform.arrange(direction=UP, buff=1)
        transform.arrange(direction=UP, buff=1)

        ints.arrange(buff=2)
        self.add(ints, texts)

        # The mobs replace each other and none are left behind
        self.play(ReplacementTransform(r_transform[0], r_transform[1]))
        self.play(ReplacementTransform(r_transform[1], r_transform[2]))

        # The mobs linger after the Transform()
        self.play(Transform(transform[0], transform[1]))
        self.play(Transform(transform[1], transform[2]))
        self.wait()",Intermediate,train
,"Display a 2×2 integer matrix:  
\[
\left(
\begin{array}{cc}
3.7 & 2 \\
42.2 & 12 \\
\end{array}
\right)
\]  
Although the matrix is created using `IntegerMatrix`, it includes decimal values like 3.7 and 42.2. The matrix is enclosed in parentheses and appears on screen without animation.","from manim import *

class IntegerMatrixExample(Scene):
    def construct(self):
        m0 = IntegerMatrix(
            [[3.7, 2], [42.2, 12]],
            left_bracket=""("",
            right_bracket="")"")
        self.add(m0)",Basic,train
,"Display two squares arranged vertically. Animate the first square growing outward from its center. Then animate the second square growing from its center as well, with its center point highlighted in red.","from manim import *

class GrowFromCenterExample(Scene):
    def construct(self):
        squares = [Square() for _ in range(2)]
        VGroup(*squares).set_x(0).arrange(buff=2)
        self.play(GrowFromCenter(squares[0]))
        self.play(GrowFromCenter(squares[1], point_color=RED))",Basic,train
,"Display the word “Blinking” in medium-large text on the screen, then animate it blinking three times by briefly disappearing and reappearing.","from manim import *

class BlinkingExample(Scene):
    def construct(self):
        text = Text(""Blinking"").scale(1.5)
        self.add(text)
        self.play(Blink(text, blinks=3))",Basic,train
,"Display three five-pointed stars arranged horizontally:

1. The first is a standard star with sharp corners.
2. The second is a copy of the first with slightly rounded corners.
3. The third is another copy with more prominently rounded corners, showing a smoother, softer star shape.","from manim import *

class PolygramRoundCorners(Scene):
    def construct(self):
        star = Star(outer_radius=2)

        shapes = VGroup(star)
        shapes.add(star.copy().round_corners(radius=0.1))
        shapes.add(star.copy().round_corners(radius=0.25))

        shapes.arrange(RIGHT)
        self.add(shapes)",Basic,train
,"Display a 3D coordinate system with two lines:

1. A red line extending from the point (2, 0, 0) to the point (0, 1, 1), angled diagonally through space.
2. A yellow line that is parallel to the red line, automatically generated to match its direction.

The camera is set at a vertical angle of \( \frac{\pi}{3} \) and a horizontal angle of \( -\frac{\pi}{4} \), providing a tilted view that clearly shows the parallel orientation of the two lines in 3D space.","from manim import *

class ParallelLineExample(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(PI / 3, -PI / 4)
        ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)
        line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)
        line2 = Line3D.parallel_to(line1, color=YELLOW)
        self.add(ax, line1, line2)",Basic,train
,"Display a diagonal arrow pointing from the bottom left to the upper right of the screen, labeled “0.5” at its midpoint.","from manim import *

class LabeledArrowExample(Scene):
    def construct(self):
        l_arrow = LabeledArrow(""0.5"", start=LEFT*3, end=RIGHT*3 + UP*2, label_position=0.5)

        self.add(l_arrow)",Basic,train
,"Display a number line with a downward-pointing arrow (vector) and a label ""x"" above it. The arrow dynamically follows a value tracked by a `ValueTracker`. Initially, the tracker is set to 0, then:

1. Instantly increases to 1.5,
2. Instantly decreases by 4 (to -2.5),
3. Animates smoothly to 5,
4. Animates to 3,
5. Animates to 1 by decrementing 2.

Throughout, the arrow and label move along the number line to reflect the current tracked value.","from manim import *

class ValueTrackerExample(Scene):
    def construct(self):
        number_line = NumberLine()
        pointer = Vector(DOWN)
        label = MathTex(""x"").add_updater(lambda m: m.next_to(pointer, UP))

        tracker = ValueTracker(0)
        pointer.add_updater(
            lambda m: m.next_to(
                        number_line.n2p(tracker.get_value()),
                        UP
                    )
        )
        self.add(number_line, pointer,label)
        tracker += 1.5
        self.wait(1)
        tracker -= 4
        self.wait(0.5)
        self.play(tracker.animate.set_value(5))
        self.wait(0.5)
        self.play(tracker.animate.set_value(3))
        self.play(tracker.animate.increment_value(-2))
        self.wait(0.5)",Basic,train
,"Display a 2x2 grid of four scenes, each containing a circle on the left and a label reading ""This is Scene 0"" through ""This is Scene 3"" on the right. The camera starts focused on the first scene, then smoothly slides to center on each of the remaining scenes one by one. After visiting all scenes, the camera zooms out to show the entire grid with extra margin around it.","from manim import *

class SlidingMultipleScenes(MovingCameraScene):
    def construct(self):
        def create_scene(number):
            frame = Rectangle(width=16,height=9)
            circ = Circle().shift(LEFT)
            text = Tex(f""This is Scene {str(number)}"").next_to(circ, RIGHT)
            frame.add(circ,text)
            return frame

        group = VGroup(*(create_scene(i) for i in range(4))).arrange_in_grid(buff=4)
        self.add(group)
        self.camera.auto_zoom(group[0], animate=False)
        for scene in group:
            self.play(self.camera.auto_zoom(scene))
            self.wait()

        self.play(self.camera.auto_zoom(group, margin=2))",Intermediate,train
,"Display three shape pairs arranged horizontally:  
- On the left, a triangle is tightly surrounded by a circle.  
- In the center, a line is loosely enclosed by a larger circle with extra spacing.  
- On the right, a square is enclosed by a smaller circle due to a reduced buffer, making the circle fit snugly inside the square.","from manim import *

class CircleSurround(Scene):
    def construct(self):
        triangle1 = Triangle()
        circle1 = Circle().surround(triangle1)
        group1 = Group(triangle1,circle1) # treat the two mobjects as one

        line2 = Line()
        circle2 = Circle().surround(line2, buffer_factor=2.0)
        group2 = Group(line2,circle2)

        # buffer_factor < 1, so the circle is smaller than the square
        square3 = Square()
        circle3 = Circle().surround(square3, buffer_factor=0.5)
        group3 = Group(square3, circle3)

        group = Group(group1, group2, group3).arrange(buff=1)
        self.add(group)",Intermediate,train
,"Display three shapes with distinct styles and positions: a circle with a thick green outline on the left, a fully yellow-filled square above the center, and a pink-filled triangle with 50% transparency on the right. Show all three shapes on screen and pause for one second.","from manim import *

class MobjectStyling(Scene):
    def construct(self):
        circle = Circle().shift(LEFT)
        square = Square().shift(UP)
        triangle = Triangle().shift(RIGHT)

        circle.set_stroke(color=GREEN, width=20)
        square.set_fill(YELLOW, opacity=1.0)
        triangle.set_fill(PINK, opacity=0.5)

        self.add(circle, square, triangle)
        self.wait(1)",Basic,train
,"Display four different matrix styles arranged in a grid:

- The first is a symbolic matrix with elements like \( \pi \), 0, -1, and 1, enclosed in square brackets.
- The second is an integer matrix with decimal and whole numbers, enclosed in parentheses.
- The third is a decimal matrix with values rounded to two decimal places, enclosed in curly braces.
- The fourth is a matrix of graphical objects including a circle, square, large \( \pi \), and a star, enclosed in angle brackets.

All matrices appear on screen simultaneously without animation.","from manim import *

class MatrixExamples(Scene):
    def construct(self):
        m0 = Matrix([[""\\pi"", 0], [-1, 1]])
        m1 = IntegerMatrix([[1.5, 0.], [12, -1.3]],
            left_bracket=""("",
            right_bracket="")"")
        m2 = DecimalMatrix(
            [[3.456, 2.122], [33.2244, 12.33]],
            element_to_mobject_config={""num_decimal_places"": 2},
            left_bracket=r""\{"",
            right_bracket=r""\}"")
        m3 = MobjectMatrix(
            [[Circle().scale(0.3), Square().scale(0.3)],
            [MathTex(""\\pi"").scale(2), Star().scale(0.3)]],
            left_bracket=""\\langle"",
            right_bracket=""\\rangle"")
        g = Group(m0, m1, m2, m3).arrange_in_grid(buff=2)
        self.add(g)",Intermediate,train
,"Display four lines of styled text arranged vertically:

1. The first line reads ""all in sans except this"" where the entire line uses a sans-serif font except for ""except this"", which is in a serif font.
2. The second line shows ""mixing fonts is ugly"" with ""mixing"" in a serif font, ""fonts"" in a sans-serif font, and ""is ugly"" in a monospaced font.
3. The third line displays ""special char > or >"" demonstrating that both the literal "">"" and the HTML entity `&gt;` render as the same character.
4. The fourth line shows ""special char < and &"" using the HTML entities `&lt;` and `&amp;` to render ""<"" and ""&"" respectively.

All lines are centered and stacked vertically on the screen.","from manim import *

class FontExample(Scene):
    def construct(self):
        text1 = MarkupText(
            'all in sans <span font_family=""serif"">except this</span>', font=""sans""
        )
        text2 = MarkupText(
            '<span font_family=""serif"">mixing</span> <span font_family=""sans"">fonts</span> <span font_family=""monospace"">is ugly</span>'
        )
        text3 = MarkupText(""special char > or &gt;"")
        text4 = MarkupText(""special char &lt; and &amp;"")
        group = VGroup(text1, text2, text3, text4).arrange(DOWN)
        self.add(group)",Intermediate,train
,"Display seven lines of styled text arranged vertically:

1. The first line reads ""all in red except this"" where the entire text is red except for ""except this"", which is yellow.
2. The second line says ""nice gradient"" with a smooth color transition from blue to green across the text.
3. The third line reads ""nice intermediate gradient"" where ""intermediate"" has a red-to-yellow gradient, while the rest of the text has a blue-to-green gradient.
4. The fourth line says ""fl ligature causing trouble here"" with ""causing trouble"" in a red-to-yellow gradient, highlighting potential rendering issues with the ""fl"" ligature.
5. The fifth line repeats the previous text but offsets the gradient to avoid the ligature issue, making ""causing trouble"" appear correctly styled.
6. The sixth line says ""fl ligature floating inside"" with ""floating"" in a red-to-yellow gradient and offset to prevent rendering issues.
7. The seventh line is similar to the sixth but uses a two-dimensional offset for the gradient on ""floating"", further refining the visual effect.

All lines are centered and stacked vertically on the screen.","from manim import *

class ColorExample(Scene):
    def construct(self):
        text1 = MarkupText(
            f'all in red <span fgcolor=""{YELLOW}"">except this</span>', color=RED
        )
        text2 = MarkupText(""nice gradient"", gradient=(BLUE, GREEN))
        text3 = MarkupText(
            'nice <gradient from=""RED"" to=""YELLOW"">intermediate</gradient> gradient',
            gradient=(BLUE, GREEN),
        )
        text4 = MarkupText(
            'fl ligature <gradient from=""RED"" to=""YELLOW"">causing trouble</gradient> here'
        )
        text5 = MarkupText(
            'fl ligature <gradient from=""RED"" to=""YELLOW"" offset=""1"">defeated</gradient> with offset'
        )
        text6 = MarkupText(
            'fl ligature <gradient from=""RED"" to=""YELLOW"" offset=""1"">floating</gradient> inside'
        )
        text7 = MarkupText(
            'fl ligature <gradient from=""RED"" to=""YELLOW"" offset=""1,1"">floating</gradient> inside'
        )
        group = VGroup(text1, text2, text3, text4, text5, text6, text7).arrange(DOWN)
        self.add(group)",Intermediate,train
,"Display the text ""Hello World!"" and a coordinate grid (number plane) centered on the screen. Both are then transformed using a matrix that shears the objects to the right and compresses them vertically, visually demonstrating the effect of a linear transformation.","from manim import *

class ApplyMatrixExample(Scene):
    def construct(self):
        matrix = [[1, 1], [0, 2/3]]
        self.play(ApplyMatrix(matrix, Text(""Hello World!"")), ApplyMatrix(matrix, NumberPlane()))",Basic,train
,"Display the text ""So shiny!"" at the center of the screen with a glowing animated boundary effect that cycles through red, green, and blue colors at a rate of 3 cycles per second. The animation runs for 2 seconds.","from manim import *

class AnimatedBoundaryExample(Scene):
    def construct(self):
        text = Text(""So shiny!"")
        boundary = AnimatedBoundary(text, colors=[RED, GREEN, BLUE],
                                    cycle_rate=3)
        self.add(text, boundary)
        self.wait(2)",Basic,train
,"Display a large circle with two tangent lines:

1. A blue tangent line touching the circle on the right side.
2. A green tangent line touching the circle at an upper-left point.

Both lines extend outward from their points of contact, illustrating tangents at different positions on the circle.","from manim import *

class VectorExample(Scene):
    def construct(self):
        plane = NumberPlane()
        vector_1 = Vector([1,2])
        vector_2 = Vector([-5,-2])
        self.add(plane, vector_1, vector_2)",Basic,train
,"Display ten dots scattered across the screen, each representing a point in 2D space. A blue convex polygon (convex hull) is drawn around the outermost points, enclosing all the dots and illustrating the smallest convex shape that contains them.","from manim import *

class ConvexHullExample(Scene):
    def construct(self):
        points = [
            [-2.35, -2.25, 0],
            [1.65, -2.25, 0],
            [2.65, -0.25, 0],
            [1.65, 1.75, 0],
            [-0.35, 2.75, 0],
            [-2.35, 0.75, 0],
            [-0.35, -1.25, 0],
            [0.65, -0.25, 0],
            [-1.35, 0.25, 0],
            [0.15, 0.75, 0]
        ]
        hull = ConvexHull(*points, color=BLUE)
        dots = VGroup(*[Dot(point) for point in points])
        self.add(hull)
        self.add(dots)",Intermediate,train
,"Display a long diagonal line stretching from the bottom left to the top right of the screen, labeled “0.5” near the end of the line (at 80% of its length), with the label shown in a small font.","from manim import *

class LabeledLineExample(Scene):
    def construct(self):
        line = LabeledLine(
            label          = '0.5',
            label_position = 0.8,
            label_config = {
                ""font_size"" : 20
            },
            start=LEFT+DOWN,
            end=RIGHT+UP)

        line.set_length(line.get_length() * 2)
        self.add(line)",Basic,train
,"Display the word ""Google"" with each letter colored to match the official Google logo:

- ""G"" in blue (#3174f0)
- ""o"" in red (#e53125)
- The second ""o"" in yellow (#fbb003)
- ""g"" in blue (#3174f0)
- ""l"" in green (#269a43)
- ""e"" in red (#e53125)

The text is large and prominently centered on the screen, scaled up for emphasis.","from manim import *

class TextMoreCustomization(Scene):
    def construct(self):
        text1 = Text(
            'Google',
            t2c={'[:1]': '#3174f0', '[1:2]': '#e53125',
                 '[2:3]': '#fbb003', '[3:4]': '#3174f0',
                 '[4:5]': '#269a43', '[5:]': '#e53125'}, font_size=58).scale(3)
        self.add(text1)",Basic,train
,"Display the text ""Hello World"" in blue at the center of the screen. The camera then smoothly zooms in to slightly enlarge the view around the text. After a brief pause, the camera smoothly zooms back out to its original framing, restoring the initial view.","from manim import *

class ChangingCameraWidthAndRestore(MovingCameraScene):
    def construct(self):
        text = Text(""Hello World"").set_color(BLUE)
        self.add(text)
        self.camera.frame.save_state()
        self.play(self.camera.frame.animate.set(width=text.width * 1.2))
        self.wait(0.3)
        self.play(Restore(self.camera.frame))",Basic,train
,"Display three elements arranged around the edges of the screen:

- A text reading “I am at the top!” is positioned at the top edge.
- A circle, initially shifted downward, is moved to the right edge with no buffer space.
- Another text reading “I am moving to the side!” is placed at the left edge.

All elements appear together, with their final positions aligned to the specified screen edges.","from manim import *

class ToEdgeExample(Scene):
    def construct(self):
        tex_top = Tex(""I am at the top!"")
        tex_top.to_edge(UP)
        tex_side = Tex(""I am moving to the side!"")
        c = Circle().shift(2*DOWN)
        self.add(tex_top, tex_side, c)
        tex_side.to_edge(LEFT)
        c.to_edge(RIGHT, buff=0)",Basic,train
,"Display a large circle with a double-headed arrow passing through it horizontally from left to right. Above it, another double-headed arrow is shown with both ends featuring filled circular tips. The two elements are vertically stacked with space between them.","from manim import *

from manim.mobject.geometry.tips import ArrowCircleFilledTip
class DoubleArrowExample(Scene):
    def construct(self):
        circle = Circle(radius=2.0)
        d_arrow = DoubleArrow(start=circle.get_left(), end=circle.get_right())
        d_arrow_2 = DoubleArrow(tip_shape_end=ArrowCircleFilledTip, tip_shape_start=ArrowCircleFilledTip)
        group = Group(Group(circle, d_arrow), d_arrow_2).arrange(UP, buff=1)
        self.add(group)",Basic,train
,"Display a square rotated 45 degrees (appearing as a diamond) centered on the screen. Transform the square into a pink circle with 50% transparency, then fade the circle out.","from manim import *

class SquareToCircle(Scene):
    def construct(self):
        circle = Circle()  # create a circle
        circle.set_fill(PINK, opacity=0.5)  # set color and transparency

        square = Square()  # create a square
        square.rotate(PI / 4)  # rotate a certain amount

        self.play(Create(square))  # animate the creation of the square
        self.play(Transform(square, circle))  # interpolate the square into the circle
        self.play(FadeOut(square))  # fade out animation",Basic,train
"Display a labeled blue shape representing the outline of the United States, constructed from geographic arc data and positioned on a coordinate grid. The shape is semi-transparent with no border, labeled “USA” in sans-serif font at its center. A white circle is drawn around the shape, centered at its geometric pole. ","Display a labeled blue shape representing the outline of the United States, constructed from geographic arc data and positioned on a coordinate grid. The shape is semi-transparent with no border, labeled “USA” in sans-serif font at its center. A white circle is drawn around the shape, centered at its geometric pole. 

Get the data for the USA map here: ""https://cdn.jsdelivr.net/npm/us-atlas@3/nation-10m.json""","from manim import *

import requests
import json

class LabeledCountryExample(Scene):
    def construct(self):
        # Fetch JSON data and process arcs
        data = requests.get('https://cdn.jsdelivr.net/npm/us-atlas@3/nation-10m.json').json()
        arcs, transform = data['arcs'], data['transform']
        sarcs = [np.cumsum(arc, axis=0) * transform['scale'] + transform['translate'] for arc in arcs]
        ssarcs = sorted(sarcs, key=len, reverse=True)[:1]

        # Compute Bounding Box
        points = np.concatenate(ssarcs)
        mins, maxs = np.min(points, axis=0), np.max(points, axis=0)

        # Build Axes
        ax = Axes(
            x_range=[mins[0], maxs[0], maxs[0] - mins[0]], x_length=10,
            y_range=[mins[1], maxs[1], maxs[1] - mins[1]], y_length=7,
            tips=False
        )

        # Adjust Coordinates
        array = [[ax.c2p(*point) for point in sarc] for sarc in ssarcs]

        # Add Polygram
        polygram = LabeledPolygram(
            *array,
            label=Text('USA', font='sans-serif'),
            precision=0.01,
            fill_color=BLUE,
            stroke_width=0,
            fill_opacity=0.75
        )

        # Display Circle (for reference)
        circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)

        self.add(ax)
        self.add(polygram)
        self.add(circle)",Advanced,train
,"Display a line of text where the phrase ""Blue text"" appears in large blue font, followed by the words ""is *cool*!"" with ""cool"" italicized. The entire line is centered on the screen.","from manim import *

class MarkupExample(Scene):
    def construct(self):
        text = MarkupText('<span foreground=""blue"" size=""x-large"">Blue text</span> is <i>cool</i>!""')
        self.add(text)",Basic,train
,"Display two dots on opposite sides of the screen—one on the far left and one on the far right. They move toward each other simultaneously, crossing paths. During their motion, the speed of the animation dynamically changes: it starts at normal speed, slows down significantly in the middle portion, then returns to normal speed by the end, creating a noticeable slow-motion effect during the center of the movement.","from manim import *

class SpeedModifierExample(Scene):
    def construct(self):
        a = Dot().shift(LEFT * 4)
        b = Dot().shift(RIGHT * 4)
        self.add(a, b)
        self.play(
            ChangeSpeed(
                AnimationGroup(
                    a.animate(run_time=1).shift(RIGHT * 8),
                    b.animate(run_time=1).shift(LEFT * 8),
                ),
                speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1},
                rate_func=linear,
            )
        )",Intermediate,train
,"Display two green lines intersecting at the origin, forming a narrow angle. The angle between them is filled with a solid green sector, bordered by two curved arcs. The filled region is highlighted in orange outline, creating a visual emphasis on the measured angle.","from manim import *

class FilledAngle(Scene):
    def construct(self):
        l1 = Line(ORIGIN, 2 * UP + RIGHT).set_color(GREEN)
        l2 = (
            Line(ORIGIN, 2 * UP + RIGHT)
            .set_color(GREEN)
            .rotate(-20 * DEGREES, about_point=ORIGIN)
        )
        norm = l1.get_length()
        a1 = Angle(l1, l2, other_angle=True, radius=norm - 0.5).set_color(GREEN)
        a2 = Angle(l1, l2, other_angle=True, radius=norm).set_color(GREEN)
        q1 = a1.points #  save all coordinates of points of angle a1
        q2 = a2.reverse_direction().points  #  save all coordinates of points of angle a1 (in reversed direction)
        pnts = np.concatenate([q1, q2, q1[0].reshape(1, 3)])  # adds points and ensures that path starts and ends at same point
        mfill = VMobject().set_color(ORANGE)
        mfill.set_points_as_corners(pnts).set_fill(GREEN, opacity=1)
        self.add(l1, l2)
        self.add(mfill)",Intermediate,train
,"Display the phrase ""the morse code"" at the center of the screen. After a brief pause, the letters animate and rearrange themselves along curved paths into the phrase ""here come dots,"" visually illustrating the anagram transformation with a smooth and dynamic motion.","from manim import *

class Anagram(Scene):
    def construct(self):
        src = Text(""the morse code"")
        tar = Text(""here come dots"")
        self.play(Write(src))
        self.wait(0.5)
        self.play(TransformMatchingShapes(src, tar, path_arc=PI/2))
        self.wait(0.5)",Basic,train
,"Display a table with two rows labeled “sin” and “cos”, and five columns labeled with square root fractions. The table contains angle values in degrees, showing sine values in the first row and cosine values in the second, all centered on screen.","from manim import *

class IntegerTableExample(Scene):
    def construct(self):
        t0 = IntegerTable(
            [[0,30,45,60,90],
            [90,60,45,30,0]],
            col_labels=[
                MathTex(r""\frac{\sqrt{0}}{2}""),
                MathTex(r""\frac{\sqrt{1}}{2}""),
                MathTex(r""\frac{\sqrt{2}}{2}""),
                MathTex(r""\frac{\sqrt{3}}{2}""),
                MathTex(r""\frac{\sqrt{4}}{2}"")],
            row_labels=[MathTex(r""\sin""), MathTex(r""\cos"")],
            h_buff=1,
            element_to_mobject_config={""unit"": r""^{\circ}""})
        self.add(t0)",Basic,train
,"Display a standard cross shape centered on the screen, formed by two intersecting rectangles—one vertical and one horizontal—creating a simple “X” mark.","from manim import *

class ExampleCross(Scene):
    def construct(self):
        cross = Cross()
        self.add(cross)",Basic,train
Display 3D axes. Show a scaled-up Gaussian surface with a green stroke and a checkerboard fill pattern in orange and blue. Set the camera orientation to a specific angle.,Display 3D axes. Show a scaled-up 3D Gaussian surface with a green stroke and a checkerboard fill pattern in orange and blue. Set the camera orientation to a specific angle that shows the 3D view.,"from manim import *

class ThreeDSurfacePlot(ThreeDScene):
    def construct(self):
        resolution_fa = 24
        self.set_camera_orientation(phi=75 * DEGREES, theta=-30 * DEGREES)

        def param_gauss(u, v):
            x = u
            y = v
            sigma, mu = 0.4, [0.0, 0.0]
            d = np.linalg.norm(np.array([x - mu[0], y - mu[1]]))
            z = np.exp(-(d ** 2 / (2.0 * sigma ** 2)))
            return np.array([x, y, z])

        gauss_plane = Surface(
            param_gauss,
            resolution=(resolution_fa, resolution_fa),
            v_range=[-2, +2],
            u_range=[-2, +2]
        )

        gauss_plane.scale(2, about_point=ORIGIN)
        gauss_plane.set_style(fill_opacity=1,stroke_color=GREEN)
        gauss_plane.set_fill_by_checkerboard(ORANGE, BLUE, opacity=0.5)
        axes = ThreeDAxes()
        self.add(axes,gauss_plane)",Intermediate,train
,"Display the text “all in red except this” centered on the screen, where the entire sentence is red except for the phrase “except this,” which is colored yellow.","from manim import *

class SingleLineColor(Scene):
    def construct(self):
        text = MarkupText(
            f'all in red <span fgcolor=""{YELLOW}"">except this</span>', color=RED
        )
        self.add(text)",Basic,train
,Display a blue square. Move the square to the left. Change its fill color to orange. Scale the square down to 30% of its original size. Rotate the square by 0.4 radians.,"from manim import *

class MovingAround(Scene):
    def construct(self):
        square = Square(color=BLUE, fill_opacity=1)

        self.play(square.animate.shift(LEFT))
        self.play(square.animate.set_fill(ORANGE))
        self.play(square.animate.scale(0.3))
        self.play(square.animate.rotate(0.4))",Basic,train
,"Display six lines of multilingual text arranged vertically:

1. The first line shows the Tamil greeting ""வணக்கம்"" using a sans-serif font.
2. The second line displays the Japanese phrase ""日本へようこそ"" with ""日本"" in blue.
3. The third line reads ""Multi-Language"" in bold.
4. The fourth line presents a mix of Russian and Hindi script: ""Здравствуйте मस नम म"", using a sans-serif font.
5. The fifth line shows the Hindi greeting ""नमस्ते"" in a sans-serif font.
6. The sixth line displays the Chinese sentence ""臂猿「黛比」帶著孩子"" in a sans-serif font.

All lines are centered and stacked vertically on the screen, showcasing a variety of scripts and font styles.","from manim import *

class MultiLanguage(Scene):
    def construct(self):
        morning = MarkupText(""வணக்கம்"", font=""sans-serif"")
        japanese = MarkupText(
            '<span fgcolor=""blue"">日本</span>へようこそ'
        )  # works as in ``Text``.
        mess = MarkupText(""Multi-Language"", weight=BOLD)
        russ = MarkupText(""Здравствуйте मस नम म "", font=""sans-serif"")
        hin = MarkupText(""नमस्ते"", font=""sans-serif"")
        chinese = MarkupText(""臂猿「黛比」帶著孩子"", font=""sans-serif"")
        group = VGroup(morning, japanese, mess, russ, hin, chinese).arrange(DOWN)
        self.add(group)",Intermediate,train
,"Display a green dot at the center of the screen. After a short pause, zooming functionality is activated (though not animated), preparing a magnified view. Then, the dot smoothly shifts to the left while the zoomed-in view follows the motion, highlighting the movement in detail.","from manim import *

class UseZoomedScene(ZoomedScene):
    def construct(self):
        dot = Dot().set_color(GREEN)
        self.add(dot)
        self.wait(1)
        self.activate_zooming(animate=False)
        self.wait(1)
        self.play(dot.animate.shift(LEFT))",Intermediate,train
,"Display two number planes side by side:

- On the **left**, a number plane with x ranging from -4 to 11 and y from -3 to 3, scaled to a width of 5 units and a height of 2 units, creating a horizontally stretched appearance.
- On the **right**, a similar number plane with the same x-range and width, but a taller y-axis scaled to 4 units in height, resulting in a vertically stretched appearance.

This scene visually compares how different y-axis scaling affects the shape of the coordinate grid.","from manim import *

class NumberPlaneScaled(Scene):
    def construct(self):
        number_plane = NumberPlane(
            x_range=(-4, 11, 1),
            y_range=(-3, 3, 1),
            x_length=5,
            y_length=2,
        ).move_to(LEFT*3)

        number_plane_scaled_y = NumberPlane(
            x_range=(-4, 11, 1),
            x_length=5,
            y_length=4,
        ).move_to(RIGHT*3)

        self.add(number_plane)
        self.add(number_plane_scaled_y)",Basic,train
,"Display four groups of arrows arranged across the screen, each demonstrating different arrow properties:

1. **Left Group (far left):** A vertical stack of arrows pointing right, each shorter than the last, showing how increasing the `buff` value reduces arrow length.
2. **Middle Group (center):** A vertical stack of arrows with increasing stroke width, illustrating how a higher `max_stroke_width_to_length_ratio` thickens the arrow shaft.
3. **Upper Right Group:** A vertical stack of arrows with increasingly longer arrow tips, demonstrating the effect of increasing `max_tip_length_to_length_ratio`.
4. **Lower Right Group:** A vertical stack of arrows with different tip shapes and colors—square, filled square, circle, and filled circle—showing the variety of arrowhead styles.","from manim import *

class ArrowExample(Scene):
    def construct(self):
        left_group = VGroup()
        # As buff increases, the size of the arrow decreases.
        for buff in np.arange(0, 2.2, 0.45):
            left_group += Arrow(buff=buff, start=2 * LEFT, end=2 * RIGHT)
        # Required to arrange arrows.
        left_group.arrange(DOWN)
        left_group.move_to(4 * LEFT)

        middle_group = VGroup()
        # As max_stroke_width_to_length_ratio gets bigger,
        # the width of stroke increases.
        for i in np.arange(0, 5, 0.5):
            middle_group += Arrow(max_stroke_width_to_length_ratio=i)
        middle_group.arrange(DOWN)

        UR_group = VGroup()
        # As max_tip_length_to_length_ratio increases,
        # the length of the tip increases.
        for i in np.arange(0, 0.3, 0.1):
            UR_group += Arrow(max_tip_length_to_length_ratio=i)
        UR_group.arrange(DOWN)
        UR_group.move_to(4 * RIGHT + 2 * UP)

        DR_group = VGroup()
        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareTip)
        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareFilledTip)
        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleTip)
        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleFilledTip)
        DR_group.arrange(DOWN)
        DR_group.move_to(4 * RIGHT + 2 * DOWN)

        self.add(left_group, middle_group, UR_group, DR_group)",Intermediate,train
,"Display the text “WaveWaveWaveWaveWave” in large font. First, animate a wave passing through the text. Then, apply another wave effect moving to the right with a shorter wave duration and smaller amplitude. Finally, animate four evenly spaced wave ripples across the text using a linear timing function.","from manim import *

class ApplyingWaves(Scene):
    def construct(self):
        tex = Tex(""WaveWaveWaveWaveWave"").scale(2)
        self.play(ApplyWave(tex))
        self.play(ApplyWave(
            tex,
            direction=RIGHT,
            time_width=0.5,
            amplitude=0.3
        ))
        self.play(ApplyWave(
            tex,
            rate_func=linear,
            ripples=4
        ))",Basic,train
,"Display a 2×2 matrix  
\[
\begin{bmatrix}
\pi & 1 \\
-1 & 3
\end{bmatrix}
\]  
with the first row colored red, the second row colored blue, and the brackets colored green. The matrix appears on screen without animation.","from manim import *

class SetRowColorsExample(Scene):
    def construct(self):
        m0 = Matrix([[""\\pi"", 1], [-1, 3]],
        ).set_row_colors([RED,BLUE], GREEN)
        self.add(m0)",Basic,train
,"Display four identical squares arranged in a horizontal row with equal spacing between them, all centered on the screen.","from manim import *

class Example(Scene):
    def construct(self):
        s1 = Square()
        s2 = Square()
        s3 = Square()
        s4 = Square()
        x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)
        self.add(x)",Basic,train
,"Display a 5×5 grid of circles. Each circle is added to the scene one at a time in quick succession, with a smooth animation and a short delay of 0.2 seconds between each addition.","from manim import *

class AddWithRunTimeScene(Scene):
    def construct(self):
        # A 5x5 grid of circles
        circles = VGroup(
            *[Circle(radius=0.5) for _ in range(25)]
        ).arrange_in_grid(5, 5)

        self.play(
            Succession(
                # Add a run_time of 0.2 to wait for 0.2 seconds after
                # adding the circle, instead of using Wait(0.2) after Add!
                *[Add(circle, run_time=0.2) for circle in circles],
                rate_func=smooth,
            )
        )
        self.wait()",Basic,train
,"Display a red circle with partial transparency at the center of the screen. After a brief pause, the circle instantly changes into a blue square with lower opacity, without any animation or transition.","from manim import *

class BecomeScene(Scene):
    def construct(self):
        circ = Circle(fill_color=RED, fill_opacity=0.8)
        square = Square(fill_color=BLUE, fill_opacity=0.2)
        self.add(circ)
        self.wait(0.5)
        circ.become(square)
        self.wait(0.5)",Basic,train
,"Display a coordinate grid using a number plane. Then, draw a green vectorized shape (VMobject) composed of two connected Bézier curves defined by eight control points. Add red dots at the control points that act as curve handles, and draw red lines connecting the start and end points of each curve segment to their respective control points, visually illustrating how the curves are shaped.","from manim import *

class VMobjectDemo(Scene):
    def construct(self):
        plane = NumberPlane()
        my_vmobject = VMobject(color=GREEN)
        my_vmobject.points = [
            np.array([-2, -1, 0]),  # start of first curve
            np.array([-3, 1, 0]),
            np.array([0, 3, 0]),
            np.array([1, 3, 0]),  # end of first curve
            np.array([1, 3, 0]),  # start of second curve
            np.array([0, 1, 0]),
            np.array([4, 3, 0]),
            np.array([4, -2, 0]),  # end of second curve
        ]
        handles = [
            Dot(point, color=RED) for point in
            [[-3, 1, 0], [0, 3, 0], [0, 1, 0], [4, 3, 0]]
        ]
        handle_lines = [
            Line(
                my_vmobject.points[ind],
                my_vmobject.points[ind+1],
                color=RED,
                stroke_width=2
            ) for ind in range(0, len(my_vmobject.points), 2)
        ]
        self.add(plane, *handles, *handle_lines, my_vmobject)",Advanced,train
,"Display the text ""foooo\nbaaaar"" where the segment ""oo\nbaa"" is colored red and includes a line break between ""oo"" and ""baa"", resulting in a two-line layout. The rest of the text remains in the default color and is displayed on a single centered block.","from manim import *

class NewlineExample(Scene):
    def construct(self):
        text = MarkupText('foooo<span foreground=""red"">oo\nbaa</span>aar')
        self.add(text)",Basic,train
,"Display a graph with six labeled nodes arranged in a spiral layout, where each node is positioned along a gradually expanding curve. The nodes are connected in a loop with additional cross-links between non-adjacent nodes, forming a dense and interconnected structure that visually spirals outward from the center.","from manim import *

class SpiralLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout=""spiral"",
            labels=True
        )
        self.add(graph)",Intermediate,train
,Display a large circle centered on screen with two small squares placed on its edge: one at the top (90 degrees) and one at the bottom (270 degrees).,"from manim import *

class PointAtAngleExample(Scene):
    def construct(self):
        circle = Circle(radius=2.0)
        p1 = circle.point_at_angle(PI/2)
        p2 = circle.point_at_angle(270*DEGREES)

        s1 = Square(side_length=0.25).move_to(p1)
        s2 = Square(side_length=0.25).move_to(p2)
        self.add(circle, s1, s2)",Basic,train
,"Display four variations of a 2×2 table arranged in a grid:

1. The first table contains plain text entries, with the second row's second cell showing a line break.
2. The second table adds row and column labels and highlights the bottom-right cell in yellow.
3. The third table includes the same labels, a star icon in the top-left corner, outer borders, right-aligned text, and a red-colored bottom-right cell.
4. The fourth table is similar to the third but uses thinner yellow lines and removes all vertical lines.

All tables are scaled down and spaced evenly in a 2×2 grid layout.","from manim import *

class TableExamples(Scene):
    def construct(self):
        t0 = Table(
            [[""This"", ""is a""],
            [""simple"", ""Table in \\n Manim.""]])
        t1 = Table(
            [[""This"", ""is a""],
            [""simple"", ""Table.""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        t1.add_highlighted_cell((2,2), color=YELLOW)
        t2 = Table(
            [[""This"", ""is a""],
            [""simple"", ""Table.""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")],
            top_left_entry=Star().scale(0.3),
            include_outer_lines=True,
            arrange_in_grid_config={""cell_alignment"": RIGHT})
        t2.add(t2.get_cell((2,2), color=RED))
        t3 = Table(
            [[""This"", ""is a""],
            [""simple"", ""Table.""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")],
            top_left_entry=Star().scale(0.3),
            include_outer_lines=True,
            line_config={""stroke_width"": 1, ""color"": YELLOW})
        t3.remove(*t3.get_vertical_lines())
        g = Group(
            t0,t1,t2,t3
        ).scale(0.7).arrange_in_grid(buff=1)
        self.add(g)",Intermediate,train
,"Display two side-by-side coordinate grids, each showing the graph of the function \( f(x) = \frac{x^2 - 2}{x^2 - 4} \):  
- On the left, a red curve is plotted without accounting for discontinuities, resulting in visual artifacts at \(x = \pm2\).  
- On the right, a green curve correctly omits the discontinuous points at \(x = -2\) and \(x = 2\), producing a more accurate representation.  
Both graphs appear simultaneously without animation.","from manim import *

class DiscontinuousExample(Scene):
    def construct(self):
        ax1 = NumberPlane((-3, 3), (-4, 4))
        ax2 = NumberPlane((-3, 3), (-4, 4))
        VGroup(ax1, ax2).arrange()
        discontinuous_function = lambda x: (x ** 2 - 2) / (x ** 2 - 4)
        incorrect = ax1.plot(discontinuous_function, color=RED)
        correct = ax2.plot(
            discontinuous_function,
            discontinuities=[-2, 2],  # discontinuous points
            dt=0.1,  # left and right tolerance of discontinuity
            color=GREEN,
        )
        self.add(ax1, ax2, incorrect, correct)",Advanced,train
,"Display a graph with six labeled nodes arranged using the Kamada-Kawai layout algorithm, which positions nodes based on specified ideal distances between them. The nodes are connected in a loop, and the layout reflects the varying desired distances between connected pairs—ranging from short to long—resulting in a non-uniform, organically spaced circular structure.","from manim import *

class KamadaKawaiLayout(Scene):
    def construct(self):
        from collections import defaultdict
        distances: dict[int, dict[int, float]] = defaultdict(dict)

        # set desired distances
        distances[1][2] = 1  # distance between vertices 1 and 2 is 1
        distances[2][3] = 1  # distance between vertices 2 and 3 is 1
        distances[3][4] = 2  # etc
        distances[4][5] = 3
        distances[5][6] = 5
        distances[6][1] = 8

        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)],
            layout=""kamada_kawai"",
            layout_config={""dist"": distances},
            layout_scale=4,
            labels=True
        )
        self.add(graph)",Intermediate,train
,"Display a 2×2 table with row and column labels. The bottom-right cell is outlined in red to highlight it, while the rest of the table appears normally.","from manim import *

class GetCellExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        cell = table.get_cell((2,2), color=RED)
        self.add(table, cell)",Basic,train
,"Display two mathematical expressions stacked vertically. Both show a right arrow labeled with \( x^6y^8 \), but the top one is rendered using `MathTex` (optimized for math), and the bottom one uses `Tex` with inline math formatting.","from manim import *

class MathTeXDemo(Scene):
    def construct(self):
        rtarrow0 = MathTex(r""\xrightarrow{x^6y^8}"", font_size=96)
        rtarrow1 = Tex(r""$\xrightarrow{x^6y^8}$"", font_size=96)

        self.add(VGroup(rtarrow0, rtarrow1).arrange(DOWN))",Basic,train
,"Display a 3×3 table filled with alternating red circles and blue crosses. A red diagonal line is drawn from the bottom-left to the top-right corner of the table, crossing through the cells. It is a completed Tic-tac-toe game, 'O' has won.","from manim import *

class MobjectTableExample(Scene):
    def construct(self):
        cross = VGroup(
            Line(UP + LEFT, DOWN + RIGHT),
            Line(UP + RIGHT, DOWN + LEFT),
        )
        a = Circle().set_color(RED).scale(0.5)
        b = cross.set_color(BLUE).scale(0.5)
        t0 = MobjectTable(
            [[a.copy(),b.copy(),a.copy()],
            [b.copy(),a.copy(),a.copy()],
            [a.copy(),b.copy(),b.copy()]]
        )
        line = Line(
            t0.get_corner(DL), t0.get_corner(UR)
        ).set_color(RED)
        self.add(t0, line)",Basic,train
,"Display a polar coordinate grid, then plot an orange polar graph defined by the equation \( r = 2\sin(5\theta) \). The resulting curve forms a five-petaled rose pattern, symmetrically arranged around the origin.","from manim import *

class PolarGraphExample(Scene):
    def construct(self):
        plane = PolarPlane()
        r = lambda theta: 2 * np.sin(theta * 5)
        graph = plane.plot_polar_graph(r, [0, 2 * PI], color=ORANGE)
        self.add(plane, graph)",Advanced,train
,"Display a set of green axes with labels. Plot the sine function in blue and the cosine function in red. Label the sine graph with ""\sin(x)"" and the cosine graph with ""\cos(x)"". Draw a yellow vertical line at \( x = 2\pi \) and label it.","from manim import *

class SinAndCosFunctionPlot(Scene):
    def construct(self):
        axes = Axes(
            x_range=[-10, 10.3, 1],
            y_range=[-1.5, 1.5, 1],
            x_length=10,
            axis_config={""color"": GREEN},
            x_axis_config={
                ""numbers_to_include"": np.arange(-10, 10.01, 2),
                ""numbers_with_elongated_ticks"": np.arange(-10, 10.01, 2),
            },
            tips=False,
        )
        axes_labels = axes.get_axis_labels()
        sin_graph = axes.plot(lambda x: np.sin(x), color=BLUE)
        cos_graph = axes.plot(lambda x: np.cos(x), color=RED)

        sin_label = axes.get_graph_label(
            sin_graph, ""\\sin(x)"", x_val=-10, direction=UP / 2
        )
        cos_label = axes.get_graph_label(cos_graph, label=""\\cos(x)"")

        vert_line = axes.get_vertical_line(
            axes.i2gp(TAU, cos_graph), color=YELLOW, line_func=Line
        )
        line_label = axes.get_graph_label(
            cos_graph, r""x=2\pi"", x_val=TAU, direction=UR, color=WHITE
        )

        plot = VGroup(axes, sin_graph, cos_graph, vert_line)
        labels = VGroup(axes_labels, sin_label, cos_label, line_label)
        self.add(plot, labels)",Intermediate,train
"Display a filled triangle at the center of the screen and a square positioned on the left edge. As the animation begins, the triangle continuously spins around the center of the screen, while the square smoothly moves from the left edge to the right edge. The triangle keeps rotating throughout the square’s movement.","Display a filled triangle at the center of the screen and a square positioned on the left edge. As the animation begins, the triangle continuously spins around the center of the screen, while the square smoothly moves from the left edge to the right edge. The triangle keeps rotating throughout the square’s movement. This gives an illusion that the triangle is moving to the left while in actuality it is the square at the back moving to the right.","from manim import *

class SpinningTriangle(Scene):
    def construct(self):
        tri = Triangle().set_fill(opacity=1).set_z_index(2)
        sq = Square().to_edge(LEFT)

        # will keep spinning while there is an animation going on
        always_rotate(tri, rate=2*PI, about_point=ORIGIN)

        self.add(tri, sq)
        self.play(sq.animate.to_edge(RIGHT), rate_func=linear, run_time=1)",Intermediate,train
,"Display a 2×5 grid of evenly spaced dots. A line is first drawn between the first and second dots. Then, the line dynamically shifts to connect the second and third dots, and finally moves again to connect the fifth and eighth dots, demonstrating how a line can be updated to connect different points.","from manim import *

class LineExample(Scene):
    def construct(self):
        d = VGroup()
        for i in range(0,10):
            d.add(Dot())
        d.arrange_in_grid(buff=1)
        self.add(d)
        l= Line(d[0], d[1])
        self.add(l)
        self.wait()
        l.put_start_and_end_on(d[1].get_center(), d[2].get_center())
        self.wait()
        l.put_start_and_end_on(d[4].get_center(), d[7].get_center())
        self.wait()",Basic,train
,"Display a vector field using arrows, where each arrow’s direction and length are determined by a sine and cosine-based function. A gray reference circle appears on the left, followed by a red circle and a dot placed on the same position. Both the circle and the dot begin to move dynamically through the vector field, following its flow. The circle uses a pointwise nudge effect, while the dot follows a smoother path, creating a visual contrast in how each object responds to the field over time.","from manim import *

class Nudging(Scene):
    def construct(self):
        func = lambda pos: np.sin(pos[1] / 2) * RIGHT + np.cos(pos[0] / 2) * UP
        vector_field = ArrowVectorField(
            func, x_range=[-7, 7, 1], y_range=[-4, 4, 1], length_func=lambda x: x / 2
        )
        self.add(vector_field)
        circle = Circle(radius=2).shift(LEFT)
        self.add(circle.copy().set_color(GRAY))
        dot = Dot().move_to(circle)

        vector_field.nudge(circle, -2, 60, True)
        vector_field.nudge(dot, -2, 60)

        circle.add_updater(vector_field.get_nudge_updater(pointwise=True))
        dot.add_updater(vector_field.get_nudge_updater())
        self.add(circle, dot)
        self.wait(6)",Intermediate,train
,"Display a large LaTeX-styled expression consisting of a monospaced ""H"" followed by a looped right arrow, and then the LaTeX logo.","from manim import *

class AMSLaTeX(Scene):
    def construct(self):
        tex = Tex(r'$\mathtt{H} \looparrowright$ \LaTeX', font_size=144)
        self.add(tex)",Basic,train
,Display a square being drawn on the screen.,"from manim import *

class CreateScene(Scene):
    def construct(self):
        self.play(Create(Square()))",Basic,train
,"Display four different number lines arranged vertically with varied styles:

- The top line is blue, spans from -10 to 10 with tick marks every 2 units, includes numbers labeled above the line.
- The second line has a smaller unit size, includes numbers with elongated ticks at -2 and 4, and the number 6 is highlighted in red.
- The third line spans from -2.5 to 2.5 with 0.5 unit intervals, is 12 units long, and displays numbers with two decimal places.
- The bottom line spans from -5 to 5 with unit intervals, includes an arrow tip at the end, and is slightly rotated by 10 degrees.

All number lines appear on screen simultaneously without animation.","from manim import *

class NumberLineExample(Scene):
    def construct(self):
        l0 = NumberLine(
            x_range=[-10, 10, 2],
            length=10,
            color=BLUE,
            include_numbers=True,
            label_direction=UP,
        )

        l1 = NumberLine(
            x_range=[-10, 10, 2],
            unit_size=0.5,
            numbers_with_elongated_ticks=[-2, 4],
            include_numbers=True,
            font_size=24,
        )
        num6 = l1.numbers[8]
        num6.set_color(RED)

        l2 = NumberLine(
            x_range=[-2.5, 2.5 + 0.5, 0.5],
            length=12,
            decimal_number_config={""num_decimal_places"": 2},
            include_numbers=True,
        )

        l3 = NumberLine(
            x_range=[-5, 5 + 1, 1],
            length=6,
            include_tip=True,
            include_numbers=True,
            rotation=10 * DEGREES,
        )

        line_group = VGroup(l0, l1, l2, l3).arrange(DOWN, buff=1)
        self.add(line_group)",Intermediate,train
,"Display the word ""Colors"" in large font, with each letter randomly assigned a different bright color.","from manim import *

class IterateColor(Scene):
    def construct(self):
        text = Text(""Colors"", font_size=96)
        for letter in text:
            letter.set_color(random_bright_color())
        self.add(text)",Basic,train
,Display two five-sided polygons (pentagons) being drawn simultaneously: one on the left rotating counterclockwise and one on the right rotating clockwise. The reversed direction of the right polygon creates a mirrored drawing effect during the animation.,"from manim import *

class ChangeOfDirection(Scene):
    def construct(self):
        ccw = RegularPolygon(5)
        ccw.shift(LEFT)
        cw = RegularPolygon(5)
        cw.shift(RIGHT).reverse_direction()

        self.play(Create(ccw), Create(cw),
        run_time=4)",Basic,train
,"Display two dots: a white one shifted to the left and a dark grey one shifted to the right. A third dot appears between them, positioned 30% of the way from the left dot to the right dot, representing an interpolated position along the line connecting the two.","from manim import *

class DotInterpolation(Scene):
    def construct(self):
        dotR = Dot(color=DARK_GREY)
        dotR.shift(2 * RIGHT)
        dotL = Dot(color=WHITE)
        dotL.shift(2 * LEFT)

        dotMiddle = VMobject().interpolate(dotL, dotR, alpha=0.3)

        self.add(dotL, dotR, dotMiddle)",Basic,train
,"Display a coordinate plane with two vectors:

1. A vector pointing to the coordinates (1, 2), labeled with its coordinate values.
2. A vector pointing to the coordinates (−3, −2), also labeled, with the label colored yellow.

Both vectors originate from the origin and are shown on the grid.","from manim import *

class VectorCoordinateLabel(Scene):
    def construct(self):
        plane = NumberPlane()

        vec_1 = Vector([1, 2])
        vec_2 = Vector([-3, -2])
        label_1 = vec_1.coordinate_label()
        label_2 = vec_2.coordinate_label(color=YELLOW)

        self.add(plane, vec_1, vec_2, label_1, label_2)",Basic,train
,Display the mathematical expression for the product rule of differentiation. Draw a rectangle around the term \( f(x) \frac{d}{dx} g(x) \). Replace the rectangle with one around the term \( g(x) \frac{d}{dx} f(x) \).,"from manim import *

class MovingFrameBox(Scene):
    def construct(self):
        text=MathTex(
            ""\\frac{d}{dx}f(x)g(x)="",""f(x)\\frac{d}{dx}g(x)"",""+"",
            ""g(x)\\frac{d}{dx}f(x)""
        )
        self.play(Write(text))
        framebox1 = SurroundingRectangle(text[1], buff = .1)
        framebox2 = SurroundingRectangle(text[3], buff = .1)
        self.play(
            Create(framebox1),
        )
        self.wait()
        self.play(
            ReplacementTransform(framebox1,framebox2),
        )
        self.wait()",Intermediate,train
,"Display two large circles side by side—one red on the left and one green on the right. Both have thick outlines. The animation scales both circles down to a quarter of their original size: the red circle’s outline remains thick, while the green circle’s outline scales down proportionally with the shape.","from manim import *

class MobjectScaleExample(Scene):
    def construct(self):
        c1 = Circle(1, RED).set_x(-1)
        c2 = Circle(1, GREEN).set_x(1)

        vg = VGroup(c1, c2)
        vg.set_stroke(width=50)
        self.add(vg)

        self.play(
            c1.animate.scale(.25),
            c2.animate.scale(.25,
                scale_stroke=True)
        )",Basic,train
,"Display an orange square being drawn with its border appearing first, followed by the fill.","from manim import *

class ShowDrawBorderThenFill(Scene):
    def construct(self):
        self.play(DrawBorderThenFill(Square(fill_opacity=1, fill_color=ORANGE)))",Basic,train
,"Display four diagrams arranged horizontally, each showing two intersecting lines forming right angles. In each diagram, a right angle is marked with a curved arc and a dot at the vertex. The arcs vary in size, position, color, and styling—some use different quadrants, stroke widths, and dot colors—demonstrating different ways to annotate right angles.","from manim import *

class RightArcAngleExample(Scene):
    def construct(self):
        line1 = Line( LEFT, RIGHT )
        line2 = Line( DOWN, UP )
        rightarcangles = [
            Angle(line1, line2, dot=True),
            Angle(line1, line2, radius=0.4, quadrant=(1,-1), dot=True, other_angle=True),
            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, dot=True, dot_color=YELLOW, dot_radius=0.04, other_angle=True),
            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, dot=True, dot_color=GREEN, dot_radius=0.08),
        ]
        plots = VGroup()
        for angle in rightarcangles:
            plot=VGroup(line1.copy(),line2.copy(), angle)
            plots.add(plot)
        plots.arrange(buff=1.5)
        self.add(plots)",Intermediate,train
,"Display a blue streamlines vector field where each line flows according to a sine and cosine-based function. The streamlines begin animating immediately with a smooth, continuous motion, simulating fluid flow at a moderate speed. After a brief moment, the animation gracefully stops, freezing the streamlines in place.","from manim import *

class EndAnimation(Scene):
    def construct(self):
        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT
        stream_lines = StreamLines(
            func, stroke_width=3, max_anchors_per_line=5, virtual_time=1, color=BLUE
        )
        self.add(stream_lines)
        stream_lines.start_animation(warm_up=False, flow_speed=1.5, time_width=0.5)
        self.wait(1)
        self.play(stream_lines.end_animation())",Intermediate,train
,"Display a green dot in the upper right. Then animate four squares arranged in a row, each growing outward from a different point: the first from the center of the screen, the second from the top left, the third from the bottom right with its starting point highlighted in red, and the fourth from the position of the green dot, using the dot’s color as the highlight.","from manim import *

class GrowFromPointExample(Scene):
    def construct(self):
        dot = Dot(3 * UR, color=GREEN)
        squares = [Square() for _ in range(4)]
        VGroup(*squares).set_x(0).arrange(buff=1)
        self.add(dot)
        self.play(GrowFromPoint(squares[0], ORIGIN))
        self.play(GrowFromPoint(squares[1], [-2, 2, 0]))
        self.play(GrowFromPoint(squares[2], [3, -2, 0], RED))
        self.play(GrowFromPoint(squares[3], dot, dot.get_color()))",Basic,train
,"Display a graph with nine labeled nodes arranged in two concentric shells. The inner shell contains nodes 1, 2, and 3, forming a triangle. The outer shell contains nodes 4 through 9, each connected to one or more nodes in the inner shell. The layout emphasizes a layered structure, with connections radiating between the inner and outer shells to form a visually organized network.","from manim import *

class ShellLayout(Scene):
    def construct(self):
        nlist = [[1, 2, 3], [4, 5, 6, 7, 8, 9]]
        graph = Graph(
            [1, 2, 3, 4, 5, 6, 7, 8, 9],
            [(1, 2), (2, 3), (3, 1), (4, 1), (4, 2), (5, 2), (6, 2), (6, 3), (7, 3), (8, 3), (8, 1), (9, 1)],
            layout=""shell"",
            layout_config={""nlist"": nlist},
            labels=True
        )
        self.add(graph)",Intermediate,train
"Display a large dark gray pentagon centered on screen. Then, repeatedly animate a blue copy of the pentagon flashing along its outline with varying trail lengths. Each flash is accompanied by a label showing the current `time_width` value (0.2, 0.5, 1, and 2), updating with each animation to indicate the duration of the trailing effect.","Display a large dark gray pentagon centered on screen. Then, repeatedly animate a blue copy of the pentagon flashing along its outline with varying trail lengths. Each flash is accompanied by a label showing the current `time_width` value (0.2, 0.5, 1, and 2), updating with each animation to indicate the duration of the trailing effect. `time_width` is the length of the sliver relative to the length of the stroke being drawn.","from manim import *

class TimeWidthValues(Scene):
    def construct(self):
        p = RegularPolygon(5, color=DARK_GRAY, stroke_width=6).scale(3)
        lbl = VMobject()
        self.add(p, lbl)
        p = p.copy().set_color(BLUE)
        for time_width in [0.2, 0.5, 1, 2]:
            lbl.become(Tex(r""\texttt{time\_width={{%.1f}}}""%time_width))
            self.play(ShowPassingFlash(
                p.copy().set_color(BLUE),
                run_time=2,
                time_width=time_width
            ))",Intermediate,train
,"Display the text ""This is some \LaTeX"" and the mathematical expression \(\sum_{n=1}^\infty \frac{1}{n^2} = \frac{\pi^2}{6}\) arranged vertically. Write the text and fade in the expression from above. Transform the text to ""That was a transform"" and move it to the upper left corner while fading out the expression. Display a number plane with the text ""This is a grid"" on top. Fade out the previous text and fade in the new text while creating the grid. Apply a non-linear transformation to the grid and update the text to ""That was a non-linear function applied to the grid.""","from manim import *

class OpeningManim(Scene):
    def construct(self):
        title = Tex(r""This is some \LaTeX"")
        basel = MathTex(r""\sum_{n=1}^\infty \frac{1}{n^2} = \frac{\pi^2}{6}"")
        VGroup(title, basel).arrange(DOWN)
        self.play(
            Write(title),
            FadeIn(basel, shift=DOWN),
        )
        self.wait()

        transform_title = Tex(""That was a transform"")
        transform_title.to_corner(UP + LEFT)
        self.play(
            Transform(title, transform_title),
            LaggedStart(*[FadeOut(obj, shift=DOWN) for obj in basel]),
        )
        self.wait()

        grid = NumberPlane()
        grid_title = Tex(""This is a grid"", font_size=72)
        grid_title.move_to(transform_title)

        self.add(grid, grid_title)  # Make sure title is on top of grid
        self.play(
            FadeOut(title),
            FadeIn(grid_title, shift=UP),
            Create(grid, run_time=3, lag_ratio=0.1),
        )
        self.wait()

        grid_transform_title = Tex(
            r""That was a non-linear function \\ applied to the grid""
        )
        grid_transform_title.move_to(grid_title, UL)
        grid.prepare_for_nonlinear_transform()
        self.play(
            grid.animate.apply_function(
                lambda p: p
                          + np.array(
                    [
                        np.sin(p[1]),
                        np.sin(p[0]),
                        0,
                    ]
                )
            ),
            run_time=3,
        )
        self.wait()
        self.play(Transform(grid_title, grid_transform_title))
        self.wait()",Advanced,train
"Display five different types of tables arranged in two groups:

- **Top Group (scaled down and aligned at the top):**
  - A labeled table with two rows and two columns, including row and column headers and a top-left label. The cell at row 2, column 2 is highlighted in green.
  - A decimal table showing values of \(x\) and \(f(x) = e^x\) for five evenly spaced \(x\)-values from -2 to 2. The cell at row 2, column 2 is highlighted in red.

- **Bottom Group (scaled down and aligned at the bottom):**
  - A math table with addition values, where the first row and column act as headers. The first three horizontal and vertical grid lines are colored blue and layered above the table.
  - A table of geometric objects (circles and crosses), arranged in a 3×3 grid. A red diagonal line crosses the table from bottom-left to top-right.
  - An integer table filled with numbers from 1 to 20 arranged in a 5×4 grid, with outer lines included.

All tables are neatly arranged with spacing between them and displayed together on the screen.","Display five different types of tables arranged in two groups:

- **Top Group (scaled down and aligned at the top):**
  - A labeled table with two rows and two columns, including row and column headers and a top-left label. The cell at row 2, column 2 is highlighted in green.
  - A decimal table showing values of \(x\) and \(f(x) = e^x\) for five evenly spaced \(x\)-values from -2 to 2. The cell at row 2, column 2 is highlighted in red.

- **Bottom Group (scaled down and aligned at the bottom):**
  - A math table with addition values, where the first row and column act as headers. The first three horizontal and vertical grid lines are colored blue and layered above the table.
  - A table of geometric objects (circles and crosses), arranged in a 3×3 grid. A red diagonal line crosses the table from bottom-left to top-right. It is a completed Tic-tac-toe game, 'O' has won.
  - An integer table filled with numbers from 1 to 20 arranged in a 5×4 grid, with outer lines included.

All tables are neatly arranged with spacing between them and displayed together on the screen.","from manim import *

class TableExamples(Scene):
    def construct(self):
        t0 = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")],
            top_left_entry=Text(""TOP""))
        t0.add_highlighted_cell((2,2), color=GREEN)
        x_vals = np.linspace(-2,2,5)
        y_vals = np.exp(x_vals)
        t1 = DecimalTable(
            [x_vals, y_vals],
            row_labels=[MathTex(""x""), MathTex(""f(x)"")],
            include_outer_lines=True)
        t1.add(t1.get_cell((2,2), color=RED))
        t2 = MathTable(
            [[""+"", 0, 5, 10],
            [0, 0, 5, 10],
            [2, 2, 7, 12],
            [4, 4, 9, 14]],
            include_outer_lines=True)
        t2.get_horizontal_lines()[:3].set_color(BLUE)
        t2.get_vertical_lines()[:3].set_color(BLUE)
        t2.get_horizontal_lines()[:3].set_z_index(1)
        cross = VGroup(
            Line(UP + LEFT, DOWN + RIGHT),
            Line(UP + RIGHT, DOWN + LEFT))
        a = Circle().set_color(RED).scale(0.5)
        b = cross.set_color(BLUE).scale(0.5)
        t3 = MobjectTable(
            [[a.copy(),b.copy(),a.copy()],
            [b.copy(),a.copy(),a.copy()],
            [a.copy(),b.copy(),b.copy()]])
        t3.add(Line(
            t3.get_corner(DL), t3.get_corner(UR)
        ).set_color(RED))
        vals = np.arange(1,21).reshape(5,4)
        t4 = IntegerTable(
            vals,
            include_outer_lines=True
        )
        g1 = Group(t0, t1).scale(0.5).arrange(buff=1).to_edge(UP, buff=1)
        g2 = Group(t2, t3, t4).scale(0.5).arrange(buff=1).to_edge(DOWN, buff=1)
        self.add(g1, g2)",Intermediate,train
,"Display a blue rectangle at the center of the screen with a translucent gray copy behind it for reference. A number is shown at the top edge of the screen, dynamically updating to reflect the rectangle’s width. The rectangle then smoothly expands horizontally until its width reaches 7 units, while the number updates in real time.","from manim import *

class WidthExample(Scene):
    def construct(self):
        decimal = DecimalNumber().to_edge(UP)
        rect = Rectangle(color=BLUE)
        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)

        decimal.add_updater(lambda d: d.set_value(rect.width))

        self.add(rect_copy, rect, decimal)
        self.play(rect.animate.set(width=7))
        self.wait()",Basic,train
,Display a large label at the center of the screen containing the text “Label Text” in a sans-serif font. The text is enclosed in a semi-transparent blue box.,"from manim import *

class LabelExample(Scene):
    def construct(self):
        label = Label(
            label=Text('Label Text', font='sans-serif'),
            box_config = {
                ""color"" : BLUE,
                ""fill_opacity"" : 0.75
            }
        )
        label.scale(3)
        self.add(label)",Basic,train
,"Display the word ""Wiggle"" in large text at the center of the screen, then animate it with a playful wiggling motion before pausing briefly.","from manim import *

class ApplyingWaves(Scene):
    def construct(self):
        tex = Tex(""Wiggle"").scale(3)
        self.play(Wiggle(tex))
        self.wait()",Basic,train
,"Display a coordinate grid with axes visible. A linear transformation is applied using the matrix \(\begin{bmatrix} 1 & 1 \\ 0 & 1 \end{bmatrix}\), which shears the grid horizontally. Ghost vectors are left behind to show the original positions before the transformation, helping visualize the effect of the matrix on the space.","from manim import *

class LinearTransformationSceneExample(LinearTransformationScene):
    def __init__(self, **kwargs):
        LinearTransformationScene.__init__(
            self,
            show_coordinates=True,
            leave_ghost_vectors=True,
            **kwargs
        )

    def construct(self):
        matrix = [[1, 1], [0, 1]]
        self.apply_matrix(matrix)
        self.wait()",Intermediate,train
,"Display a 2×2 matrix  
\[
\begin{bmatrix}
2 & 3 \\
1 & 5
\end{bmatrix}
\]  
with each entry individually colored:  
- 2 in blue  
- 3 in green  
- 1 in yellow  
- 5 in red  

The matrix appears on screen without animation.","from manim import *

class GetEntriesExample(Scene):
    def construct(self):
        m0 = Matrix([[2, 3], [1, 5]])
        ent = m0.get_entries()
        colors = [BLUE, GREEN, YELLOW, RED]
        for k in range(len(colors)):
            ent[k].set_color(colors[k])
        self.add(m0)",Intermediate,train
,"Display a 2×2 matrix  
\[
\begin{bmatrix}
\pi & 3 \\
1 & 5
\end{bmatrix}
\]  
with its left bracket colored blue and right bracket colored green. The matrix appears on screen without animation.","from manim import *

class GetBracketsExample(Scene):
    def construct(self):
        m0 = Matrix([[""\\pi"", 3], [1, 5]])
        bra = m0.get_brackets()
        colors = [BLUE, GREEN]
        for k in range(len(colors)):
            bra[k].set_color(colors[k])
        self.add(m0)",Basic,train
,"Display a 3D scene with a coordinate axis system and a colorful surface representing the function \( z = \sin(x) \cos(y) \) over a square domain. The surface is fully opaque and shaded using a color gradient: red for lower values, yellow for mid-range, and green for higher values along the vertical (z) axis. The camera is angled from above and behind to highlight the surface's undulating shape.","from manim import *

class FillByValueExample(ThreeDScene):
    def construct(self):
        resolution_fa = 8
        self.set_camera_orientation(phi=75 * DEGREES, theta=-160 * DEGREES)
        axes = ThreeDAxes(x_range=(0, 5, 1), y_range=(0, 5, 1), z_range=(-1, 1, 0.5))
        def param_surface(u, v):
            x = u
            y = v
            z = np.sin(x) * np.cos(y)
            return z
        surface_plane = Surface(
            lambda u, v: axes.c2p(u, v, param_surface(u, v)),
            resolution=(resolution_fa, resolution_fa),
            v_range=[0, 5],
            u_range=[0, 5],
            )
        surface_plane.set_style(fill_opacity=1)
        surface_plane.set_fill_by_value(axes=axes, colorscale=[(RED, -0.5), (YELLOW, 0), (GREEN, 0.5)], axis=2)
        self.add(axes, surface_plane)",Basic,train
,"Display two dots, one at the coordinates (-2, -1) and the other at (2, 1). Draw an orange line connecting the two dots. Add a brace below the line with the text ""Horizontal distance"" and another brace perpendicular to the line with the text ""x-x_1"".","from manim import *

class BraceAnnotation(Scene):
    def construct(self):
        dot = Dot([-2, -1, 0])
        dot2 = Dot([2, 1, 0])
        line = Line(dot.get_center(), dot2.get_center()).set_color(ORANGE)
        b1 = Brace(line)
        b1text = b1.get_text(""Horizontal distance"")
        b2 = Brace(line, direction=line.copy().rotate(PI / 2).get_unit_vector())
        b2text = b2.get_tex(""x-x_1"")
        self.add(line, dot, dot2, b1, b2, b1text, b2text)",Basic,train
,"Display a graph with six labeled nodes arranged using the spring layout, which simulates physical forces to position nodes in a way that minimizes edge crossings and evenly distributes them. The nodes are connected in a loop with additional cross-links between non-adjacent nodes, forming a dense and organically spaced network that balances visual clarity and connectivity.","from manim import *

class SpringLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout=""spring"",
            labels=True
        )
        self.add(graph)",Intermediate,train
,"Display a 3D octahedron with an edge length of 3 units, centered in the scene. The camera is angled at 75° vertically and 30° horizontally to provide a clear, tilted view. One vertex of the octahedron is highlighted in red, and one of its triangular faces is colored yellow, emphasizing individual components of the polyhedron.","from manim import *

class PolyhedronSubMobjects(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        octahedron = Octahedron(edge_length = 3)
        octahedron.graph[0].set_color(RED)
        octahedron.faces[2].set_color(YELLOW)
        self.add(octahedron)",Basic,train
,"Display three smaller Manim banners stacked vertically:

- The bottom banner expands to the right.
- The middle banner expands outward from the center.
- The top banner expands to the left.

All three banners animate their expansion simultaneously.","from manim import *

class ExpandDirections(Scene):
    def construct(self):
        banners = [ManimBanner().scale(0.5).shift(UP*x) for x in [-2, 0, 2]]
        self.play(
            banners[0].expand(direction=""right""),
            banners[1].expand(direction=""center""),
            banners[2].expand(direction=""left""),
        )",Basic,train
"Display four annular sectors on a white background, each positioned in a different quadrant of the screen: a default yellow sector in the upper left, a red sector with a thicker ring and 45-degree angle in the upper right, a semi-transparent blue half-ring in the lower left, and a green sector in the lower right drawn clockwise with a 270-degree angle.","Display four annular sectors on a white background, each positioned in a different quadrant of the screen: 

- a default yellow sector in the upper left
- a red sector with a thicker ring and 45-degree angle in the upper right
- a semi-transparent blue half-ring in the lower left, and a green sector in the lower right drawn clockwise with a 270-degree angle.","from manim import *

class AnnularSectorExample(Scene):
    def construct(self):
        # Changes background color to clearly visualize changes in fill_opacity.
        self.camera.background_color = WHITE

        # The default parameter start_angle is 0, so the AnnularSector starts from the +x-axis.
        s1 = AnnularSector(color=YELLOW).move_to(2 * UL)

        # Different inner_radius and outer_radius than the default.
        s2 = AnnularSector(inner_radius=1.5, outer_radius=2, angle=45 * DEGREES, color=RED).move_to(2 * UR)

        # fill_opacity is typically a number > 0 and <= 1. If fill_opacity=0, the AnnularSector is transparent.
        s3 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=PI, fill_opacity=0.25, color=BLUE).move_to(2 * DL)

        # With a negative value for the angle, the AnnularSector is drawn clockwise from the start value.
        s4 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=-3 * PI / 2, color=GREEN).move_to(2 * DR)

        self.add(s1, s2, s3, s4)",Intermediate,train
,"Display a large white number “0” centered on the screen. Animate the number counting smoothly from 0 to 100 over four seconds, keeping it centered throughout the animation. Then pause.","from manim import *

class Count(Animation):
    def __init__(self, number: DecimalNumber, start: float, end: float, **kwargs) -> None:
        # Pass number as the mobject of the animation
        super().__init__(number,  **kwargs)
        # Set start and end
        self.start = start
        self.end = end

    def interpolate_mobject(self, alpha: float) -> None:
        # Set value of DecimalNumber according to alpha
        value = self.start + (alpha * (self.end - self.start))
        self.mobject.set_value(value)


class CountingScene(Scene):
    def construct(self):
        # Create Decimal Number and add it to scene
        number = DecimalNumber().set_color(WHITE).scale(5)
        # Add an updater to keep the DecimalNumber centered as its value changes
        number.add_updater(lambda number: number.move_to(ORIGIN))

        self.add(number)

        self.wait()

        # Play the Count Animation to count from 0 to 100 in 4 seconds
        self.play(Count(number, 0, 100), run_time=4, rate_func=linear)

        self.wait()",Advanced,train
,"First, transform a circle into a square, then transform that square into a triangle, and finally fade out the triangle. After a brief pause, repeat the sequence using replacement transforms: replace the circle with a square, then replace the square with a triangle, and finally fade out the triangle.","from manim import *

class TwoTransforms(Scene):
    def transform(self):
        a = Circle()
        b = Square()
        c = Triangle()
        self.play(Transform(a, b))
        self.play(Transform(a, c))
        self.play(FadeOut(a))

    def replacement_transform(self):
        a = Circle()
        b = Square()
        c = Triangle()
        self.play(ReplacementTransform(a, b))
        self.play(ReplacementTransform(b, c))
        self.play(FadeOut(c))

    def construct(self):
        self.transform()
        self.wait(0.5)  # wait for 0.5 seconds
        self.replacement_transform()",Basic,train
,"Display the word “Manim” centered on the screen, with a straight underline drawn directly beneath it, emphasizing the text.","from manim import *

class UnderLine(Scene):
    def construct(self):
        man = Tex(""Manim"")  # Full Word
        ul = Underline(man)  # Underlining the word
        self.add(man, ul)",Basic,train
,"Display a 2×2 matrix  
\[
\begin{bmatrix}
\pi & 3 \\
1 & 5
\end{bmatrix}
\]  
with a surrounding rectangle highlighting the second row (containing the numbers 1 and 5). The matrix and highlight appear on screen without animation.","from manim import *

class GetRowsExample(Scene):
    def construct(self):
        m0 = Matrix([[""\\pi"", 3], [1, 5]])
        m0.add(SurroundingRectangle(m0.get_rows()[1]))
        self.add(m0)",Basic,train
,"Display a graph with six labeled nodes arranged using a planar layout, which positions the nodes to avoid edge crossings where possible. The nodes are connected in a loop with additional cross-links between non-adjacent nodes, forming a dense but neatly spaced structure that maintains visual clarity and planarity.","from manim import *

class PlanarLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout=""planar"",
            layout_scale=4,
            labels=True
        )
        self.add(graph)",Intermediate,train
,"Display a square at the center of the screen. First, the square is drawn. Then, in a single smooth animation, it shifts to the right, doubles in size, and rotates 90 degrees counterclockwise. Finally, the square disappears.","from manim import *

class AnimateChainExample(Scene):
    def construct(self):
        s = Square()
        self.play(Create(s))
        self.play(s.animate.shift(RIGHT).scale(2).rotate(PI / 2))
        self.play(Uncreate(s))",Basic,train
,"Display a five-pointed star shape (pentagram) centered on the screen. Then, a red star with the same outer radius is drawn over it with a smooth animation. After being displayed briefly, the red star fades out gradually.","from manim import *

class StarExample(Scene):
    def construct(self):
        pentagram = RegularPolygram(5, radius=2)
        star = Star(outer_radius=2, color=RED)

        self.add(pentagram)
        self.play(Create(star), run_time=3)
        self.play(FadeOut(star), run_time=2)",Basic,train
,"Display a directed graph with five labeled nodes arranged in a circular layout. Arrows connect the nodes according to specified edges, with all edges styled using thin lines and square arrow tips. One specific edge, from node 3 to node 4, is highlighted in red and features a larger, more prominent arrow tip. The entire graph scales up slightly as it is drawn onto the screen.","from manim import *

class CustomDiGraph(Scene):
    def construct(self):
        vertices = [i for i in range(5)]
        edges = [
            (0, 1),
            (1, 2),
            (3, 2),
            (3, 4),
        ]

        edge_config = {
            ""stroke_width"": 2,
            ""tip_config"": {
                ""tip_shape"": ArrowSquareTip,
                ""tip_length"": 0.15,
            },
            (3, 4): {
                ""color"": RED,
                ""tip_config"": {""tip_length"": 0.25, ""tip_width"": 0.25}
            },
        }

        g = DiGraph(
            vertices,
            edges,
            labels=True,
            layout=""circular"",
            edge_config=edge_config,
        ).scale(1.4)

        self.play(Create(g))
        self.wait()",Intermediate,train
,"Display a 3D coordinate system with three colored dots placed at specific positions:

1. A red dot located at the point (0, 0, 1), one unit above the origin along the Z-axis.
2. A blue dot with a smaller radius positioned at (2, 0, 0), two units along the X-axis.
3. An orange dot, also with a smaller radius, placed at the origin (0, 0, 0).

The camera is angled at 75° vertically and -45° horizontally, providing a clear, tilted view of the 3D space and the relative positions of the dots.","from manim import *

class Dot3DExample(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)

        axes = ThreeDAxes()
        dot_1 = Dot3D(point=axes.coords_to_point(0, 0, 1), color=RED)
        dot_2 = Dot3D(point=axes.coords_to_point(2, 0, 0), radius=0.1, color=BLUE)
        dot_3 = Dot3D(point=[0, 0, 0], radius=0.1, color=ORANGE)
        self.add(axes, dot_1, dot_2,dot_3)",Basic,train
,"Animate the creation of a yellow streamlines vector field, where each line flows according to a custom function that subtly rotates and shifts position vectors. The streamlines appear gradually across the screen with a smooth animation, using shorter lines and fewer anchor points for performance and visual clarity.","from manim import *

class StreamLineCreation(Scene):
    def construct(self):
        func = lambda pos: (pos[0] * UR + pos[1] * LEFT) - pos
        stream_lines = StreamLines(
            func,
            color=YELLOW,
            x_range=[-7, 7, 1],
            y_range=[-4, 4, 1],
            stroke_width=3,
            virtual_time=1,  # use shorter lines
            max_anchors_per_line=5,  # better performance with fewer anchors
        )
        self.play(stream_lines.create())  # uses virtual_time as run_time
        self.wait()",Intermediate,train
,"Display a vector field where each arrow’s direction is determined by a sine and cosine-based function. Initially, the arrows appear with their default magnitudes. Then, the entire vector field smoothly transforms as the function is scaled down by half, resulting in shorter arrows while maintaining their original directions.","from manim import *

class ScaleVectorFieldFunction(Scene):
    def construct(self):
        func = lambda pos: np.sin(pos[1]) * RIGHT + np.cos(pos[0]) * UP
        vector_field = ArrowVectorField(func)
        self.add(vector_field)
        self.wait()

        func = VectorField.scale_func(func, 0.5)
        self.play(vector_field.animate.become(ArrowVectorField(func)))
        self.wait()",Basic,train
,"Display a square and a circle side by side with space between them. The square rotates 90 degrees counterclockwise over two seconds, while at the same time, the circle shifts to the right and then returns to its original position in a smooth back-and-forth motion.","from manim import *

class AnimateWithArgsExample(Scene):
    def construct(self):
        s = Square()
        c = Circle()

        VGroup(s, c).arrange(RIGHT, buff=2)
        self.add(s, c)

        self.play(
            s.animate(run_time=2).rotate(PI / 2),
            c.animate(rate_func=there_and_back).shift(RIGHT),
        )",Basic,train
,"Display a rectangle being drawn over 3 seconds. Then, one second later, the first line of text ""I was added with Add!"" appears. After another second, the remaining two lines ""Me too!"" and ""And me!"" appear simultaneously, all within the rectangle.","from manim import *

class DefaultAddScene(Scene):
    def construct(self):
        text_1 = Text(""I was added with Add!"")
        text_2 = Text(""Me too!"")
        text_3 = Text(""And me!"")
        texts = VGroup(text_1, text_2, text_3).arrange(DOWN)
        rect = SurroundingRectangle(texts, buff=0.5)

        self.play(
            Create(rect, run_time=3.0),
            Succession(
                Wait(1.0),
                # You can Add a Mobject in the middle of an animation...
                Add(text_1),
                Wait(1.0),
                # ...or multiple Mobjects at once!
                Add(text_2, text_3),
            ),
        )
        self.wait()",Basic,train
,"Display a set of coordinate axes with labeled ticks, then place a dot at the point \((-3.5, 2)\). A vertical dashed line extends from this point downward to the x-axis, visually marking the x-coordinate of the dot.","from manim import *

class GetVerticalLineExample(Scene):
    def construct(self):
        ax = Axes().add_coordinates()
        point = ax.coords_to_point(-3.5, 2)

        dot = Dot(point)
        line = ax.get_vertical_line(point, line_config={""dashed_ratio"": 0.85})

        self.add(ax, line, dot)",Basic,train
,"Display the word “Indicate” in large font on the screen, then animate it with a brief highlighting effect that draws attention to the text.","from manim import *

class UsingIndicate(Scene):
    def construct(self):
        tex = Tex(""Indicate"").scale(3)
        self.play(Indicate(tex))
        self.wait()",Basic,train
,"Display four arc polygons arranged horizontally across the screen, each formed by three points: the origin, a point to the right, and a point above. The first uses default arcs with a large radius, the second uses arcs with a fixed angle, the third uses uniformly styled red arcs with a specific radius, and the fourth is fully filled in red with each arc segment customized in radius, angle, and color.","from manim import *

class SeveralArcPolygons(Scene):
    def construct(self):
        a = [0, 0, 0]
        b = [2, 0, 0]
        c = [0, 2, 0]
        ap1 = ArcPolygon(a, b, c, radius=2)
        ap2 = ArcPolygon(a, b, c, angle=45*DEGREES)
        ap3 = ArcPolygon(a, b, c, arc_config={'radius': 1.7, 'color': RED})
        ap4 = ArcPolygon(a, b, c, color=RED, fill_opacity=1,
                                    arc_config=[{'radius': 1.7, 'color': RED},
                                    {'angle': 20*DEGREES, 'color': BLUE},
                                    {'radius': 1}])
        ap_group = VGroup(ap1, ap2, ap3, ap4).arrange()
        self.play(*[Create(ap) for ap in [ap1, ap2, ap3, ap4]])
        self.wait()",Intermediate,train
,"Display two seven-pointed stars arranged side by side:

1. A red star with a density of 2, creating a more open and less intersecting shape.
2. A purple star with a density of 3, resulting in a more intricate and tightly woven pattern.

The difference in density alters how the star points connect, showcasing distinct geometric styles.","from manim import *

class DifferentDensitiesExample(Scene):
    def construct(self):
        density_2 = Star(7, outer_radius=2, density=2, color=RED)
        density_3 = Star(7, outer_radius=2, density=3, color=PURPLE)

        self.add(VGroup(density_2, density_3).arrange(RIGHT))",Basic,train
,"Display a graph with six labeled nodes arranged randomly across the screen. The nodes are connected by a mix of sequential and cross-linking edges, forming a dense and irregular network. The layout emphasizes randomness, resulting in a visually scattered but fully connected structure.","from manim import *

class RandomLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout=""random"",
            labels=True
        )
        self.add(graph)",Intermediate,train
,"Display a vector field using arrows, where each arrow's direction and magnitude are determined by a custom function that subtly rotates and scales the position vectors. The field is shown on a neutral background without animation.","from manim import *

class BasicUsage(Scene):
    def construct(self):
        func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3
        self.add(ArrowVectorField(func))",Basic,train
,"Display a 3D tetrahedron—a four-faced polyhedron with triangular faces—centered in the scene. The camera is set at a 75° vertical angle and a 30° horizontal angle, providing a tilted perspective that clearly reveals the tetrahedron’s geometric form.","from manim import *

class TetrahedronScene(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        obj = Tetrahedron()
        self.add(obj)",Basic,train
,"Display a 3D square pyramid centered in the scene, constructed from five vertices: four forming a square base and one apex above the center. The pyramid consists of four triangular side faces and one square base. The camera is angled at 75° vertically and 30° horizontally, providing a clear, tilted view of the pyramid’s structure.","from manim import *

class SquarePyramidScene(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        vertex_coords = [
            [1, 1, 0],
            [1, -1, 0],
            [-1, -1, 0],
            [-1, 1, 0],
            [0, 0, 2]
        ]
        faces_list = [
            [0, 1, 4],
            [1, 2, 4],
            [2, 3, 4],
            [3, 0, 4],
            [0, 1, 2, 3]
        ]
        pyramid = Polyhedron(vertex_coords, faces_list)
        self.add(pyramid)",Intermediate,train
"Display a 2×2 table with row and column labels. The bottom-right cell is highlighted in green and placed behind the table content, creating a subtle background emphasis without covering the cell's text.","Display a 2×2 table with row and column labels. The top-left cell is highlighted in green and placed behind the table content, creating a subtle background emphasis without covering the cell's text.","from manim import *

class GetHighlightedCellExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        highlight = table.get_highlighted_cell((2,2), color=GREEN)
        table.add_to_back(highlight)
        self.add(table)",Basic,train
,"Display a diagonal line from the bottom-left to the top-right of the screen. Place three colored dots along the line: a red dot at one-quarter of the way, a blue dot at the midpoint, and a yellow dot at three-quarters of the way along the line.","from manim import *

class PointFromProportion(Scene):
    def construct(self):
        line = Line(2*DL, 2*UR)
        self.add(line)
        colors = (RED, BLUE, YELLOW)
        proportions = (1/4, 1/2, 3/4)
        for color, proportion in zip(colors, proportions):
            self.add(Dot(color=color).move_to(
                    line.point_from_proportion(proportion)
            ))",Basic,train
,Display a set of axes with labels. Plot two curves: one in blue and the other in green. Draw yellow vertical lines at \( x = 2 \) and \( x = 3 \) on the blue curve. Show a blue Riemann rectangle area between \( x = 0.3 \) and \( x = 0.6 \) on the blue curve. Display a grey shaded area between the green and blue curves from \( x = 2 \) to \( x = 3 \).,"from manim import *

class GraphAreaPlot(Scene):
    def construct(self):
        ax = Axes(
            x_range=[0, 5],
            y_range=[0, 6],
            x_axis_config={""numbers_to_include"": [2, 3]},
            tips=False,
        )

        labels = ax.get_axis_labels()

        curve_1 = ax.plot(lambda x: 4 * x - x ** 2, x_range=[0, 4], color=BLUE_C)
        curve_2 = ax.plot(
            lambda x: 0.8 * x ** 2 - 3 * x + 4,
            x_range=[0, 4],
            color=GREEN_B,
        )

        line_1 = ax.get_vertical_line(ax.input_to_graph_point(2, curve_1), color=YELLOW)
        line_2 = ax.get_vertical_line(ax.i2gp(3, curve_1), color=YELLOW)

        riemann_area = ax.get_riemann_rectangles(curve_1, x_range=[0.3, 0.6], dx=0.03, color=BLUE, fill_opacity=0.5)
        area = ax.get_area(curve_2, [2, 3], bounded_graph=curve_1, color=GREY, opacity=0.5)

        self.add(ax, labels, curve_1, curve_2, line_1, line_2, riemann_area, area)",Intermediate,train
,"Display a square, a circle, a triangle, an arrow, and a star arranged in two rows. Animate the square growing from the center of the screen, the circle expanding outward from its center, the triangle growing upward from its bottom edge, the arrow extending from left to right, and the star spinning into view from nothing.","from manim import *

class Growing(Scene):
    def construct(self):
        square = Square()
        circle = Circle()
        triangle = Triangle()
        arrow = Arrow(LEFT, RIGHT)
        star = Star()

        VGroup(square, circle, triangle).set_x(0).arrange(buff=1.5).set_y(2)
        VGroup(arrow, star).move_to(DOWN).set_x(0).arrange(buff=1.5).set_y(-2)

        self.play(GrowFromPoint(square, ORIGIN))
        self.play(GrowFromCenter(circle))
        self.play(GrowFromEdge(triangle, DOWN))
        self.play(GrowArrow(arrow))
        self.play(SpinInFromNothing(star))",Basic,train
,"Display a polar coordinate grid labeled in terms of π radians. A vector is drawn from the origin to the point corresponding to the polar coordinates \( (3, \frac{\pi}{4}) \), visually illustrating the conversion from polar to Cartesian coordinates.","from manim import *

class PolarToPointExample(Scene):
    def construct(self):
        polarplane_pi = PolarPlane(azimuth_units=""PI radians"", size=6)
        polartopoint_vector = Vector(polarplane_pi.polar_to_point(3, PI/4))
        self.add(polarplane_pi)
        self.add(polartopoint_vector)",Intermediate,train
,"Display a translucent green Reuleaux triangle with blue curved edges and one red arc, formed by three arcs connecting three points in an equilateral triangle layout. The shape fades into view at the center of the screen with partial fill and visible stroke outlines.","from manim import *

class ArcPolygonExample2(Scene):
    def construct(self):
        arc_conf = {""stroke_width"": 3, ""stroke_color"": BLUE,
            ""fill_opacity"": 0.5, ""color"": GREEN}
        poly_conf = {""color"": None}
        a = [-1, 0, 0]
        b = [1, 0, 0]
        c = [0, np.sqrt(3), 0]
        arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)
        arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)
        arc2 = ArcBetweenPoints(c, a, radius=2, stroke_color=RED)
        reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)
        self.play(FadeIn(reuleaux_tri))
        self.wait(2)",Intermediate,train
,"Display a coordinate grid with labeled axes, where the x-axis ranges from 0 to 10 and the y-axis uses a logarithmic scale. A curve representing the function \( y = x^2 \) is plotted from just above 0 to 10. The graph visually demonstrates how the quadratic function behaves when the vertical axis is scaled logarithmically.","from manim import *

class LogScalingExample(Scene):
    def construct(self):
        ax = Axes(
            x_range=[0, 10, 1],
            y_range=[-2, 6, 1],
            tips=False,
            axis_config={""include_numbers"": True},
            y_axis_config={""scaling"": LogBase(custom_labels=True)},
        )

        # x_min must be > 0 because log is undefined at 0.
        graph = ax.plot(lambda x: x ** 2, x_range=[0.001, 10], use_smoothing=False)
        self.add(ax, graph)",Basic,train
,Display a 3D coordinate system with labeled axes. The y-axis is labeled with the text “\( y \)-label” using LaTeX formatting. The camera is set at an angled perspective to clearly show the 3D structure and the position of the y-axis label in space.,"from manim import *

class GetYAxisLabelExample(ThreeDScene):
    def construct(self):
        ax = ThreeDAxes()
        lab = ax.get_y_axis_label(Tex(""$y$-label""))
        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)
        self.add(ax, lab)",Basic,train
,"Display a bar chart with five labeled bars:  
- Bars represent the values -5, 40, -10, 20, and -3, labeled respectively as ""one"", ""two"", ""three"", ""four"", and ""five"".  
- The chart spans a y-axis range from -20 to 50 with tick marks every 10 units.  
- The x-axis is 10 units long with large font labels, and the y-axis is 6 units tall.  
- Each bar has a corresponding numerical label displayed above or below it.  
The chart and labels appear on screen simultaneously without animation.","from manim import *

class BarChartExample(Scene):
    def construct(self):
        chart = BarChart(
            values=[-5, 40, -10, 20, -3],
            bar_names=[""one"", ""two"", ""three"", ""four"", ""five""],
            y_range=[-20, 50, 10],
            y_length=6,
            x_length=10,
            x_axis_config={""font_size"": 36},
        )

        c_bar_lbls = chart.get_bar_labels(font_size=48)

        self.add(chart, c_bar_lbls)",Intermediate,train
,"Display a red semi-transparent square on the left and a green semi-transparent triangle on the right. After a brief pause, the camera smoothly pans to center on the square, then transitions to center on the triangle, creating a dynamic shift in focus between the two shapes.","from manim import *

class MovingCameraCenter(MovingCameraScene):
    def construct(self):
        s = Square(color=RED, fill_opacity=0.5).move_to(2 * LEFT)
        t = Triangle(color=GREEN, fill_opacity=0.5).move_to(2 * RIGHT)
        self.wait(0.3)
        self.add(s, t)
        self.play(self.camera.frame.animate.move_to(s))
        self.wait(0.3)
        self.play(self.camera.frame.animate.move_to(t))",Basic,train
,"Display three overlaid function graphs on screen:  
- A red curve representing a composite cosine function.  
- A blue curve representing a composite sine function, identical in form to the cosine one.  
- A green version of the same sine function, restricted to a smaller x-range and shifted upward.  
All three graphs appear together without animation.","from manim import *

class ExampleFunctionGraph(Scene):
    def construct(self):
        cos_func = FunctionGraph(
            lambda t: np.cos(t) + 0.5 * np.cos(7 * t) + (1 / 7) * np.cos(14 * t),
            color=RED,
        )

        sin_func_1 = FunctionGraph(
            lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),
            color=BLUE,
        )

        sin_func_2 = FunctionGraph(
            lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),
            x_range=[-4, 4],
            color=GREEN,
        ).move_to([0, 1, 0])

        self.add(cos_func, sin_func_1, sin_func_2)",Intermediate,train
,"Display three rectangles arranged horizontally:

1. A wide rectangle with a grid overlay spaced at 1.0 units horizontally and 0.5 units vertically.
2. A tall, narrow rectangle without a grid.
3. A square-shaped rectangle with a 1×1 grid overlay and thinner grid lines, showing a more compact and evenly divided layout.","from manim import *

class RectangleExample(Scene):
    def construct(self):
        rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)
        rect2 = Rectangle(width=1.0, height=4.0)
        rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)
        rect3.grid_lines.set_stroke(width=1)

        rects = Group(rect1, rect2, rect3).arrange(buff=1)
        self.add(rects)",Basic,train
,"Display a 3D blue cube with semi-transparent faces (70% opacity) and a side length of 3 units, centered in the scene. The camera is angled at 75° vertically and -45° horizontally, providing a clear, tilted view that reveals multiple faces of the cube simultaneously. A 3D coordinate axis system is also present in the scene for spatial reference.","from manim import *

class CubeExample(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)

        axes = ThreeDAxes()
        cube = Cube(side_length=3, fill_opacity=0.7, fill_color=BLUE)
        self.add(cube)",Basic,train
,"Display a 2×2 table with row and column labels. The row labels “R1” and “R2” are each assigned a randomly chosen bright color, making them stand out from the rest of the table.","from manim import *

class GetRowLabelsExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        lab = table.get_row_labels()
        for item in lab:
            item.set_color(random_bright_color())
        self.add(table)",Basic,train
,"Display a green-outlined circle on the left and a semi-transparent pink triangle on the right, each with a faint white background rectangle behind them. The background rectangles are then animated: the one behind the circle rotates 45 degrees, and the one behind the triangle rotates 90 degrees, creating a dynamic visual effect.","from manim import *

class ExampleBackgroundRectangle(Scene):
    def construct(self):
        circle = Circle().shift(LEFT)
        circle.set_stroke(color=GREEN, width=20)
        triangle = Triangle().shift(2 * RIGHT)
        triangle.set_fill(PINK, opacity=0.5)
        backgroundRectangle1 = BackgroundRectangle(circle, color=WHITE, fill_opacity=0.15)
        backgroundRectangle2 = BackgroundRectangle(triangle, color=WHITE, fill_opacity=0.15)
        self.add(backgroundRectangle1)
        self.add(backgroundRectangle2)
        self.add(circle)
        self.add(triangle)
        self.play(Rotate(backgroundRectangle1, PI / 4))
        self.play(Rotate(backgroundRectangle2, PI / 2))",Basic,train
,"Display a blue rectangle at the center of the screen with a translucent gray copy behind it for reference. A number is shown at the top edge of the screen, dynamically updating to reflect the rectangle’s height. The rectangle then smoothly grows taller until its height reaches 5 units, while the number updates in real time.","from manim import *

class HeightExample(Scene):
    def construct(self):
        decimal = DecimalNumber().to_edge(UP)
        rect = Rectangle(color=BLUE)
        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)

        decimal.add_updater(lambda d: d.set_value(rect.height))

        self.add(rect_copy, rect, decimal)
        self.play(rect.animate.set(height=5))
        self.wait()",Basic,train
,"Display a red semi-transparent square on the left and a green semi-transparent triangle on the right. After a brief pause, the camera smoothly pans to center on the square, then transitions to center on the triangle, creating a dynamic shift in focus between the two shapes.","from manim import *

class MovingAndZoomingCamera(MovingCameraScene):
    def construct(self):
        s = Square(color=BLUE, fill_opacity=0.5).move_to(2 * LEFT)
        t = Triangle(color=YELLOW, fill_opacity=0.5).move_to(2 * RIGHT)
        self.add(s, t)
        self.play(self.camera.frame.animate.move_to(s).set(width=s.width*2))
        self.wait(0.3)
        self.play(self.camera.frame.animate.move_to(t).set(width=t.width*2))

        self.play(self.camera.frame.animate.move_to(ORIGIN).set(width=14))",Intermediate,train
,"Display the text “Fade In” in large font as it fades into view from below while scaling up slightly. Then transform it into the text “Fade Out.” Finally, animate “Fade Out” fading away while moving further downward and scaling up.","from manim import *

class Fading(Scene):
    def construct(self):
        tex_in = Tex(""Fade"", ""In"").scale(3)
        tex_out = Tex(""Fade"", ""Out"").scale(3)
        self.play(FadeIn(tex_in, shift=DOWN, scale=0.66))
        self.play(ReplacementTransform(tex_in, tex_out))
        self.play(FadeOut(tex_out, shift=DOWN * 2, scale=1.5))",Basic,train
,"Display a vector field where each arrow points away from a vertical line on the left, with direction determined by subtracting a fixed leftward vector. The arrows are color-coded based on their magnitude, transitioning through red, yellow, blue, and dark gray. Two reference circles are shown on the left: a small red circle representing the minimum magnitude and a large dark gray circle representing the maximum magnitude used for the color scheme.","from manim import *

class Coloring(Scene):
    def construct(self):
        func = lambda pos: pos - LEFT * 5
        colors = [RED, YELLOW, BLUE, DARK_GRAY]
        min_radius = Circle(radius=2, color=colors[0]).shift(LEFT * 5)
        max_radius = Circle(radius=10, color=colors[-1]).shift(LEFT * 5)
        vf = ArrowVectorField(
            func, min_color_scheme_value=2, max_color_scheme_value=10, colors=colors
        )
        self.add(vf, min_radius, max_radius)",Basic,train
,"Display a 3D octahedron—a polyhedron with eight triangular faces—centered in the scene. The camera is positioned at a 75° vertical angle and a 30° horizontal angle, giving a tilted view that clearly reveals the octahedron’s symmetrical structure.","from manim import *

class OctahedronScene(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        obj = Octahedron()
        self.add(obj)",Basic,train
,"Display two small squares rotating simultaneously in place: one starts above the center and rotates in a full circle around the origin, while the other rotates in place at the center of the screen. Both rotations are smooth and complete one full turn.","from manim import *

class UsingRotate(Scene):
    def construct(self):
        self.play(
            Rotate(
                Square(side_length=0.5).shift(UP * 2),
                angle=2*PI,
                about_point=ORIGIN,
                rate_func=linear,
            ),
            Rotate(Square(side_length=0.5), angle=2*PI, rate_func=linear),
            )",Intermediate,train
Display a set of axes and plot the sine curve in blue. Show an orange dot at the start of the curve and two additional dots at the start and end of the curve. Zoom in the camera to follow the orange dot as it moves along the sine curve. Restore the camera to its original state. ,Display a set of axes and plot the sine curve in blue. Show an orange dot at the start of the curve and two additional dots at the start and end of the curve. Zoom in the camera to follow the orange dot as it moves along the sine curve. At the end of the video restore the camera to its original state. ,"from manim import *

class FollowingGraphCamera(MovingCameraScene):
    def construct(self):
        self.camera.frame.save_state()

        # create the axes and the curve
        ax = Axes(x_range=[-1, 10], y_range=[-1, 10])
        graph = ax.plot(lambda x: np.sin(x), color=BLUE, x_range=[0, 3 * PI])

        # create dots based on the graph
        moving_dot = Dot(ax.i2gp(graph.t_min, graph), color=ORANGE)
        dot_1 = Dot(ax.i2gp(graph.t_min, graph))
        dot_2 = Dot(ax.i2gp(graph.t_max, graph))

        self.add(ax, graph, dot_1, dot_2, moving_dot)
        self.play(self.camera.frame.animate.scale(0.5).move_to(moving_dot))

        def update_curve(mob):
            mob.move_to(moving_dot.get_center())

        self.camera.frame.add_updater(update_curve)
        self.play(MoveAlongPath(moving_dot, graph, rate_func=linear))
        self.camera.frame.remove_updater(update_curve)

        self.play(Restore(self.camera.frame))",Intermediate,train
,"Display a blue square with partial fill. The square rotates 180 degrees over 2 seconds with a linear motion, then it is highlighted using the `Indicate` animation without changing its color. The default settings for `Rotate` and `Indicate` are temporarily modified for this scene and then reset afterward.","from manim import *

class ChangeDefaultAnimation(Scene):
    def construct(self):
        Rotate.set_default(run_time=2, rate_func=rate_functions.linear)
        Indicate.set_default(color=None)

        S = Square(color=BLUE, fill_color=BLUE, fill_opacity=0.25)
        self.add(S)
        self.play(Rotate(S, PI))
        self.play(Indicate(S))

        Rotate.set_default()
        Indicate.set_default()",Basic,train
,"Display a dot positioned to the right of the origin and a number label that dynamically follows the dot’s position. As the dot rotates in a full circle around the origin, the label continuously updates its value to reflect the dot’s current x-coordinate and stays positioned next to the dot throughout the motion.","from manim import *

class NextToUpdater(Scene):
    def construct(self):
        def dot_position(mobject):
            mobject.set_value(dot.get_center()[0])
            mobject.next_to(dot)

        dot = Dot(RIGHT*3)
        label = DecimalNumber()
        label.add_updater(dot_position)
        self.add(dot, label)

        self.play(Rotating(dot, about_point=ORIGIN, angle=TAU, run_time=TAU, rate_func=linear))",Intermediate,train
,"Display a polar coordinate grid with a size of 6 units. The azimuth (angle) labels are shown in terms of π radians, and both the angle and radius labels are styled with a larger font size for clarity. Coordinate labels are added to enhance readability of the polar layout.","from manim import *

class PolarPlaneExample(Scene):
    def construct(self):
        polarplane_pi = PolarPlane(
            azimuth_units=""PI radians"",
            size=6,
            azimuth_label_font_size=33.6,
            radius_config={""font_size"": 33.6},
        ).add_coordinates()
        self.add(polarplane_pi)",Basic,train
,"Display a red square and a yellow circle labeled with keys ""s"" and ""c"" respectively, grouped together using a visual dictionary. After a pause, green text labeled ""t"" appears below the square. A rectangle is then added below the text and labeled ""r"". The text changes color to purple, scales up, and is then replaced with new blue text. This new text is removed, followed by the red square being uncreated, the yellow circle fading out, and the rectangle fading out while shifting downward. Finally, two new VDicts appear: one on the left showing integers 1, 2, and 3 stacked vertically, and another on the right showing a square, circle, and rectangle arranged together.","from manim import *

class ShapesWithVDict(Scene):
    def construct(self):
        square = Square().set_color(RED)
        circle = Circle().set_color(YELLOW).next_to(square, UP)

        # create dict from list of tuples each having key-mobject pair
        pairs = [(""s"", square), (""c"", circle)]
        my_dict = VDict(pairs, show_keys=True)

        # display it just like a VGroup
        self.play(Create(my_dict))
        self.wait()

        text = Tex(""Some text"").set_color(GREEN).next_to(square, DOWN)

        # add a key-value pair by wrapping it in a single-element list of tuple
        # after attrs branch is merged, it will be easier like `.add(t=text)`
        my_dict.add([(""t"", text)])
        self.wait()

        rect = Rectangle().next_to(text, DOWN)
        # can also do key assignment like a python dict
        my_dict[""r""] = rect

        # access submobjects like a python dict
        my_dict[""t""].set_color(PURPLE)
        self.play(my_dict[""t""].animate.scale(3))
        self.wait()

        # also supports python dict styled reassignment
        my_dict[""t""] = Tex(""Some other text"").set_color(BLUE)
        self.wait()

        # remove submobject by key
        my_dict.remove(""t"")
        self.wait()

        self.play(Uncreate(my_dict[""s""]))
        self.wait()

        self.play(FadeOut(my_dict[""c""]))
        self.wait()

        self.play(FadeOut(my_dict[""r""], shift=DOWN))
        self.wait()

        # you can also make a VDict from an existing dict of mobjects
        plain_dict = {
            1: Integer(1).shift(DOWN),
            2: Integer(2).shift(2 * DOWN),
            3: Integer(3).shift(3 * DOWN),
        }

        vdict_from_plain_dict = VDict(plain_dict)
        vdict_from_plain_dict.shift(1.5 * (UP + LEFT))
        self.play(Create(vdict_from_plain_dict))

        # you can even use zip
        vdict_using_zip = VDict(zip([""s"", ""c"", ""r""], [Square(), Circle(), Rectangle()]))
        vdict_using_zip.shift(1.5 * RIGHT)
        self.play(Create(vdict_using_zip))
        self.wait()",Intermediate,train
,"Display a circle positioned in the upper-right corner of the screen. A LaTeX-style text reading “To the corner!” is placed in the lower-left corner with no buffer space, and a mathematical expression “\(x^3\)” is positioned in the upper-left corner with extra spacing from the edges. All three elements appear simultaneously.","from manim import *

class ToCornerExample(Scene):
    def construct(self):
        c = Circle()
        c.to_corner(UR)
        t = Tex(""To the corner!"")
        t2 = MathTex(""x^3"").shift(DOWN)
        self.add(c,t,t2)
        t.to_corner(DL, buff=0)
        t2.to_corner(UL, buff=1.5)",Basic,train
,"Display a thick yellow horizontal line across the screen with rounded ends, demonstrating the use of a round cap style for line terminations.","from manim import *

class CapStyleExample(Scene):
    def construct(self):
        line = Line(LEFT, RIGHT, color=YELLOW, stroke_width=20)
        line.set_cap_style(CapStyleType.ROUND)
        self.add(line)",Basic,train
,"Display the word “Hello” in large text on the screen, animating it as if it is being written out by hand.","from manim import *

class ShowWrite(Scene):
    def construct(self):
        self.play(Write(Text(""Hello"", font_size=144)))",Basic,train
,"Display three vertically aligned dots on the left side of the screen, along with a red dashed vertical line labeled ""25%"" and a title at the top reading ""lag_ratio = 0.25"". The dots then move horizontally to the right, one after another, with a slight delay between each movement based on a lag ratio of 0.25. The entire animation lasts 4 seconds.","from manim import *

class LaggedStartExample(Scene):
    def construct(self):
        title = Text(""lag_ratio = 0.25"").to_edge(UP)

        dot1 = Dot(point=LEFT * 2 + UP, radius=0.16)
        dot2 = Dot(point=LEFT * 2, radius=0.16)
        dot3 = Dot(point=LEFT * 2 + DOWN, radius=0.16)
        line_25 = DashedLine(
            start=LEFT + UP * 2,
            end=LEFT + DOWN * 2,
            color=RED
        )
        label = Text(""25%"", font_size=24).next_to(line_25, UP)
        self.add(title, dot1, dot2, dot3, line_25, label)

        self.play(LaggedStart(
            dot1.animate.shift(RIGHT * 4),
            dot2.animate.shift(RIGHT * 4),
            dot3.animate.shift(RIGHT * 4),
            lag_ratio=0.25,
            run_time=4
        ))",Intermediate,train
,"Display a coordinate grid with a purple curve representing the function \( y = x^2 \), and a second curve showing its derivative, \( y = 2x \), automatically computed and plotted. The original function is labeled “\( x^2 \)” near \( x = -2 \), and the derivative is labeled “\( 2x \)” near \( x = 3 \). This scene visually illustrates the relationship between a function and its derivative.","from manim import *

class DerivativeGraphExample(Scene):
    def construct(self):
        ax = NumberPlane(y_range=[-1, 7], background_line_style={""stroke_opacity"": 0.4})

        curve_1 = ax.plot(lambda x: x ** 2, color=PURPLE_B)
        curve_2 = ax.plot_derivative_graph(curve_1)
        curves = VGroup(curve_1, curve_2)

        label_1 = ax.get_graph_label(curve_1, ""x^2"", x_val=-2, direction=DL)
        label_2 = ax.get_graph_label(curve_2, ""2x"", x_val=3, direction=RIGHT)
        labels = VGroup(label_1, label_2)

        self.add(ax, curves, labels)",Intermediate,train
,"Display a series of text labels, each showing the name of a different indication animation in large font. For each label:

1. Apply the corresponding indication effect:
   - “ApplyWave” animates a wave passing through the text.
   - “Circumscribe” draws a border around the text.
   - “Flash” creates a flashing effect at the top of the screen.
   - “FocusOn” highlights the text with a spotlight effect.
   - “Indicate” briefly highlights the text with a pulsing effect.
   - “ShowPassingFlash” animates an underline flashing across the text.
   - “Wiggle” makes the text wiggle.

2. After each effect, fade out the current label upward and fade in the next one from below, cycling through all the animations.","from manim import *

class Indications(Scene):
    def construct(self):
        indications = [ApplyWave,Circumscribe,Flash,FocusOn,Indicate,ShowPassingFlash,Wiggle]
        names = [Tex(i.__name__).scale(3) for i in indications]

        self.add(names[0])
        for i in range(len(names)):
            if indications[i] is Flash:
                self.play(Flash(UP))
            elif indications[i] is ShowPassingFlash:
                self.play(ShowPassingFlash(Underline(names[i])))
            else:
                self.play(indications[i](names[i]))
            self.play(AnimationGroup(
                FadeOut(names[i], shift=UP*1.5),
                FadeIn(names[(i+1)%len(names)], shift=UP*1.5),
            ))",Intermediate,train
,"Display two lines originating from the same point: one extending horizontally to the right, and the other rotated upward at an 80-degree angle. An angle arc is drawn between them with a radius of 1.5 units, and a red dot marks the midpoint of this angle arc. The scene pauses briefly to display the full construction.","from manim import *

class AngleMidPoint(Scene):
    def construct(self):
        line1 = Line(ORIGIN, 2*RIGHT)
        line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)

        a = Angle(line1, line2, radius=1.5, other_angle=False)
        d = Dot(a.get_midpoint()).set_color(RED)

        self.add(line1, line2, a, d)
        self.wait()",Basic,train
,"Set the background color to white. Display a red square on the left and a blue square on the right. Internally rotate the points of the blue square to alter its orientation. Then, animate the red square transforming into a red circle on the left, and simultaneously transform the rotated blue square into a blue circle on the right.","from manim import *

class ExampleRotation(Scene):
    def construct(self):
        self.camera.background_color = WHITE
        m1a = Square().set_color(RED).shift(LEFT)
        m1b = Circle().set_color(RED).shift(LEFT)
        m2a = Square().set_color(BLUE).shift(RIGHT)
        m2b = Circle().set_color(BLUE).shift(RIGHT)

        points = m2a.points
        points = np.roll(points, int(len(points)/4), axis=0)
        m2a.points = points

        self.play(Transform(m1a,m1b),Transform(m2a,m2b), run_time=1)",Basic,train
,"Display a coordinate grid with default x- and y-axes, but with both axes using the ""StealthTip"" style for their arrow tips. The axes appear clean and minimal, with no numerical labels or tick marks by default.","from manim import *

class AxesWithDifferentTips(Scene):
    def construct(self):
        ax = Axes(axis_config={'tip_shape': StealthTip})
        self.add(ax)",Basic,train
,"Display four sets of two intersecting lines forming right angles, each with a different style of right angle marker:

1. The first uses the default size and position.
2. The second has a smaller marker placed in a different quadrant.
3. The third has a slightly larger marker with a thicker stroke in another quadrant.
4. The fourth features the largest marker, colored red, positioned in a different quadrant.

All four sets are arranged horizontally with space between them.","from manim import *

class RightAngleExample(Scene):
    def construct(self):
        line1 = Line( LEFT, RIGHT )
        line2 = Line( DOWN, UP )
        rightangles = [
            RightAngle(line1, line2),
            RightAngle(line1, line2, length=0.4, quadrant=(1,-1)),
            RightAngle(line1, line2, length=0.5, quadrant=(-1,1), stroke_width=8),
            RightAngle(line1, line2, length=0.7, quadrant=(-1,-1), color=RED),
        ]
        plots = VGroup()
        for rightangle in rightangles:
            plot=VGroup(line1.copy(),line2.copy(), rightangle)
            plots.add(plot)
        plots.arrange(buff=1.5)
        self.add(plots)",Basic,train
"Display a blue dot and a green dot arranged horizontally with a red line connecting them. Move the blue dot to the right and the green dot upwards, updating the connecting line dynamically.","Display a blue dot and a green dot arranged horizontally with a white line connecting them. Move the blue dot to the right and the green dot upwards, updating the connecting line dynamically.","from manim import *

class MovingDots(Scene):
    def construct(self):
        d1,d2=Dot(color=BLUE),Dot(color=GREEN)
        dg=VGroup(d1,d2).arrange(RIGHT,buff=1)
        l1=Line(d1.get_center(),d2.get_center()).set_color(RED)
        x=ValueTracker(0)
        y=ValueTracker(0)
        d1.add_updater(lambda z: z.set_x(x.get_value()))
        d2.add_updater(lambda z: z.set_y(y.get_value()))
        l1.add_updater(lambda z: z.become(Line(d1.get_center(),d2.get_center())))
        self.add(d1,d2,l1)
        self.play(x.animate.set_value(5))
        self.play(y.animate.set_value(4))
        self.wait()",Intermediate,train
,"Display the text ""Hello ★ LaTeX"" in large font, where the star is a LaTeX-rendered symbol and the LaTeX logo is typeset properly. The substring ""igsta"" within the star symbol is colored red, though it may not visibly affect the output since ""igsta"" does not appear in the visible text.","from manim import *

class LaTeXSubstrings(Scene):
    def construct(self):
        tex = Tex('Hello', r'$\bigstar$', r'\LaTeX', font_size=144)
        tex.set_color_by_tex('igsta', RED)
        self.add(tex)",Basic,train
,"Display 3D axes. Set the camera orientation to a specific angle. Show the text ""This is a 3D text"" fixed in the upper left corner of the frame.","from manim import *

class FixedInFrameMObjectTest(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)
        text3d = Text(""This is a 3D text"")
        self.add_fixed_in_frame_mobjects(text3d)
        text3d.to_corner(UL)
        self.add(axes)
        self.wait()",Intermediate,train
,"Display a 2×2 matrix  
\[
\begin{bmatrix}
\pi & 3 \\
1 & 5
\end{bmatrix}
\]  
with a surrounding rectangle highlighting the second column (containing the numbers 3 and 5). The matrix and highlight appear on screen without animation.","from manim import *

class GetColumnsExample(Scene):
    def construct(self):
        m0 = Matrix([[r""\pi"", 3], [1, 5]])
        m0.add(SurroundingRectangle(m0.get_columns()[1]))
        self.add(m0)",Basic,train
,"Display a number plane with labeled axes ranging from 0 to 7 on the x-axis and 0 to 5 on the y-axis. A gold-colored line graph is plotted through a series of six data points, each marked with a purple dot outlined in black. The graph shows a fluctuating trend, rising and falling across the plotted x-values, and is centered on the screen for clear visibility.","from manim import *

class LineGraphExample(Scene):
    def construct(self):
        plane = NumberPlane(
            x_range = (0, 7),
            y_range = (0, 5),
            x_length = 7,
            axis_config={""include_numbers"": True},
        )
        plane.center()
        line_graph = plane.plot_line_graph(
            x_values = [0, 1.5, 2, 2.8, 4, 6.25],
            y_values = [1, 3, 2.25, 4, 2.5, 1.75],
            line_color=GOLD_E,
            vertex_dot_style=dict(stroke_width=3,  fill_color=PURPLE),
            stroke_width = 4,
        )
        self.add(plane, line_graph)",Basic,train
,"Display a red parametric curve traced by the point \((\sin(2t), \sin(3t))\) as \(t\) ranges from 0 to \(2\pi\), scaled up by a factor of 3. The curve appears on screen without animation.","from manim import *

class PlotParametricFunction(Scene):
    def func(self, t):
        return (np.sin(2 * t), np.sin(3 * t), 0)

    def construct(self):
        func = ParametricFunction(self.func, t_range = (0, TAU), fill_opacity=0).set_color(RED)
        self.add(func.scale(3))",Intermediate,train
,"Display six colored circles arranged vertically on the left side of the screen, each labeled with a different angle: -90°, 0°, 30°, 90°, 180°, and 270°. Each circle animates by transforming into a matching circle on the right side of the screen, following a curved path determined by the specified angle:

- Negative angles move clockwise,
- Positive angles move counterclockwise,
- 0° moves in a straight line.

Each transformation is accompanied by a yellow arc showing the path taken, visually demonstrating how different `path_arc` values affect the motion.","from manim import *

class TransformPathArc(Scene):
    def construct(self):
        def make_arc_path(start, end, arc_angle):
            points = []
            p_fn = path_along_arc(arc_angle)
            # alpha animates between 0.0 and 1.0, where 0.0
            # is the beginning of the animation and 1.0 is the end.
            for alpha in range(0, 11):
                points.append(p_fn(start, end, alpha / 10.0))
            path = VMobject(stroke_color=YELLOW)
            path.set_points_smoothly(points)
            return path

        left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)
        colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]
        # Positive angles move counter-clockwise, negative angles move clockwise.
        examples = [-90, 0, 30, 90, 180, 270]
        anims = []
        for idx, angle in enumerate(examples):
            left_c = left.copy().shift((3 - idx) * UP)
            left_c.fill_color = colors[idx]
            right_c = left_c.copy().shift(4 * RIGHT)
            path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),
                                     arc_angle=angle * DEGREES)
            desc = Text('%d°' % examples[idx]).next_to(left_c, LEFT)
            # Make the circles in front of the text in front of the arcs.
            self.add(
                path_arc.set_z_index(1),
                desc.set_z_index(2),
                left_c.set_z_index(3),
            )
            anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))

        self.play(*anims, run_time=2)
        self.wait()",Advanced,train
,"Display a stationary line from left to right. Show a second line rotating around a point on the left, forming an angle with the stationary line. Label the angle with the Greek letter theta (θ). Animate the rotating line to change its angle, updating the angle and its label dynamically. Change the color of the theta label to red briefly.","from manim import *

class MovingAngle(Scene):
    def construct(self):
        rotation_center = LEFT

        theta_tracker = ValueTracker(110)
        line1 = Line(LEFT, RIGHT)
        line_moving = Line(LEFT, RIGHT)
        line_ref = line_moving.copy()
        line_moving.rotate(
            theta_tracker.get_value() * DEGREES, about_point=rotation_center
        )
        a = Angle(line1, line_moving, radius=0.5, other_angle=False)
        tex = MathTex(r""\theta"").move_to(
            Angle(
                line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False
            ).point_from_proportion(0.5)
        )

        self.add(line1, line_moving, a, tex)
        self.wait()

        line_moving.add_updater(
            lambda x: x.become(line_ref.copy()).rotate(
                theta_tracker.get_value() * DEGREES, about_point=rotation_center
            )
        )

        a.add_updater(
            lambda x: x.become(Angle(line1, line_moving, radius=0.5, other_angle=False))
        )
        tex.add_updater(
            lambda x: x.move_to(
                Angle(
                    line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False
                ).point_from_proportion(0.5)
            )
        )

        self.play(theta_tracker.animate.set_value(40))
        self.play(theta_tracker.animate.increment_value(140))
        self.play(tex.animate.set_color(RED), run_time=0.5)
        self.play(theta_tracker.animate.set_value(350))",Intermediate,train
,"Display a large circle and a copy of it at the center of the screen. The copy is transformed using a complex exponential function, creating a warped version of the original. Then, over three seconds, the transformed circle continuously morphs as if it's being rotated and distorted by a dynamic complex function, gradually completing a full rotation while changing color to blue.","from manim import *

class ApplyFuncExample(Scene):
    def construct(self):
        circ = Circle().scale(1.5)
        circ_ref = circ.copy()
        circ.apply_complex_function(
            lambda x: np.exp(x*1j)
        )
        t = ValueTracker(0)
        circ.add_updater(
            lambda x: x.become(circ_ref.copy().apply_complex_function(
                lambda x: np.exp(x+t.get_value()*1j)
            )).set_color(BLUE)
        )
        self.add(circ_ref)
        self.play(TransformFromCopy(circ_ref, circ))
        self.play(t.animate.set_value(TAU), run_time=3)",Intermediate,train
,"Display the word ""Hello"" in large font with a smooth gradient transitioning from red to blue to green across the text.","from manim import *

class GradientExample(Scene):
    def construct(self):
        t = Text(""Hello"", gradient=(RED, BLUE, GREEN), font_size=96)
        self.add(t)",Basic,train
,"Display 24 small white rectangles, each labeled with a number from 1 to 24, arranged in a grid. The grid flows down each column before moving to the next (top to bottom, then left to right). The columns and rows have custom spacing and alignment: columns are aligned left, center, or right as specified, and rows are aligned upper, center, or down. The first and last columns and rows have fixed widths and heights, while the others adjust automatically.","from manim import *

class ArrangeInGrid(Scene):
    def construct(self):
        boxes = VGroup(*[
            Rectangle(WHITE, 0.5, 0.5).add(Text(str(i+1)).scale(0.5))
            for i in range(24)
        ])
        self.add(boxes)

        boxes.arrange_in_grid(
            buff=(0.25,0.5),
            col_alignments=""lccccr"",
            row_alignments=""uccd"",
            col_widths=[1, *[None]*4, 1],
            row_heights=[1, None, None, 1],
            flow_order=""dr""
        )",Intermediate,train
,"Display a red circle with a red dot on its edge, positioned to the left. As the circle rolls to the right across the screen over 4 seconds, it rotates and leaves behind a traced path showing the trajectory of the point on its edge. The path is continuously drawn as the circle moves.","from manim import *

class TracedPathExample(Scene):
    def construct(self):
        circ = Circle(color=RED).shift(4*LEFT)
        dot = Dot(color=RED).move_to(circ.get_start())
        rolling_circle = VGroup(circ, dot)
        trace = TracedPath(circ.get_start)
        rolling_circle.add_updater(lambda m: m.rotate(-0.3))
        self.add(trace, rolling_circle)
        self.play(rolling_circle.animate.shift(8*RIGHT), run_time=4, rate_func=linear)",Basic,train
,"Display a 3D scene with a set of 15 points in space, each marked by a small dot. These points are enclosed by a translucent convex hull—a 3D shape formed by connecting the outermost points. The hull has no visible faces but faint blue edges with low opacity. The camera is angled to provide a clear view of the 3D structure, tilted at 75° vertically and 30° horizontally.","from manim import *

class ConvexHull3DExample(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        points = [
            [ 1.93192757,  0.44134585, -1.52407061],
            [-0.93302521,  1.23206983,  0.64117067],
            [-0.44350918, -0.61043677,  0.21723705],
            [-0.42640268, -1.05260843,  1.61266094],
            [-1.84449637,  0.91238739, -1.85172623],
            [ 1.72068132, -0.11880457,  0.51881751],
            [ 0.41904805,  0.44938012, -1.86440686],
            [ 0.83864666,  1.66653337,  1.88960123],
            [ 0.22240514, -0.80986286,  1.34249326],
            [-1.29585759,  1.01516189,  0.46187522],
            [ 1.7776499,  -1.59550796, -1.70240747],
            [ 0.80065226, -0.12530398,  1.70063977],
            [ 1.28960948, -1.44158255,  1.39938582],
            [-0.93538943,  1.33617705, -0.24852643],
            [-1.54868271,  1.7444399,  -0.46170734]
        ]
        hull = ConvexHull3D(
            *points,
            faces_config = {""stroke_opacity"": 0},
            graph_config = {
                ""vertex_type"": Dot3D,
                ""edge_config"": {
                    ""stroke_color"": BLUE,
                    ""stroke_width"": 2,
                    ""stroke_opacity"": 0.05,
                }
            }
        )
        dots = VGroup(*[Dot3D(point) for point in points])
        self.add(hull)
        self.add(dots)",Advanced,train
,"Display a streamlines vector field where each line flows according to a custom function combining sine, cosine, and position-based scaling. Two rectangles are overlaid: a smaller one labeled ""Spawning Area"" indicating where streamlines originate, and a larger one labeled ""Flowing Area"" showing the full region where the streamlines move. Both labels have semi-transparent background rectangles for readability.","from manim import *

class SpawningAndFlowingArea(Scene):
    def construct(self):
        func = lambda pos: np.sin(pos[0]) * UR + np.cos(pos[1]) * LEFT + pos / 5
        stream_lines = StreamLines(
            func, x_range=[-3, 3, 0.2], y_range=[-2, 2, 0.2], padding=1
        )

        spawning_area = Rectangle(width=6, height=4)
        flowing_area = Rectangle(width=8, height=6)
        labels = [Tex(""Spawning Area""), Tex(""Flowing Area"").shift(DOWN * 2.5)]
        for lbl in labels:
            lbl.add_background_rectangle(opacity=0.6, buff=0.05)

        self.add(stream_lines, spawning_area, flowing_area, *labels)",Intermediate,train
,"Display two arrows arranged vertically: one pointing horizontally from left to right, and the other diagonally from bottom right to top left. Animate the first arrow growing from left to right. Then animate the second arrow growing along its diagonal path with its starting point highlighted in red.","from manim import *

class GrowArrowExample(Scene):
    def construct(self):
        arrows = [Arrow(2 * LEFT, 2 * RIGHT), Arrow(2 * DR, 2 * UL)]
        VGroup(*arrows).set_x(0).arrange(buff=2)
        self.play(GrowArrow(arrows[0]))
        self.play(GrowArrow(arrows[1], point_color=RED))",Basic,train
,"Display a blue dot on the left and a red dot on the right, each with a short horizontal line extending from them. A smooth cubic Bézier curve connects the ends of these lines, arching from the blue dot’s line to the red dot’s line, forming a flowing S-shaped path across the screen.","from manim import *

class BezierSplineExample(Scene):
    def construct(self):
        p1 = np.array([-3, 1, 0])
        p1b = p1 + [1, 0, 0]
        d1 = Dot(point=p1).set_color(BLUE)
        l1 = Line(p1, p1b)
        p2 = np.array([3, -1, 0])
        p2b = p2 - [1, 0, 0]
        d2 = Dot(point=p2).set_color(RED)
        l2 = Line(p2, p2b)
        bezier = CubicBezier(p1b, p1b + 3 * RIGHT, p2b - 3 * RIGHT, p2b)
        self.add(l1, d1, l2, d2, bezier)",Intermediate,train
,"Display three colored circles: red on the left, green in the center, and blue on the right. Initially, the red and green circles are grouped together, and the blue circle is in a separate group. After a pause, the blue circle is added to the first group, and the entire group shifts downward. Then, the blue circle is removed from the group, and the two groups animate separately—one shifting left and the other shifting up. Next, all three circles shift right together. Finally, only the green and blue circles (excluding the red) shift right.","from manim import *

class AddToVGroup(Scene):
    def construct(self):
        circle_red = Circle(color=RED)
        circle_green = Circle(color=GREEN)
        circle_blue = Circle(color=BLUE)
        circle_red.shift(LEFT)
        circle_blue.shift(RIGHT)
        gr = VGroup(circle_red, circle_green)
        gr2 = VGroup(circle_blue) # Constructor uses add directly
        self.add(gr,gr2)
        self.wait()
        gr += gr2 # Add group to another
        self.play(
            gr.animate.shift(DOWN),
        )
        gr -= gr2 # Remove group
        self.play( # Animate groups separately
            gr.animate.shift(LEFT),
            gr2.animate.shift(UP),
        )
        self.play( #Animate groups without modification
            (gr+gr2).animate.shift(RIGHT)
        )
        self.play( # Animate group without component
            (gr-circle_red).animate.shift(RIGHT)
        )",Intermediate,train
,"Display a coordinate axes system with a quadratic curve representing \( y = 0.5x^2 - 0.5 \). Three sets of Riemann rectangles are shown:

1. **Right-endpoint rectangles** in a gradient from teal to dark blue, approximating the area under the curve from \( x = -4 \) to \( x = -3 \).
2. **Left-endpoint rectangles** in yellow, spanning from \( x = -1.5 \) to \( x = 1.5 \), with inverted colors for areas below the x-axis.
3. **Bounded rectangles** between the quadratic curve and a straight line \( y = 1.5x \), from \( x = 4 \) to \( x = 5 \), filled with a gradient from maroon to purple.

All elements are combined to illustrate different Riemann sum approximations and bounded area visualization.","from manim import *

class GetRiemannRectanglesExample(Scene):
    def construct(self):
        ax = Axes(y_range=[-2, 10])
        quadratic = ax.plot(lambda x: 0.5 * x ** 2 - 0.5)

        # the rectangles are constructed from their top right corner.
        # passing an iterable to `color` produces a gradient
        rects_right = ax.get_riemann_rectangles(
            quadratic,
            x_range=[-4, -3],
            dx=0.25,
            color=(TEAL, BLUE_B, DARK_BLUE),
            input_sample_type=""right"",
        )

        # the colour of rectangles below the x-axis is inverted
        # due to show_signed_area
        rects_left = ax.get_riemann_rectangles(
            quadratic, x_range=[-1.5, 1.5], dx=0.15, color=YELLOW
        )

        bounding_line = ax.plot(
            lambda x: 1.5 * x, color=BLUE_B, x_range=[3.3, 6]
        )
        bounded_rects = ax.get_riemann_rectangles(
            bounding_line,
            bounded_graph=quadratic,
            dx=0.15,
            x_range=[4, 5],
            show_signed_area=False,
            color=(MAROON_A, RED_B, PURPLE_D),
        )

        self.add(
            ax, bounding_line, quadratic, rects_right, rects_left, bounded_rects
        )",Advanced,train
,"Set the background color to white. Display a red square, then animate it transforming into a slightly rotated red rectangle.","from manim import *

class ExampleTransform(Scene):
    def construct(self):
        self.camera.background_color = WHITE
        m1 = Square().set_color(RED)
        m2 = Rectangle().set_color(RED).rotate(0.2)
        self.play(Transform(m1,m2))",Basic,train
,"Display six lines of styled text arranged vertically, each demonstrating different formatting effects:

1. The first line shows ""Hello world"" entirely in italic.
2. The second line shows ""Hello"" in normal style and ""world"" in italic.
3. The third line displays ""Hello world"" entirely in bold.
4. The fourth line shows ""Hello"" in normal weight and ""world"" in bold.
5. The fifth line highlights all occurrences of the letter ""o"" in yellow, with ligatures disabled to ensure individual character styling.
6. The sixth line reads ""Visit us at docs.manim.community"", with the URL highlighted in yellow and ligatures disabled for precise character rendering. This line is slightly larger and shifted downward.

All lines are centered and evenly spaced to fill the screen vertically.","from manim import *

class TextItalicAndBoldExample(Scene):
    def construct(self):
        text1 = Text(""Hello world"", slant=ITALIC)
        text2 = Text(""Hello world"", t2s={'world':ITALIC})
        text3 = Text(""Hello world"", weight=BOLD)
        text4 = Text(""Hello world"", t2w={'world':BOLD})
        text5 = Text(""Hello world"", t2c={'o':YELLOW}, disable_ligatures=True)
        text6 = Text(
            ""Visit us at docs.manim.community"",
            t2c={""docs.manim.community"": YELLOW},
            disable_ligatures=True,
       )
        text6.scale(1.3).shift(DOWN)
        self.add(text1, text2, text3, text4, text5 , text6)
        Group(*self.mobjects).arrange(DOWN, buff=.8).set(height=config.frame_height-LARGE_BUFF)",Basic,train
,"Display five small grayscale images arranged in a row, each labeled with a different resampling algorithm: ""nearest,"" ""lanczos,"" ""linear,"" ""cubic,"" and ""box."" Each image is a 4×4 pixel grid with increasing brightness along the diagonal, and each one is rendered using its respective interpolation method to demonstrate visual differences.","from manim import *

class ImageInterpolationEx(Scene):
    def construct(self):
        img = ImageMobject(np.uint8([[63, 0, 0, 0],
                                        [0, 127, 0, 0],
                                        [0, 0, 191, 0],
                                        [0, 0, 0, 255]
                                        ]))

        img.height = 2
        img1 = img.copy()
        img2 = img.copy()
        img3 = img.copy()
        img4 = img.copy()
        img5 = img.copy()

        img1.set_resampling_algorithm(RESAMPLING_ALGORITHMS[""nearest""])
        img2.set_resampling_algorithm(RESAMPLING_ALGORITHMS[""lanczos""])
        img3.set_resampling_algorithm(RESAMPLING_ALGORITHMS[""linear""])
        img4.set_resampling_algorithm(RESAMPLING_ALGORITHMS[""cubic""])
        img5.set_resampling_algorithm(RESAMPLING_ALGORITHMS[""box""])
        img1.add(Text(""nearest"").scale(0.5).next_to(img1,UP))
        img2.add(Text(""lanczos"").scale(0.5).next_to(img2,UP))
        img3.add(Text(""linear"").scale(0.5).next_to(img3,UP))
        img4.add(Text(""cubic"").scale(0.5).next_to(img4,UP))
        img5.add(Text(""box"").scale(0.5).next_to(img5,UP))

        x= Group(img1,img2,img3,img4,img5)
        x.arrange()
        self.add(x)",Intermediate,train
,"Display a set of coordinate axes with a purple sine curve representing \( y = \sin(x) \). At \( x = \frac{\pi}{2} \), a dot is placed on the curve, and a label showing \( \frac{\pi}{2} \) appears near the dot, positioned diagonally up and to the right.","from manim import *

class GetGraphLabelExample(Scene):
    def construct(self):
        ax = Axes()
        sin = ax.plot(lambda x: np.sin(x), color=PURPLE_B)
        label = ax.get_graph_label(
            graph=sin,
            label= MathTex(r""\frac{\pi}{2}""),
            x_val=PI / 2,
            dot=True,
            direction=UR,
        )

        self.add(ax, sin, label)",Basic,train
,"Display a dot on the far left side of the screen. It begins moving steadily to the right. After a brief pause, a speed modifier is applied that gradually slows the dot to a complete stop, effectively freezing its motion as the animation progresses.","from manim import *

class SpeedModifierUpdaterExample2(Scene):
    def construct(self):
        a = Dot().shift(LEFT * 4)
        self.add(a)

        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))
        self.wait()
        self.play(
            ChangeSpeed(
                Wait(),
                speedinfo={1: 0},
                affects_speed_updaters=True,
            )
        )",Intermediate,train
"Display a 2×2 table with row and column labels. The first vertical line in the table is colored red, highlighting the leftmost boundary between columns.","Display a 2×2 table with row and column labels. The first vertical line in the table is colored red, highlighting the leftmost boundary between columns (between row headings and cells)","from manim import *

class GetVerticalLinesExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        table.get_vertical_lines()[0].set_color(RED)
        self.add(table)",Basic,train
,"Display a blue ellipse on the left and a red ellipse on the right with the text ""Boolean Operation"" above them. Fade in the group of ellipses and text. Show the green intersection of the ellipses with the label ""Intersection"" above it. Display the orange union of the ellipses with the label ""Union"" above it. Show the yellow exclusion of the ellipses with the label ""Exclusion"" above it. Display the pink difference of the ellipses with the label ""Difference"" above it.","from manim import *

class BooleanOperations(Scene):
    def construct(self):
        ellipse1 = Ellipse(
            width=4.0, height=5.0, fill_opacity=0.5, color=BLUE, stroke_width=10
        ).move_to(LEFT)
        ellipse2 = ellipse1.copy().set_color(color=RED).move_to(RIGHT)
        bool_ops_text = MarkupText(""<u>Boolean Operation</u>"").next_to(ellipse1, UP * 3)
        ellipse_group = Group(bool_ops_text, ellipse1, ellipse2).move_to(LEFT * 3)
        self.play(FadeIn(ellipse_group))

        i = Intersection(ellipse1, ellipse2, color=GREEN, fill_opacity=0.5)
        self.play(i.animate.scale(0.25).move_to(RIGHT * 5 + UP * 2.5))
        intersection_text = Text(""Intersection"", font_size=23).next_to(i, UP)
        self.play(FadeIn(intersection_text))

        u = Union(ellipse1, ellipse2, color=ORANGE, fill_opacity=0.5)
        union_text = Text(""Union"", font_size=23)
        self.play(u.animate.scale(0.3).next_to(i, DOWN, buff=union_text.height * 3))
        union_text.next_to(u, UP)
        self.play(FadeIn(union_text))

        e = Exclusion(ellipse1, ellipse2, color=YELLOW, fill_opacity=0.5)
        exclusion_text = Text(""Exclusion"", font_size=23)
        self.play(e.animate.scale(0.3).next_to(u, DOWN, buff=exclusion_text.height * 3.5))
        exclusion_text.next_to(e, UP)
        self.play(FadeIn(exclusion_text))

        d = Difference(ellipse1, ellipse2, color=PINK, fill_opacity=0.5)
        difference_text = Text(""Difference"", font_size=23)
        self.play(d.animate.scale(0.3).next_to(u, LEFT, buff=difference_text.height * 3.5))
        difference_text.next_to(d, UP)
        self.play(FadeIn(difference_text))",Basic,train
,"Display a 2×2 matrix  
\[
\begin{bmatrix}
\pi & 1 \\
-1 & 3
\end{bmatrix}
\]  
with the first column colored red, the second column colored blue, and the brackets colored green. The matrix appears on screen without animation.","from manim import *

class SetColumnColorsExample(Scene):
    def construct(self):
        m0 = Matrix([[""\\pi"", 1], [-1, 3]],
        ).set_column_colors([RED,BLUE], GREEN)
        self.add(m0)",Basic,train
,"Display a decimal table with two rows:

- The first row shows the values of \( x = [-2, -1, 0, 1, 2] \).
- The second row shows the corresponding values of \( f(x) = e^x \), each rounded to two decimal places.

The rows are labeled with LaTeX-style expressions “\( x \)” and “\( f(x) = e^x \)”, and there is extra horizontal spacing between the columns. The table is centered on the screen.","from manim import *

class DecimalTableExample(Scene):
    def construct(self):
        x_vals = [-2,-1,0,1,2]
        y_vals = np.exp(x_vals)
        t0 = DecimalTable(
            [x_vals, y_vals],
            row_labels=[MathTex(""x""), MathTex(""f(x)=e^{x}"")],
            h_buff=1,
            element_to_mobject_config={""num_decimal_places"": 2})
        self.add(t0)",Basic,train
,"Display a graph with eight labeled nodes arranged in a circular layout. Node 7 is highlighted in red, and three edges connected to it—(1, 7), (2, 7), and (4, 7)—are also colored red to emphasize its connections. The rest of the graph uses default styling, and all nodes are evenly spaced around the circle.","from manim import *

class LabeledModifiedGraph(Scene):
    def construct(self):
        vertices = [1, 2, 3, 4, 5, 6, 7, 8]
        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),
                 (2, 8), (3, 4), (6, 1), (6, 2),
                 (6, 3), (7, 2), (7, 4)]
        g = Graph(vertices, edges, layout=""circular"", layout_scale=3,
                  labels=True, vertex_config={7: {""fill_color"": RED}},
                  edge_config={(1, 7): {""stroke_color"": RED},
                               (2, 7): {""stroke_color"": RED},
                               (4, 7): {""stroke_color"": RED}})
        self.add(g)",Advanced,train
,"Display a semi-transparent, multicolored background rectangle spanning most of the screen. In front of it, show two 2×2 tables side by side: the first has individual background rectangles behind each cell, and the second has a single background rectangle behind the entire table. Both tables are scaled down and arranged with spacing between them.","from manim import *

class BackgroundRectanglesExample(Scene):
    def construct(self):
        background = Rectangle(height=6.5, width=13)
        background.set_fill(opacity=.5)
        background.set_color([TEAL, RED, YELLOW])
        self.add(background)
        t0 = Table(
            [[""This"", ""is a""],
            [""simple"", ""Table.""]],
            add_background_rectangles_to_entries=True)
        t1 = Table(
            [[""This"", ""is a""],
            [""simple"", ""Table.""]],
            include_background_rectangle=True)
        g = Group(t0, t1).scale(0.7).arrange(buff=0.5)
        self.add(g)",Basic,train
,"Display a dot at the origin. Draw a line from (3, 0) to (5, 0). Show a blue circle growing from its center. Transform the dot to a new position to the right. Move the dot along the path of the circle. Rotate the dot around the point (2, 0).","from manim import *

class PointMovingOnShapes(Scene):
    def construct(self):
        circle = Circle(radius=1, color=BLUE)
        dot = Dot()
        dot2 = dot.copy().shift(RIGHT)
        self.add(dot)

        line = Line([3, 0, 0], [5, 0, 0])
        self.add(line)

        self.play(GrowFromCenter(circle))
        self.play(Transform(dot, dot2))
        self.play(MoveAlongPath(dot, circle), run_time=2, rate_func=linear)
        self.play(Rotating(dot, about_point=[2, 0, 0]), run_time=1.5)
        self.wait()",Intermediate,train
"Display a green dot at the center of the screen accompanied by a clicking sound. After a pause, another click is heard as the dot changes to blue. Following another pause and click, the dot changes to red. Each color change is synchronized with a sound effect.","Display a green dot at the center of the screen accompanied by a clicking sound. After a pause, another click is heard as the dot changes to blue. Following another pause and click, the dot changes to red. Each color change is synchronized with a sound effect.

Sound effect source: https://freesound.org/people/Druminfected/sounds/250551/","from manim import *

class SoundExample(Scene):
    # Source of sound under Creative Commons 0 License. https://freesound.org/people/Druminfected/sounds/250551/
    def construct(self):
        dot = Dot().set_color(GREEN)
        self.add_sound(""click.wav"")
        self.add(dot)
        self.wait()
        self.add_sound(""click.wav"")
        dot.set_color(BLUE)
        self.wait()
        self.add_sound(""click.wav"")
        dot.set_color(RED)
        self.wait()",Intermediate,train
,Display a large dot that continuously moves horizontally across the screen from left to right. The dot's position is controlled by a `ValueTracker` that automatically increases over time using an updater. The motion is smooth and continuous during the 2-second wait period.,"from manim import *

class ValueTrackerExample(Scene):
    def construct(self):
        tracker = ValueTracker(0)
        label = Dot(radius=3).add_updater(lambda x : x.set_x(tracker.get_value()))
        self.add(label)
        self.add(tracker)
        tracker.add_updater(lambda mobject, dt: mobject.increment_value(dt))
        self.wait(2)",Basic,train
,"Display the Manim logo banner animation on a light beige background:  
- The banner is drawn on screen using the light theme style.  
- It then expands in size.  
- After a brief pause, the banner is smoothly removed with an unwrite animation.","from manim import *

class LightThemeBanner(Scene):
    def construct(self):
        self.camera.background_color = ""#ece6e2""
        banner = ManimBanner(dark_theme=False)
        self.play(banner.create())
        self.play(banner.expand())
        self.wait()
        self.play(Unwrite(banner))",Basic,train
,"Display a 2×2 table with row and column labels. A red rectangle is drawn around the second column, visually highlighting both cells in that column.","from manim import *

class GetColumnsExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        table.add(SurroundingRectangle(table.get_columns()[1]))
        self.add(table)",Basic,train
,"Display a group of four dots, with the third dot colored red, arranged horizontally and scaled up. Show a yellow dot at the coordinates (4, 3). Move the group of dots so that the red dot aligns with the yellow dot.","from manim import *

class MovingGroupToDestination(Scene):
    def construct(self):
        group = VGroup(Dot(LEFT), Dot(ORIGIN), Dot(RIGHT, color=RED), Dot(2 * RIGHT)).scale(1.4)
        dest = Dot([4, 3, 0], color=YELLOW)
        self.add(group, dest)
        self.play(group.animate.shift(dest.get_center() - group[2].get_center()))
        self.wait(0.5)",Intermediate,train
,"Display a row of four shapes—square, circle, triangle, and star—arranged horizontally. Then, animate them cycling their positions to the right four times, so that each shape moves to the next position in the sequence, creating a rotating effect among the group.","from manim import *

class CyclicReplaceExample(Scene):
    def construct(self):
        group = VGroup(Square(), Circle(), Triangle(), Star())
        group.arrange(RIGHT)
        self.add(group)

        for _ in range(4):
            self.play(CyclicReplace(*group))",Basic,train
,"Display the text ""Hello 你好 \LaTeX"" in large font, using a LaTeX template that supports both Latin and Chinese characters (via the `ctex` package), with the LaTeX logo typeset properly.","from manim import *

class LaTeXTemplateLibrary(Scene):
    def construct(self):
        tex = Tex('Hello 你好 \\LaTeX', tex_template=TexTemplateLibrary.ctex, font_size=144)
        self.add(tex)",Basic,train
,"Display a randomly generated graph with 14 nodes and edges based on the Erdős–Rényi model, arranged using a spring layout. After the graph is created, each node animates to a new position along an elliptical path, forming a smooth arc across the screen. Finally, the entire graph is removed from view.","from manim import *

import networkx as nx

nxgraph = nx.erdos_renyi_graph(14, 0.5)

class ImportNetworkxGraph(Scene):
    def construct(self):
        G = Graph.from_networkx(nxgraph, layout=""spring"", layout_scale=3.5)
        self.play(Create(G))
        self.play(*[G[v].animate.move_to(5*RIGHT*np.cos(ind/7 * PI) +
                                         3*UP*np.sin(ind/7 * PI))
                    for ind, v in enumerate(G.vertices)])
        self.play(Uncreate(G))",Advanced,train
,"Display a 3D icosahedron—a twenty-faced polyhedron—centered in the scene. The camera is set at a 75° vertical angle and a 30° horizontal angle, providing a clear, tilted perspective that highlights the icosahedron’s geometric structure.","from manim import *

class IcosahedronScene(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        obj = Icosahedron()
        self.add(obj)",Basic,train
,"Display a circle at the center of the screen with a square to its left, a dot to its right, and a triangle below it. All four geometric shapes are arranged around the circle and shown simultaneously.","from manim import *

class GeometricShapes(Scene):
    def construct(self):
        d = Dot()
        c = Circle()
        s = Square()
        t = Triangle()
        d.next_to(c, RIGHT)
        s.next_to(c, LEFT)
        t.next_to(c, DOWN)
        self.add(d, c, s, t)",Basic,train
,"Display four styled numbers positioned around the screen:

1. An orange number “2” (rounded from 2.5) scaled up and placed slightly left and near the top.
2. A large number “3” (from 3.14159) with ellipsis, scaled by its own value and placed in the upper right.
3. A gradient-colored number “42” in blue and teal, scaled and placed in the lower right.
4. A yellow number “6” (from 6.28), scaled and positioned in the lower left.

Each number is rendered using the `Integer` class, which rounds the input to the nearest whole number.","from manim import *

class IntegerExample(Scene):
    def construct(self):
        self.add(Integer(number=2.5).set_color(ORANGE).scale(2.5).set_x(-0.5).set_y(0.8))
        self.add(Integer(number=3.14159, show_ellipsis=True).set_x(3).set_y(3.3).scale(3.14159))
        self.add(Integer(number=42).set_x(2.5).set_y(-2.3).set_color_by_gradient(BLUE, TEAL).scale(1.7))
        self.add(Integer(number=6.28).set_x(-1.5).set_y(-2).set_color(YELLOW).scale(1.4))",Intermediate,train
,"Display a dot at the center of the screen. Then, draw a horizontal line along the bottom edge of the frame and label it with the screen's pixel width (default is 1920). Next, draw a vertical line along the left edge of the frame and label it with the screen's pixel height (default is 1080).","from manim import *

class ShowScreenResolution(Scene):
    def construct(self):
        pixel_height = config[""pixel_height""]  #  1080 is default
        pixel_width = config[""pixel_width""]  # 1920 is default
        frame_width = config[""frame_width""]
        frame_height = config[""frame_height""]
        self.add(Dot())
        d1 = Line(frame_width * LEFT / 2, frame_width * RIGHT / 2).to_edge(DOWN)
        self.add(d1)
        self.add(Text(str(pixel_width)).next_to(d1, UP))
        d2 = Line(frame_height * UP / 2, frame_height * DOWN / 2).to_edge(LEFT)
        self.add(d2)
        self.add(Text(str(pixel_height)).next_to(d2, RIGHT))",Basic,train
,"Display a number plane with a grid of horizontal and vertical lines. The grid lines are styled with a teal color, medium thickness, and semi-transparent appearance, creating a visually distinct coordinate background.","from manim import *

class NumberPlaneExample(Scene):
    def construct(self):
        number_plane = NumberPlane(
            background_line_style={
                ""stroke_color"": TEAL,
                ""stroke_width"": 4,
                ""stroke_opacity"": 0.6
            }
        )
        self.add(number_plane)",Basic,train
"Display a hierarchical tree graph starting from a single root node labeled ""ROOT."" From this root, five child nodes branch out, each connected to its own grandchild, which in turn connects to a great-grandchild. The structure forms five vertical chains of four nodes each, all radiating from the central root, and is arranged using a tree layout to clearly show the parent-child relationships.","Display a hierarchical tree graph starting from a single root node. From this root, five child nodes branch out, each connected to its own grandchild, which in turn connects to a great-grandchild. The structure forms five vertical chains of four nodes each, all radiating from the central root, and is arranged using a tree layout to clearly show the parent-child relationships.","from manim import *

import networkx as nx

class Tree(Scene):
    def construct(self):
        G = nx.Graph()

        G.add_node(""ROOT"")

        for i in range(5):
            G.add_node(""Child_%i"" % i)
            G.add_node(""Grandchild_%i"" % i)
            G.add_node(""Greatgrandchild_%i"" % i)

            G.add_edge(""ROOT"", ""Child_%i"" % i)
            G.add_edge(""Child_%i"" % i, ""Grandchild_%i"" % i)
            G.add_edge(""Grandchild_%i"" % i, ""Greatgrandchild_%i"" % i)

        self.play(Create(
            Graph(list(G.nodes), list(G.edges), layout=""tree"", root_vertex=""ROOT"")))",Advanced,train
,"Set the background color to a light beige. Display a large black double-struck ""M"" shifted to the left and up. Show a green circle shifted to the left, a blue square shifted up, and a red triangle shifted to the right. Group these shapes and the ""M"" together, centering the group on the screen.","from manim import *

class ManimCELogo(Scene):
    def construct(self):
        self.camera.background_color = ""#ece6e2""
        logo_green = ""#87c2a5""
        logo_blue = ""#525893""
        logo_red = ""#e07a5f""
        logo_black = ""#343434""
        ds_m = MathTex(r""\mathbb{M}"", fill_color=logo_black).scale(7)
        ds_m.shift(2.25 * LEFT + 1.5 * UP)
        circle = Circle(color=logo_green, fill_opacity=1).shift(LEFT)
        square = Square(color=logo_blue, fill_opacity=1).shift(UP)
        triangle = Triangle(color=logo_red, fill_opacity=1).shift(RIGHT)
        logo = VGroup(triangle, square, circle, ds_m)  # order matters
        logo.move_to(ORIGIN)
        self.add(logo)",Basic,train
,"Display a grey circle with two small green dots: one at the rightmost point labeled ""(2,0)"" in blue, and one at the top labeled ""(0,2)"" in blue. A yellow arc is then drawn between the two dots, curving counterclockwise along the circle’s edge.","from manim import *

class ArcBetweenPointsExample(Scene):
    def construct(self):
        circle = Circle(radius=2, stroke_color=GREY)
        dot_1 = Dot(color=GREEN).move_to([2, 0, 0]).scale(0.5)
        dot_1_text = Tex(""(2,0)"").scale(0.5).next_to(dot_1, RIGHT).set_color(BLUE)
        dot_2 = Dot(color=GREEN).move_to([0, 2, 0]).scale(0.5)
        dot_2_text = Tex(""(0,2)"").scale(0.5).next_to(dot_2, UP).set_color(BLUE)
        arc= ArcBetweenPoints(start=2 * RIGHT, end=2 * UP, stroke_color=YELLOW)
        self.add(circle, dot_1, dot_2, dot_1_text, dot_2_text)
        self.play(Create(arc))",Intermediate,train
,"Display a large mathematical expression showing a script-style ""H"" followed by a right arrow pointing to a double-struck ""H"", using a custom LaTeX package (mathrsfs) to render the script font.","from manim import *

class AddPackageLatex(Scene):
    def construct(self):
        myTemplate = TexTemplate()
        myTemplate.add_to_preamble(r""\usepackage{mathrsfs}"")
        tex = Tex(
            r""$\mathscr{H} \rightarrow \mathbb{H}$"",
            tex_template=myTemplate,
            font_size=144,
        )
        self.add(tex)",Basic,train
,"Display a solid red square on the left and a solid blue circle overlapping it from the top right. On the right side of the screen, show a green shape representing the intersection—only the overlapping area shared by both the square and the circle.","from manim import *

class IntersectionExample(Scene):
    def construct(self):
        sq = Square(color=RED, fill_opacity=1)
        sq.move_to([-2, 0, 0])
        cr = Circle(color=BLUE, fill_opacity=1)
        cr.move_to([-1.3, 0.7, 0])
        un = Intersection(sq, cr, color=GREEN, fill_opacity=1)
        un.move_to([1.5, 0, 0])
        self.add(sq, cr, un)",Basic,train
,"Display a large, semi-transparent background rectangle filled with a gradient of teal, red, and yellow. In front of it, three matrices are arranged horizontally:

- The first matrix has background rectangles behind each individual entry.
- The second matrix has a single background rectangle behind the entire matrix.
- The third matrix has no background rectangles.

All elements appear on screen simultaneously without animation.","from manim import *

class BackgroundRectanglesExample(Scene):
    def construct(self):
        background= Rectangle().scale(3.2)
        background.set_fill(opacity=.5)
        background.set_color([TEAL, RED, YELLOW])
        self.add(background)
        m0 = Matrix([[12, -30], [-1, 15]],
            add_background_rectangles_to_entries=True)
        m1 = Matrix([[2, 0], [-1, 1]],
            include_background_rectangle=True)
        m2 = Matrix([[12, -30], [-1, 15]])
        g = Group(m0, m1, m2).arrange(buff=2)
        self.add(g)",Intermediate,train
,"Display three rows of dashed shapes demonstrating different dash configurations:

- **Top row**: Eleven white circles with increasing numbers of dashes, showing how dash count affects appearance.
- **Middle row**: Eleven white circles with increasing dashed ratios, illustrating how the length of dashes relative to gaps changes.
- **Bottom row**: Two versions of the function \( f(t) = t^5 \), both dashed—one with evenly spaced dashes and the other with stretched segments.

All rows are neatly arranged and centered on the screen.","from manim import *

class DashedVMobjectExample(Scene):
    def construct(self):
        r = 0.5

        top_row = VGroup()  # Increasing num_dashes
        for dashes in range(1, 12):
            circ = DashedVMobject(Circle(radius=r, color=WHITE), num_dashes=dashes)
            top_row.add(circ)

        middle_row = VGroup()  # Increasing dashed_ratio
        for ratio in np.arange(1 / 11, 1, 1 / 11):
            circ = DashedVMobject(
                Circle(radius=r, color=WHITE), dashed_ratio=ratio
            )
            middle_row.add(circ)

        func1 = FunctionGraph(lambda t: t**5,[-1,1],color=WHITE)
        func_even = DashedVMobject(func1,num_dashes=6,equal_lengths=True)
        func_stretched = DashedVMobject(func1, num_dashes=6, equal_lengths=False)
        bottom_row = VGroup(func_even,func_stretched)

        top_row.arrange(buff=0.3)
        middle_row.arrange()
        bottom_row.arrange(buff=1)
        everything = VGroup(top_row, middle_row, bottom_row).arrange(DOWN, buff=1)
        self.add(everything)",Intermediate,train
,"Display a number plane. Show a dot at the origin (0, 0) with the label ""(0, 0)"" below it. Draw an arrow from the origin to the point (2, 2) with the label ""(2, 2)"" next to the arrow's tip.","from manim import *

class VectorArrow(Scene):
    def construct(self):
        dot = Dot(ORIGIN)
        arrow = Arrow(ORIGIN, [2, 2, 0], buff=0)
        numberplane = NumberPlane()
        origin_text = Text('(0, 0)').next_to(dot, DOWN)
        tip_text = Text('(2, 2)').next_to(arrow.get_end(), RIGHT)
        self.add(numberplane, dot, arrow, origin_text, tip_text)",Basic,train
,"Display three horizontal dashed lines across the screen, each demonstrating different dash styles:

1. The top line has long dashes due to an increased dash length.
2. The middle line is a standard dashed line with default settings.
3. The bottom line has very short dashes and longer gaps, resulting from a decreased dashed ratio.","from manim import *

class DashedLineExample(Scene):
    def construct(self):
        # dash_length increased
        dashed_1 = DashedLine(config.left_side, config.right_side, dash_length=2.0).shift(UP*2)
        # normal
        dashed_2 = DashedLine(config.left_side, config.right_side)
        # dashed_ratio decreased
        dashed_3 = DashedLine(config.left_side, config.right_side, dashed_ratio=0.1).shift(DOWN*2)
        self.add(dashed_1, dashed_2, dashed_3)",Basic,train
"Display the x and y axes with labels for \(\pi\), \(2\pi\), \(3\pi\), and \(4\pi\) on the x-axis. Show a unit circle centered at (-4, 0). Move a yellow dot around the circle, drawing a blue line from the origin to the dot and a yellow line from the dot to the sine curve. Draw the sine curve dynamically as the dot moves.","Display the x and y axes with labels for \(\pi\), \(2\pi\), \(3\pi\), and \(4\pi\) on the x-axis. Show a unit circle centered at (-4, 0). Move a yellow dot around the circle, with a blue line connecting the origin to the dot and a yellow line from the dot to the sine curve which is drawn dynamically on the plane as the dot moves around the circle.","from manim import *

class SineCurveUnitCircle(Scene):
    # contributed by heejin_park, https://infograph.tistory.com/230
    def construct(self):
        self.show_axis()
        self.show_circle()
        self.move_dot_and_draw_curve()
        self.wait()

    def show_axis(self):
        x_start = np.array([-6,0,0])
        x_end = np.array([6,0,0])

        y_start = np.array([-4,-2,0])
        y_end = np.array([-4,2,0])

        x_axis = Line(x_start, x_end)
        y_axis = Line(y_start, y_end)

        self.add(x_axis, y_axis)
        self.add_x_labels()

        self.origin_point = np.array([-4,0,0])
        self.curve_start = np.array([-3,0,0])

    def add_x_labels(self):
        x_labels = [
            MathTex(r""\pi""), MathTex(r""2 \pi""),
            MathTex(r""3 \pi""), MathTex(r""4 \pi""),
        ]

        for i in range(len(x_labels)):
            x_labels[i].next_to(np.array([-1 + 2*i, 0, 0]), DOWN)
            self.add(x_labels[i])

    def show_circle(self):
        circle = Circle(radius=1)
        circle.move_to(self.origin_point)
        self.add(circle)
        self.circle = circle

    def move_dot_and_draw_curve(self):
        orbit = self.circle
        origin_point = self.origin_point

        dot = Dot(radius=0.08, color=YELLOW)
        dot.move_to(orbit.point_from_proportion(0))
        self.t_offset = 0
        rate = 0.25

        def go_around_circle(mob, dt):
            self.t_offset += (dt * rate)
            # print(self.t_offset)
            mob.move_to(orbit.point_from_proportion(self.t_offset % 1))

        def get_line_to_circle():
            return Line(origin_point, dot.get_center(), color=BLUE)

        def get_line_to_curve():
            x = self.curve_start[0] + self.t_offset * 4
            y = dot.get_center()[1]
            return Line(dot.get_center(), np.array([x,y,0]), color=YELLOW_A, stroke_width=2 )


        self.curve = VGroup()
        self.curve.add(Line(self.curve_start,self.curve_start))
        def get_curve():
            last_line = self.curve[-1]
            x = self.curve_start[0] + self.t_offset * 4
            y = dot.get_center()[1]
            new_line = Line(last_line.get_end(),np.array([x,y,0]), color=YELLOW_D)
            self.curve.add(new_line)

            return self.curve

        dot.add_updater(go_around_circle)

        origin_to_circle_line = always_redraw(get_line_to_circle)
        dot_to_curve_line = always_redraw(get_line_to_curve)
        sine_curve_line = always_redraw(get_curve)

        self.add(dot)
        self.add(orbit, origin_to_circle_line, dot_to_curve_line, sine_curve_line)
        self.wait(8.5)

        dot.remove_updater(go_around_circle)",Advanced,train
,"Display a 3D cylinder with a radius of 2 units and a height of 3 units, centered in the scene. The cylinder is placed within a 3D coordinate system for spatial reference. The camera is set at a 75° vertical angle and a 30° horizontal angle, providing a tilted view that clearly shows the cylindrical shape and its proportions.","from manim import *

class ExampleCylinder(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        cylinder = Cylinder(radius=2, height=3)
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        self.add(axes, cylinder)",Basic,train
,"Display two pairs of dots and squares: one pair on the left side of the screen and the other on the right. After a brief pause, the left dot transforms into a square with a clockwise spinning motion, while the right dot transforms into a square with a standard morphing animation. Both transformations occur simultaneously.","from manim import *

class ClockwiseExample(Scene):
    def construct(self):
        dl, dr = Dot(), Dot()
        sl, sr = Square(), Square()

        VGroup(dl, sl).arrange(DOWN).shift(2*LEFT)
        VGroup(dr, sr).arrange(DOWN).shift(2*RIGHT)

        self.add(dl, dr)
        self.wait()
        self.play(
            ClockwiseTransform(dl, sl),
            Transform(dr, sr)
        )
        self.wait()",Intermediate,train
,"Display a set of coordinate axes with labeled ticks, then place a dot at the point \((-4, 1.5)\). A horizontal line extends from this point across the graph, visually marking the y-value of the dot.","from manim import *

class GetHorizontalLineExample(Scene):
    def construct(self):
        ax = Axes().add_coordinates()
        point = ax @ (-4, 1.5)

        dot = Dot(point)
        line = ax.get_horizontal_line(point, line_func=Line)

        self.add(ax, line, dot)",Basic,train
,"Display the text “Changing default values is easy!” in black on a white background. The text uses a modified default color setting for `Text` objects, which is temporarily changed to black for this scene and then reset to white afterward.","from manim import *

config.background_color = WHITE

class ChangedDefaultTextcolor(Scene):
    def construct(self):
        Text.set_default(color=BLACK)
        self.add(Text(""Changing default values is easy!""))

        # we revert the colour back to the default to prevent a bug in the docs.
        Text.set_default(color=WHITE)",Basic,train
,"Display two polygons:

1. An isosceles triangle on the left side of the screen, with its base at the top and the vertex pointing downward.
2. A complex six-pointed polygon on the right side, outlined in purple, formed by connecting six specified points that create a shape resembling a square with additional triangular extensions.","from manim import *

class PolygonExample(Scene):
    def construct(self):
        isosceles = Polygon([-5, 1.5, 0], [-2, 1.5, 0], [-3.5, -2, 0])
        position_list = [
            [4, 1, 0],  # middle right
            [4, -2.5, 0],  # bottom right
            [0, -2.5, 0],  # bottom left
            [0, 3, 0],  # top left
            [2, 1, 0],  # middle
            [4, 3, 0],  # top right
        ]
        square_and_triangles = Polygon(*position_list, color=PURPLE_B)
        self.add(isosceles, square_and_triangles)",Intermediate,train
,"Display a dot, a square, and a triangle grouped together on screen. Then animate them appearing one by one in order, gradually revealing the full group.","from manim import *

class ShowIncreasingSubsetsScene(Scene):
    def construct(self):
        p = VGroup(Dot(), Square(), Triangle())
        self.add(p)
        self.play(ShowIncreasingSubsets(p))
        self.wait()",Basic,test
,"Display eight diagrams arranged in a 2×4 grid, each showing two diagonal lines intersecting at various angles. Each diagram highlights a different angle between the lines using a curved arc, with variations in radius, quadrant placement, stroke width, color, and whether the smaller or larger angle is shown. Each diagram is enclosed in a light rectangular frame for clarity.","from manim import *

class AngleExample(Scene):
    def construct(self):
        line1 = Line( LEFT + (1/3) * UP, RIGHT + (1/3) * DOWN )
        line2 = Line( DOWN + (1/3) * RIGHT, UP + (1/3) * LEFT )
        angles = [
            Angle(line1, line2),
            Angle(line1, line2, radius=0.4, quadrant=(1,-1), other_angle=True),
            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, other_angle=True),
            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED),
            Angle(line1, line2, other_angle=True),
            Angle(line1, line2, radius=0.4, quadrant=(1,-1)),
            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8),
            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, other_angle=True),
        ]
        plots = VGroup()
        for angle in angles:
            plot=VGroup(line1.copy(),line2.copy(), angle)
            plots.add(VGroup(plot,SurroundingRectangle(plot, buff=0.3)))
        plots.arrange_in_grid(rows=2,buff=1)
        self.add(plots)",Intermediate,test
,"Display the text “Alice and Bob” in large font on the screen, then animate it being erased in the original writing order, as if unwriting it from start to end.","from manim import *

class UnwriteReverseFalse(Scene):
    def construct(self):
        text = Tex(""Alice and Bob"").scale(3)
        self.add(text)
        self.play(Unwrite(text, reverse=False))",Basic,test
"Display a 2×2 table with row and column labels. A rectangle is drawn around the first row, visually highlighting both cells in that row.","Display a 2×2 table with row and column labels. A rectangle is drawn around the first row, visually highlighting both cells in that row, including the row heading.","from manim import *

class GetRowsExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        table.add(SurroundingRectangle(table.get_rows()[1]))
        self.add(table)",Basic,test
,"Display a 3D dodecahedron—a twelve-faced polyhedron—centered in the scene. The camera is angled at 75° vertically and 30° horizontally to provide a clear, tilted view of the shape, showcasing its three-dimensional structure.","from manim import *

class DodecahedronScene(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        obj = Dodecahedron()
        self.add(obj)",Basic,test
,"Display a circle on the screen. Then animate a red flash effect radiating outward from the circle with 30 lines, a slightly larger flash radius than the circle, and a quick burst animation that lasts 2 seconds using a fast-start easing function.","from manim import *

class FlashOnCircle(Scene):
    def construct(self):
        radius = 2
        circle = Circle(radius)
        self.add(circle)
        self.play(Flash(
            circle, line_length=1,
            num_lines=30, color=RED,
            flash_radius=radius+SMALL_BUFF,
            time_width=0.3, run_time=2,
            rate_func = rush_from
        ))",Basic,test
,"Display a dot on the far left side of the screen. It begins moving smoothly to the right, but its speed varies over time: it starts at normal speed, slows down significantly during the middle portion of the animation, then returns to normal speed. This speed variation is controlled by a modifier that affects the dot's motion continuously throughout the animation.","from manim import *

class SpeedModifierUpdaterExample(Scene):
    def construct(self):
        a = Dot().shift(LEFT * 4)
        self.add(a)

        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))
        self.play(
            ChangeSpeed(
                Wait(2),
                speedinfo={0.4: 1, 0.5: 0.2, 0.8: 0.2, 1: 1},
                affects_speed_updaters=True,
            )
        )",Intermediate,test
,"Display three point cloud dots arranged horizontally. The first is red with default styling, the second is larger with a thicker outline, and the third has a lower point density, making it appear more sparse. All three are shown together as a grouped visual comparison.","from manim import *

class PointCloudDotExample(Scene):
    def construct(self):
        cloud_1 = PointCloudDot(color=RED)
        cloud_2 = PointCloudDot(stroke_width=4, radius=1)
        cloud_3 = PointCloudDot(density=15)

        group = Group(cloud_1, cloud_2, cloud_3).arrange()
        self.add(group)",Basic,test
,"Set the background color of the scene to white using two equivalent configuration methods: one by directly assigning to config.background_color, and the other by using dictionary-style access with config[""background_color""].","from manim import *
config.background_color = WHITE
config[""background_color""] = WHITE",Basic,test
,"Display a coordinate system with labeled axes and grid lines. A green dot is placed at the point (2, 2) relative to the axes, with dashed guide lines extending from the axes to the dot. A red dot is also placed at the same (2, 2) location, but relative to the scene's default coordinate system. This illustrates the difference between placing objects using axis-based coordinates versus scene-based coordinates.","from manim import *

class CoordsToPointExample(Scene):
    def construct(self):
        ax = Axes().add_coordinates()

        # a dot with respect to the axes
        dot_axes = Dot(ax.coords_to_point(2, 2), color=GREEN)
        lines = ax.get_lines_to_point(ax.c2p(2,2))

        # a dot with respect to the scene
        # the default plane corresponds to the coordinates of the scene.
        plane = NumberPlane()
        dot_scene = Dot((2,2,0), color=RED)

        self.add(plane, dot_scene, ax, dot_axes, lines)",Intermediate,test
,"Display a dot positioned at the upper left. Then animate the text “FadeIn with shift or target_position and scale” appearing in four parts: the first part fades in normally, the second fades in while shifting upward, the third fades in while moving toward the dot, and the fourth fades in while scaling up. Each part appears with a delay between them.
","from manim import *

class FadeInExample(Scene):
    def construct(self):
        dot = Dot(UP * 2 + LEFT)
        self.add(dot)
        tex = Tex(
            ""FadeIn with "", ""shift "", r"" or target\_position"", "" and scale""
        ).scale(1)
        animations = [
            FadeIn(tex[0]),
            FadeIn(tex[1], shift=DOWN),
            FadeIn(tex[2], target_position=dot),
            FadeIn(tex[3], scale=1.5),
        ]
        self.play(AnimationGroup(*animations, lag_ratio=0.5))",Basic,test
"Display a vertical sequence of annotation elements centered on screen: a plain dot, a dot with an annotation ring, a dot labeled ""ii"", a dot labeled with an orange Greek letter alpha, a large left-to-right curved arrow bending downward, a left-to-right curved arrow bending upward, and a double-headed curved arrow pointing right. Each element is evenly spaced vertically.","Display a vertical sequence of annotation elements centered on screen: 

- A plain dot
- A dot with an annotation ring
- A dot labeled ""ii""
- A dot labeled with an orange Greek letter alpha
- A large left-to-right curved arrow bending downward
- A left-to-right curved arrow bending upward
- Lastly, a double-headed curved arrow pointing right.

Each of the above element is evenly spaced vertically.","from manim import *

class UsefulAnnotations(Scene):
    def construct(self):
        m0 = Dot()
        m1 = AnnotationDot()
        m2 = LabeledDot(""ii"")
        m3 = LabeledDot(MathTex(r""\alpha"").set_color(ORANGE))
        m4 = CurvedArrow(2*LEFT, 2*RIGHT, radius= -5)
        m5 = CurvedArrow(2*LEFT, 2*RIGHT, radius= 8)
        m6 = CurvedDoubleArrow(ORIGIN, 2*RIGHT)

        self.add(m0, m1, m2, m3, m4, m5, m6)
        for i, mobj in enumerate(self.mobjects):
            mobj.shift(DOWN * (i-3))",Basic,test
,"Display two ellipses arranged horizontally: a tall blue ellipse on the left and a wide dark blue ellipse on the right, with space between them.","from manim import *

class EllipseExample(Scene):
    def construct(self):
        ellipse_1 = Ellipse(width=2.0, height=4.0, color=BLUE_B)
        ellipse_2 = Ellipse(width=4.0, height=1.0, color=BLUE_D)
        ellipse_group = Group(ellipse_1,ellipse_2).arrange(buff=1)
        self.add(ellipse_group)",Basic,test
,Display a 3D scene with a coordinate axis system and a torus (doughnut-shaped surface) centered in the scene. The camera is angled from above and slightly to the side to provide a clear view of the torus's circular structure.,"from manim import *

class ExampleTorus(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        torus = Torus()
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        self.add(axes, torus)",Basic,test
,"Display the word “Hello” in large text on the screen, animating it being written out in reverse order, from the last letter to the first, while keeping the text visible after the animation completes.","from manim import *

class ShowWriteReversed(Scene):
    def construct(self):
        self.play(Write(Text(""Hello"", font_size=144), reverse=True, remover=False))",Basic,test
,"Display a group of concentric circles, each with increasing radius and a different color from dark brown through various shades of blue, teal, green, and yellow. The circles are centered on the screen, creating a layered, iris-like visual effect.","from manim import *

class ArcShapeIris(Scene):
    def construct(self):
        colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]
        radius = [1 + rad * 0.1 for rad in range(len(colors))]

        circles_group = VGroup()

        # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]
        circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)
                            for rad, col in zip(radius, colors)])
        self.add(circles_group)",Intermediate,test
,"Display two groups of shapes: on the upper left, a square and a circle shifted diagonally; on the upper right, a circle and a triangle also shifted diagonally. Below each group is a copy of the same arrangement.

First, both upper groups fade in. Then:

- The upper left group transforms into the upper right group using a smooth fade transition.
- The lower left group transforms into the lower right group using a piecewise fade, where each individual shape fades and morphs into its corresponding target.

Finally, all shapes fade out together.","from manim import *

class FadeTransformSubmobjects(Scene):
    def construct(self):
        src = VGroup(Square(), Circle().shift(LEFT + UP))
        src.shift(3*LEFT + 2*UP)
        src_copy = src.copy().shift(4*DOWN)

        target = VGroup(Circle(), Triangle().shift(RIGHT + DOWN))
        target.shift(3*RIGHT + 2*UP)
        target_copy = target.copy().shift(4*DOWN)

        self.play(FadeIn(src), FadeIn(src_copy))
        self.play(
            FadeTransform(src, target),
            FadeTransformPieces(src_copy, target_copy)
        )
        self.play(*[FadeOut(mobj) for mobj in self.mobjects])",Intermediate,test
,Display the text “Flash the dot below:” at the top of the screen with a yellow dot positioned below it. Then animate a flashing effect around the dot to draw attention to it.,"from manim import *

class UsingFlash(Scene):
    def construct(self):
        dot = Dot(color=YELLOW).shift(DOWN)
        self.add(Tex(""Flash the dot below:""), dot)
        self.play(Flash(dot))
        self.wait()",Basic,test
,"Display a 3D scene with the camera angled from above and to the side. Show a small rectangular prism rotated onto its side, and a larger rectangular prism positioned to its right. Both prisms are static and appear simultaneously in the scene.","from manim import *

class ExamplePrism(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=60 * DEGREES, theta=150 * DEGREES)
        prismSmall = Prism(dimensions=[1, 2, 3]).rotate(PI / 2)
        prismLarge = Prism(dimensions=[1.5, 3, 4.5]).move_to([2, 0, 0])
        self.add(prismSmall, prismLarge)",Basic,test
,"Display a yellow curve representing the implicit function defined by the equation \( x y^2 - x^2 y - 2 = 0 \), overlaid on a coordinate grid. The graph and the number plane appear together without animation.","from manim import *

class ImplicitFunctionExample(Scene):
    def construct(self):
        graph = ImplicitFunction(
            lambda x, y: x * y ** 2 - x ** 2 * y - 2,
            color=YELLOW
        )
        self.add(NumberPlane(), graph)",Intermediate,test
,"Display a large teal circle centered on the screen, then animate a radiating ripple effect that emanates outward from the circle, creating the impression of a broadcast or signal being sent from its center.","from manim import *

class BroadcastExample(Scene):
    def construct(self):
        mob = Circle(radius=4, color=TEAL_A)
        self.play(Broadcast(mob))",Basic,test
,"Display three squares arranged in a row. Animate the first square spinning into view from nothing with a default rotation. Then animate the second square spinning in with a full 360-degree rotation. Finally, animate the third square spinning into view with its center point highlighted in red.","from manim import *

class SpinInFromNothingExample(Scene):
    def construct(self):
        squares = [Square() for _ in range(3)]
        VGroup(*squares).set_x(0).arrange(buff=2)
        self.play(SpinInFromNothing(squares[0]))
        self.play(SpinInFromNothing(squares[1], angle=2 * PI))
        self.play(SpinInFromNothing(squares[2], point_color=RED))",Basic,test
,"Display two on-screen variables: one labeled “x” and the other “x²”, both showing values with three decimal places. Initially, “x” is set to 2.0 and “x²” to 4.0. As “x” animates smoothly to 5.0 over two seconds, “x²” updates in real time to reflect the square of “x”, maintaining a dynamic link between the two values.","from manim import *

class VariableExample(Scene):
    def construct(self):
        start = 2.0

        x_var = Variable(start, 'x', num_decimal_places=3)
        sqr_var = Variable(start**2, 'x^2', num_decimal_places=3)
        Group(x_var, sqr_var).arrange(DOWN)

        sqr_var.add_updater(lambda v: v.tracker.set_value(x_var.tracker.get_value()**2))

        self.add(x_var, sqr_var)
        self.play(x_var.tracker.animate.set_value(5), run_time=2, rate_func=linear)
        self.wait(0.1)",Intermediate,test
,"Display a coordinate grid using a number plane. Then, create a brace between two points: one at the origin and the other at position (1, 2). The brace appears connecting these two points diagonally, and the scene pauses for two seconds to show the result.","from manim import *

class BraceBPExample(Scene):
    def construct(self):
        p1 = [0,0,0]
        p2 = [1,2,0]
        brace = BraceBetweenPoints(p1,p2)
        self.play(Create(NumberPlane()))
        self.play(Create(brace))
        self.wait(2)",Basic,test
,"Display six different matrix styles arranged in a grid:

- The first is a 2×2 matrix with elements including the symbol \( \pi \), enclosed in square brackets.
- The second is a 2×3 matrix with custom spacing and curly braces as brackets. The second column is highlighted with a surrounding rectangle.
- The third is a 2×2 matrix with elements aligned to the upper-left corner, enclosed in parentheses.
- The fourth is a 2×2 matrix enclosed in angle brackets.
- The fifth is a 2×2 matrix with each column colored differently (red and green).
- The sixth is a 2×2 matrix with each row colored differently (red and green).

All matrices appear on screen simultaneously without animation.","from manim import *

class MatrixExamples(Scene):
    def construct(self):
        m0 = Matrix([[2, r""\pi""], [-1, 1]])
        m1 = Matrix([[2, 0, 4], [-1, 1, 5]],
            v_buff=1.3,
            h_buff=0.8,
            bracket_h_buff=SMALL_BUFF,
            bracket_v_buff=SMALL_BUFF,
            left_bracket=r""\{"",
            right_bracket=r""\}"")
        m1.add(SurroundingRectangle(m1.get_columns()[1]))
        m2 = Matrix([[2, 1], [-1, 3]],
            element_alignment_corner=UL,
            left_bracket=""("",
            right_bracket="")"")
        m3 = Matrix([[2, 1], [-1, 3]],
            left_bracket=r""\langle"",
            right_bracket=r""\rangle"")
        m4 = Matrix([[2, 1], [-1, 3]],
        ).set_column_colors(RED, GREEN)
        m5 = Matrix([[2, 1], [-1, 3]],
        ).set_row_colors(RED, GREEN)
        g = Group(
            m0,m1,m2,m3,m4,m5
        ).arrange_in_grid(buff=2)
        self.add(g)",Intermediate,test
,"Display the binomial coefficient \( \binom{2n}{n+2} \) in large font. Index labels are added to each character in the expression for reference. The characters ""2n"" in the numerator are colored yellow, and ""n+2"" in the denominator are colored red.","from manim import *

class IndexLabelsMathTex(Scene):
    def construct(self):
        text = MathTex(r""\binom{2n}{n+2}"", font_size=96)

        # index the first (and only) term of the MathTex mob
        self.add(index_labels(text[0]))

        text[0][1:3].set_color(YELLOW)
        text[0][3:6].set_color(RED)
        self.add(text)",Basic,test
,"Display a circle containing the text “hello!” centered inside it. The circle and text are drawn together. Then, the text is smoothly removed using an animation, leaving only the circle visible. Afterward, the scene pauses briefly.","from manim import *

class CircleWithContent(VGroup):
    def __init__(self, content):
        super().__init__()
        self.circle = Circle()
        self.content = content
        self.add(self.circle, content)
        content.move_to(self.circle.get_center())

    def clear_content(self):
        self.remove(self.content)
        self.content = None

    @override_animate(clear_content)
    def _clear_content_animation(self, anim_args=None):
        if anim_args is None:
            anim_args = {}
        anim = Uncreate(self.content, **anim_args)
        self.clear_content()
        return anim

class AnimationOverrideExample(Scene):
    def construct(self):
        t = Text(""hello!"")
        my_mobject = CircleWithContent(t)
        self.play(Create(my_mobject))
        self.play(my_mobject.animate.clear_content())
        self.wait()",Intermediate,test
,"Display a 2×2 table with row and column labels. Each of the four cell entries is colored differently—blue, green, yellow, and red. The bottom-right cell is also rotated upside down, while the labels remain unchanged.","from manim import *

class GetEntriesWithoutLabelsExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        ent = table.get_entries_without_labels()
        colors = [BLUE, GREEN, YELLOW, RED]
        for k in range(len(colors)):
            ent[k].set_color(colors[k])
        table.get_entries_without_labels((2,2)).rotate(PI)
        self.add(table)",Basic,test
,"Display two angles formed at the origin: one standard angle between the upward and leftward directions, and a larger red angle with a thicker stroke between the diagonal upper-left and rightward directions, drawn in the opposite (reflex) direction.","from manim import *

class AngleFromThreePointsExample(Scene):
    def construct(self):
        sample_angle = Angle.from_three_points(UP, ORIGIN, LEFT)
        red_angle = Angle.from_three_points(LEFT + UP, ORIGIN, RIGHT, radius=.8, quadrant=(-1,-1), color=RED, stroke_width=8, other_angle=True)
        self.add(red_angle, sample_angle)",Intermediate,test
,"Display five lines of styled text arranged vertically:

1. The first line shows the word ""bla"" with a green double underline.
2. The second line displays ""xxx"" with a green single underline, followed by ""aabb"" in a yellow-to-red gradient, and ending with ""y"".
3. The third line is similar to the second, but the gradient on ""aabb"" is offset slightly to the left, altering the color transition.
4. The fourth line shows ""xxx"" with a green double underline, followed by ""aabb"" in a yellow-to-red gradient, and ending with ""y"".
5. The fifth line is like the fourth, but the gradient on ""aabb"" is offset further to the left, shifting the gradient effect more noticeably.

All lines are centered and stacked vertically on the screen.","from manim import *

class UnderlineExample(Scene):
    def construct(self):
        text1 = MarkupText(
            '<span underline=""double"" underline_color=""green"">bla</span>'
        )
        text2 = MarkupText(
            '<span underline=""single"" underline_color=""green"">xxx</span><gradient from=""#ffff00"" to=""RED"">aabb</gradient>y'
        )
        text3 = MarkupText(
            '<span underline=""single"" underline_color=""green"">xxx</span><gradient from=""#ffff00"" to=""RED"" offset=""-1"">aabb</gradient>y'
        )
        text4 = MarkupText(
            '<span underline=""double"" underline_color=""green"">xxx</span><gradient from=""#ffff00"" to=""RED"">aabb</gradient>y'
        )
        text5 = MarkupText(
            '<span underline=""double"" underline_color=""green"">xxx</span><gradient from=""#ffff00"" to=""RED"" offset=""-2"">aabb</gradient>y'
        )
        group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)
        self.add(group)",Intermediate,test
,"Display a graph with six labeled nodes arranged in a circular layout. The nodes are connected by a combination of sequential and cross-linking edges, forming a loop with additional diagonal connections between non-adjacent nodes. This creates a visually dense and interconnected circular network.","from manim import *

class CircularLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout=""circular"",
            labels=True
        )
        self.add(graph)",Intermediate,test
,"Display a 2×2 table with row and column labels. All horizontal lines in the table, including those separating rows and labels, are colored red to visually emphasize the row divisions.","from manim import *

class GetHorizontalLinesExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        table.get_horizontal_lines().set_color(RED)
        self.add(table)",Basic,test
,"Display a coordinate grid with a red sine curve plotted across it. A blue dot moves smoothly along the curve from left to right, while a yellow tangent line dynamically updates to stay tangent to the curve at the dot’s position. The animation visually demonstrates how the tangent line changes as it follows the sine wave.","from manim import *

class TangentAnimation(Scene):
    def construct(self):
        ax = Axes()
        sine = ax.plot(np.sin, color=RED)
        alpha = ValueTracker(0)
        point = always_redraw(
            lambda: Dot(
                sine.point_from_proportion(alpha.get_value()),
                color=BLUE
            )
        )
        tangent = always_redraw(
            lambda: TangentLine(
                sine,
                alpha=alpha.get_value(),
                color=YELLOW,
                length=4
            )
        )
        self.add(ax, sine, point, tangent)
        self.play(alpha.animate.set_value(1), rate_func=linear, run_time=2)",Advanced,test
,"Display a 2×2 table with row and column labels. The bottom-right cell is highlighted in green to draw attention, while the rest of the table remains unhighlighted.","from manim import *

class AddHighlightedCellExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        table.add_highlighted_cell((2,2), color=GREEN)
        self.add(table)",Basic,test
,"Display a bar chart with 11 bars representing values from -10 to 10 in increments of 2. After the chart appears, the bar values are updated to show the reversed sequence (from 10 down to -10). Each bar is labeled with its new value. The chart and updated labels appear without animation.","from manim import *

class ChangeBarValuesExample(Scene):
    def construct(self):
        values=[-10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10]

        chart = BarChart(
            values,
            y_range=[-10, 10, 2],
            y_axis_config={""font_size"": 24},
        )
        self.add(chart)

        chart.change_bar_values(list(reversed(values)))
        self.add(chart.get_bar_labels(font_size=24))",Intermediate,test
,Display a 3D coordinate system with labeled axes. The z-axis is labeled with the text “\( z \)-label” using LaTeX formatting. The camera is set at an angled perspective to clearly show the 3D structure and the position of the z-axis label in space.,"from manim import *

class GetZAxisLabelExample(ThreeDScene):
    def construct(self):
        ax = ThreeDAxes()
        lab = ax.get_z_axis_label(Tex(""$z$-label""))
        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)
        self.add(ax, lab)",Basic,test
,"Display a dense scatter of 400 small colored points randomly distributed across the screen. The points are placed in two overlapping patterns, each using different scaling factors for their grid-like placement. Each point is randomly colored red, green, blue, or yellow, creating a vibrant, speckled visual effect.","from manim import *

class ExamplePoint(Scene):
    def construct(self):
        colorList = [RED, GREEN, BLUE, YELLOW]
        for i in range(200):
            point = Point(location=[0.63 * np.random.randint(-4, 4), 0.37 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))
            self.add(point)
        for i in range(200):
            point = Point(location=[0.37 * np.random.randint(-4, 4), 0.63 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))
            self.add(point)
        self.add(point)",Basic,test
,"Display a 2×2 matrix  
\[
\begin{bmatrix}
2 & 0 \\
-1 & 1
\end{bmatrix}
\]  
followed by a determinant expression showing that its determinant is 3. Both the matrix and the determinant text appear on screen simultaneously without animation.","from manim import *

class DeterminantOfAMatrix(Scene):
    def construct(self):
        matrix = Matrix([
            [2, 0],
            [-1, 1]
        ])

        # scaling down the `det` string
        det = get_det_text(matrix,
                    determinant=3,
                    initial_scale_factor=1)

        # must add the matrix
        self.add(matrix)
        self.add(det)",Basic,test
,"Display a 2×2 table with row and column labels. The column labels “C1” and “C2” are each assigned a randomly chosen bright color, making them visually distinct from the rest of the table.","from manim import *

class GetColLabelsExample(Scene):
    def construct(self):
        table = Table(
            [[""First"", ""Second""],
            [""Third"",""Fourth""]],
            row_labels=[Text(""R1""), Text(""R2"")],
            col_labels=[Text(""C1""), Text(""C2"")])
        lab = table.get_col_labels()
        for item in lab:
            item.set_color(random_bright_color())
        self.add(table)",Basic,test
,"Display a 3D scene with a coordinate axis system and a curved surface resembling a twisted, vertically stretched ring. The surface is generated using a parametric function and appears in the center of the scene, with the camera angled from above and to the side to highlight its shape.","from manim import *

class ParaSurface(ThreeDScene):
    def func(self, u, v):
        return np.array([np.cos(u) * np.cos(v), np.cos(u) * np.sin(v), u])

    def construct(self):
        axes = ThreeDAxes(x_range=[-4,4], x_length=8)
        surface = Surface(
            lambda u, v: axes.c2p(*self.func(u, v)),
            u_range=[-PI, PI],
            v_range=[0, TAU],
            resolution=8,
        )
        self.set_camera_orientation(theta=70 * DEGREES, phi=75 * DEGREES)
        self.add(axes, surface)",Basic,test
,"Display three coordinate axes arranged in a triangular layout: one in the upper left, one in the upper right, and one along the bottom. Each axis shows a plot of the logarithmic function \( y = \log(x) \), but with different rendering styles:

- The top-left graph shows a smooth red curve with default interpolation.
- The top-right graph displays a choppy orange curve due to disabled smoothing.
- The bottom graph presents a highly detailed green curve using a very fine step size for better accuracy.

This scene visually compares the effects of interpolation and sampling density on graph quality.","from manim import *

class PlotExample(Scene):
    def construct(self):
        # construct the axes
        ax_1 = Axes(
            x_range=[0.001, 6],
            y_range=[-8, 2],
            x_length=5,
            y_length=3,
            tips=False,
        )
        ax_2 = ax_1.copy()
        ax_3 = ax_1.copy()

        # position the axes
        ax_1.to_corner(UL)
        ax_2.to_corner(UR)
        ax_3.to_edge(DOWN)
        axes = VGroup(ax_1, ax_2, ax_3)

        # create the logarithmic curves
        def log_func(x):
            return np.log(x)

        # a curve without adjustments; poor interpolation.
        curve_1 = ax_1.plot(log_func, color=PURE_RED)

        # disabling interpolation makes the graph look choppy as not enough
        # inputs are available
        curve_2 = ax_2.plot(log_func, use_smoothing=False, color=ORANGE)

        # taking more inputs of the curve by specifying a step for the
        # x_range yields expected results, but increases rendering time.
        curve_3 = ax_3.plot(
            log_func, x_range=(0.001, 6, 0.001), color=PURE_GREEN
        )

        curves = VGroup(curve_1, curve_2, curve_3)

        self.add(axes, curves)",Intermediate,test
,"Display a square at the center of the screen, then animate it being warped by a complex exponential transformation. The square stretches and curves dramatically, creating a visually striking distortion that maps each point of the square through the exponential function in the complex plane.","from manim import *

class WarpSquare(Scene):
    def construct(self):
        square = Square()
        self.play(
            ApplyPointwiseFunction(
                lambda point: complex_to_R3(np.exp(R3_to_complex(point))), square
            )
        )
        self.wait()",Advanced,test
,"Display the phrase ""fl ligature"" twice in large font, stacked vertically with some spacing. The top version uses a typographic ligature for ""fl"", while the bottom version disables ligatures, showing the ""f"" and ""l"" as separate characters.","from manim import *

class DisableLigature(Scene):
    def construct(self):
        li = Text(""fl ligature"",font_size=96)
        nli = Text(""fl ligature"", disable_ligatures=True, font_size=96)
        self.add(Group(li, nli).arrange(DOWN, buff=.8))",Basic,test
,"Display a grid of 35 dots arranged in 5 rows and 7 columns, with a title ""LaggedStartMap"" at the top. A yellow ripple effect animates across the dots and the title, where each element briefly changes to yellow and then returns to its original color. The effect is staggered with a lag ratio of 0.1, creating a wave-like motion.","from manim import *

class LaggedStartMapExample(Scene):
    def construct(self):
        title = Tex(""LaggedStartMap"").to_edge(UP, buff=LARGE_BUFF)
        dots = VGroup(
            *[Dot(radius=0.16) for _ in range(35)]
            ).arrange_in_grid(rows=5, cols=7, buff=MED_LARGE_BUFF)
        self.add(dots, title)

        # Animate yellow ripple effect
        for mob in dots, title:
            self.play(LaggedStartMap(
                ApplyMethod, mob,
                lambda m : (m.set_color, YELLOW),
                lag_ratio = 0.1,
                rate_func = there_and_back,
                run_time = 2
            ))",Intermediate,test
,"Display a complex plane with labeled coordinates, then show two yellow dots: one at the position representing \(2 + i\) and another at \(-3 - 2i\). Each dot is labeled with its corresponding complex number, placed just above and to the right of the dot.","from manim import *

class ComplexPlaneExample(Scene):
    def construct(self):
        plane = ComplexPlane().add_coordinates()
        self.add(plane)
        d1 = Dot(plane.n2p(2 + 1j), color=YELLOW)
        d2 = Dot(plane.n2p(-3 - 2j), color=YELLOW)
        label1 = MathTex(""2+i"").next_to(d1, UR, 0.1)
        label2 = MathTex(""-3-2i"").next_to(d2, UR, 0.1)
        self.add(
            d1,
            label1,
            d2,
            label2,
        )",Basic,test
"Display a square at the center of the screen. It fades in, then undergoes a series of transformations: it changes color to purple, becomes semi-transparent, shifts to the left, and scales up. Next, it moves downward and rotates slightly. After a brief pause, the square smoothly returns to its original appearance and position using a restore animation.","Display a square at the center of the screen. It fades in, then undergoes a series of transformations: it changes color to purple, becomes semi-transparent, shifts to the left, and scales up. Next, it moves downward and rotates slightly, only displaying a upper half (upper triangle) of the square. After a brief pause, the square smoothly returns to its original appearance and position using a restore animation.","from manim import *

class RestoreExample(Scene):
    def construct(self):
        s = Square()
        s.save_state()
        self.play(FadeIn(s))
        self.play(s.animate.set_color(PURPLE).set_opacity(0.5).shift(2*LEFT).scale(3))
        self.play(s.animate.shift(5*DOWN).rotate(PI/4))
        self.wait()
        self.play(Restore(s), run_time=2)",Intermediate,test
,"Display three on-screen variables with animated updates:

1. A decimal variable labeled “var” starts at 0.5, with the label in red and the value in green. It animates to 10.5.
2. An integer variable labeled “int_var” appears below, also with red and green styling, and animates from 0 to 10.
3. A third variable labeled with a subscripted math expression “\( a_i \)” appears below the others, displaying a static value of 10.

Each variable is introduced with a writing animation and spaced vertically.","from manim import *

class VariablesWithValueTracker(Scene):
    def construct(self):
        var = 0.5
        on_screen_var = Variable(var, Text(""var""), num_decimal_places=3)

        # You can also change the colours for the label and value
        on_screen_var.label.set_color(RED)
        on_screen_var.value.set_color(GREEN)

        self.play(Write(on_screen_var))
        # The above line will just display the variable with
        # its initial value on the screen. If you also wish to
        # update it, you can do so by accessing the `tracker` attribute
        self.wait()
        var_tracker = on_screen_var.tracker
        var = 10.5
        self.play(var_tracker.animate.set_value(var))
        self.wait()

        int_var = 0
        on_screen_int_var = Variable(
            int_var, Text(""int_var""), var_type=Integer
        ).next_to(on_screen_var, DOWN)
        on_screen_int_var.label.set_color(RED)
        on_screen_int_var.value.set_color(GREEN)

        self.play(Write(on_screen_int_var))
        self.wait()
        var_tracker = on_screen_int_var.tracker
        var = 10.5
        self.play(var_tracker.animate.set_value(var))
        self.wait()

        # If you wish to have a somewhat more complicated label for your
        # variable with subscripts, superscripts, etc. the default class
        # for the label is MathTex
        subscript_label_var = 10
        on_screen_subscript_var = Variable(subscript_label_var, ""{a}_{i}"").next_to(
            on_screen_int_var, DOWN
        )
        self.play(Write(on_screen_subscript_var))
        self.wait()",Intermediate,test
,"Display a graph with six labeled nodes arranged using the spectral layout, which positions nodes based on the eigenvectors of the graph's Laplacian matrix. The nodes are connected in a loop with additional cross-links between non-adjacent nodes, forming a dense and structured network. The layout emphasizes the graph's underlying connectivity patterns through a linear or curved arrangement.","from manim import *

class SpectralLayout(Scene):
    def construct(self):
        graph = Graph(
            [1, 2, 3, 4, 5, 6],
            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
            layout=""spectral"",
            labels=True
        )
        self.add(graph)",Intermediate,test
,"Display a set of coordinate axes ranging from 0 to 8 on the x-axis and 0 to 5 on the y-axis. A label reading “\( y \)-values” is placed to the left of the y-axis, rotated vertically and slightly offset outward to clearly indicate the axis it describes.","from manim import *

class GetYAxisLabelExample(Scene):
    def construct(self):
        ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)
        y_label = ax.get_y_axis_label(
            Tex(""$y$-values"").scale(0.65).rotate(90 * DEGREES),
            edge=LEFT,
            direction=LEFT,
            buff=0.3,
        )
        self.add(ax, y_label)",Basic,test
,"Display a directed graph with four numbered nodes connected by arrows representing edges. Initially, the graph appears in a default layout. Then, each node animates to a new position in 3D space: node 1 moves to the upper right, node 2 to the upper left and slightly forward, node 3 to the lower right and back, and node 4 to the lower left. The edges adjust dynamically to maintain the connections between the repositioned nodes.","from manim import *

class MovingDiGraph(Scene):
    def construct(self):
        vertices = [1, 2, 3, 4]
        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]

        g = DiGraph(vertices, edges)

        self.add(g)
        self.play(
            g[1].animate.move_to([1, 1, 1]),
            g[2].animate.move_to([-1, 1, 2]),
            g[3].animate.move_to([1, -1, -1]),
            g[4].animate.move_to([-1, -1, 0]),
        )
        self.wait()",Intermediate,test
,"Display a circle at the center of the screen. It then animates by changing its fill color to semi-transparent green, shrinking to half its size, and moving diagonally up and to the right, smoothly transitioning to its new appearance and position.","from manim import *

class MoveToTargetExample(Scene):
    def construct(self):
        c = Circle()

        c.generate_target()
        c.target.set_fill(color=GREEN, opacity=0.5)
        c.target.shift(2*RIGHT + UP).scale(0.5)

        self.add(c)
        self.play(MoveToTarget(c))",Basic,test
,"Display a square on the screen, then animate it disappearing as if being undone or erased.","from manim import *

class ShowUncreate(Scene):
    def construct(self):
        self.play(Uncreate(Square()))",Basic,test
,Display the LaTeX logo rendered using the LaTeX typesetting system in large font at the center of the screen.,"from manim import *

class HelloLaTeX(Scene):
    def construct(self):
        tex = Tex(r""\LaTeX"", font_size=144)
        self.add(tex)",Basic,test
,"Display the word “Inserting” in purple text on the left side of the screen, with a grey cursor positioned at the start. Animate the text being typed out character by character with the cursor moving along, then make the cursor blink twice.","from manim import *

class InsertingTextExample(Scene):
    def construct(self):
        text = Text(""Inserting"", color=PURPLE).scale(1.5).to_edge(LEFT)
        cursor = Rectangle(
            color = GREY_A,
            fill_color = GREY_A,
            fill_opacity = 1.0,
            height = 1.1,
            width = 0.5,
        ).move_to(text[0]) # Position the cursor

        self.play(TypeWithCursor(text, cursor))
        self.play(Blink(cursor, blinks=2))",Basic,test
,"Display a square starting at the top edge of the screen with a decimal number next to it. As the square moves down and then back up over five seconds, the decimal dynamically updates to show the square’s vertical position, formatted with three decimal places and labeled in “M-Units.” The number smoothly follows the square’s movement throughout the animation.","from manim import *

class MovingSquareWithUpdaters(Scene):
    def construct(self):
        decimal = DecimalNumber(
            0,
            show_ellipsis=True,
            num_decimal_places=3,
            include_sign=True,
            unit=r""\text{M-Units}"",
            unit_buff_per_font_unit=0.003
        )
        square = Square().to_edge(UP)

        decimal.add_updater(lambda d: d.next_to(square, RIGHT))
        decimal.add_updater(lambda d: d.set_value(square.get_center()[1]))
        self.add(square, decimal)
        self.play(
            square.animate.to_edge(DOWN),
            rate_func=there_and_back,
            run_time=5,
        )
        self.wait()",Basic,test
,"Display a semi-transparent orange square. Over three seconds, transform it into a semi-transparent blue circle. Then, create a small dot that stays just below the circle as it moves. Animate the circle shifting to the right, with the dot following it. Finally, fade out both the circle and the dot.","from manim import *

class ToyExample(Scene):
    def construct(self):
        orange_square = Square(color=ORANGE, fill_opacity=0.5)
        blue_circle = Circle(color=BLUE, fill_opacity=0.5)
        self.add(orange_square)
        self.play(ReplacementTransform(orange_square, blue_circle, run_time=3))
        small_dot = Dot()
        small_dot.add_updater(lambda mob: mob.next_to(blue_circle, DOWN))
        self.play(Create(small_dot))
        self.play(blue_circle.animate.shift(RIGHT))
        self.wait()
        self.play(FadeOut(blue_circle, small_dot))",Basic,test
,"Display the word “Italic” centered on the screen, styled with an italic slant.","from manim import *

class SlantsExample(Scene):
    def construct(self):
        a = Text(""Italic"", slant=ITALIC)
        self.add(a)",Basic,test
,Display the text “Hello world” in large font (size 144) centered on the screen.,"from manim import *

class HelloWorld(Scene):
    def construct(self):
        text = Text(""Hello world"", font_size=144)
        self.add(text)",Basic,test
,"Display three squares stacked vertically:

1. A large square at the bottom.
2. A medium-sized square placed directly above the large one.
3. A small square positioned above the medium one.

Each square is centered horizontally and aligned vertically with even spacing.","from manim import *

class SquareExample(Scene):
    def construct(self):
        square_1 = Square(side_length=2.0).shift(DOWN)
        square_2 = Square(side_length=1.0).next_to(square_1, direction=UP)
        square_3 = Square(side_length=0.5).next_to(square_2, direction=UP)
        self.add(square_1, square_2, square_3)",Basic,test
,"Display four instances of the letter ""F"" arranged horizontally with large spacing between them. The first ""F"" is at normal size, the second is twice as large, the third is half the size, and the fourth is flipped due to being scaled by a negative factor.","from manim import *

class MobjectScaleExample(Scene):
    def construct(self):
        f1 = Text(""F"")
        f2 = Text(""F"").scale(2)
        f3 = Text(""F"").scale(0.5)
        f4 = Text(""F"").scale(-1)

        vgroup = VGroup(f1, f2, f3, f4).arrange(6 * RIGHT)
        self.add(vgroup)",Basic,test
"Display a white title reading ""K-means clustering and Logistic Regression"" scaled down and positioned at the top of the screen. Below it, in the bottom-right quadrant, show a vertically arranged list of four white text items: ""1. Measuring"", ""2. Clustering"", ""3. Regression"", and ""4. Prediction"", all semi-transparent except for ""2. Clustering"", which is fully opaque.","Display a white title reading ""K-means clustering and Logistic Regression"" scaled down and positioned at the top of the screen. Below it, in the bottom-right quadrant, show a vertically arranged list of four white text items: 

- ""1. Measuring""
- ""2. Clustering""
- ""3. Regression""
- ""4. Prediction""

All above are semi-transparent except for ""2. Clustering"", which is fully opaque, stressing it out over others.","from manim import *

class TextAlignment(Scene):
    def construct(self):
        title = Text(""K-means clustering and Logistic Regression"", color=WHITE)
        title.scale(0.75)
        self.add(title.to_edge(UP))

        t1 = Text(""1. Measuring"").set_color(WHITE)

        t2 = Text(""2. Clustering"").set_color(WHITE)

        t3 = Text(""3. Regression"").set_color(WHITE)

        t4 = Text(""4. Prediction"").set_color(WHITE)

        x = VGroup(t1, t2, t3, t4).arrange(direction=DOWN, aligned_edge=LEFT).scale(0.7).next_to(ORIGIN,DR)
        x.set_opacity(0.5)
        x.submobjects[1].set_opacity(1)
        self.add(x)",Intermediate,test
,"Display a green dot at the center of the screen. After a short pause, zooming functionality is activated (though not animated), preparing a magnified view. Then, the dot smoothly shifts to the left while the zoomed-in view follows the motion, highlighting the movement in detail.","from manim import *

class ChangingZoomScale(ZoomedScene):
    def __init__(self, **kwargs):
        ZoomedScene.__init__(
            self,
            zoom_factor=0.3,
            zoomed_display_height=1,
            zoomed_display_width=3,
            image_frame_stroke_width=20,
            zoomed_camera_config={
                ""default_frame_stroke_width"": 3,
            },
            **kwargs
        )

    def construct(self):
        dot = Dot().set_color(GREEN)
        sq = Circle(fill_opacity=1, radius=0.2).next_to(dot, RIGHT)
        self.add(dot, sq)
        self.wait(1)
        self.activate_zooming(animate=False)
        self.wait(1)
        self.play(dot.animate.shift(LEFT * 0.3))

        self.play(self.zoomed_camera.frame.animate.scale(4))
        self.play(self.zoomed_camera.frame.animate.shift(0.5 * DOWN))",Intermediate,test
,Display a vertical bar chart with ten bars representing values from 10 down to 1. Each bar is labeled with its corresponding value using white mathematical text in a large font. The chart and labels appear on screen simultaneously without animation.,"from manim import *

class GetBarLabelsExample(Scene):
    def construct(self):
        chart = BarChart(values=[10, 9, 8, 7, 6, 5, 4, 3, 2, 1], y_range=[0, 10, 1])

        c_bar_lbls = chart.get_bar_labels(
            color=WHITE, label_constructor=MathTex, font_size=36
        )

        self.add(chart, c_bar_lbls)",Intermediate,test
,"Display a red outline formed by connecting a sequence of corner points. The shape starts by tracing a square clockwise from the top right, then draws two diagonal lines forming an ""X"" across the bottom half. The entire shape is scaled up to appear larger on the screen.","from manim import *

class PointsAsCornersExample(Scene):
    def construct(self):
        corners = (
            # create square
            UR, UL,
            DL, DR,
            UR,
            # create crosses
            DL, UL,
            DR
        )
        vmob = VMobject(stroke_color=RED)
        vmob.set_points_as_corners(corners).scale(2)
        self.add(vmob)",Basic,test
,"Display a set of axes with a blue line representing the function \( y = x \). At the point where \( x = 4 \), a vertical dashed line and a horizontal dashed line intersect the graph, forming a ""T"" shape. A label reading ""x-value"" is placed near this intersection to indicate the corresponding point on the graph.","from manim import *

class TLabelExample(Scene):
    def construct(self):
        # defines the axes and linear function
        axes = Axes(x_range=[-1, 10], y_range=[-1, 10], x_length=9, y_length=6)
        func = axes.plot(lambda x: x, color=BLUE)
        # creates the T_label
        t_label = axes.get_T_label(x_val=4, graph=func, label=Tex(""x-value""))
        self.add(axes, func, t_label)",Basic,test
"Display a dot shifted to the upper left. Show an image with a height of 7. Add a purple frame around the dot and a red frame around the zoomed display, which is shifted down. Display the text ""Frame"" below the purple frame and ""Zoomed camera"" below the red frame. Scale the frames and zoomed display, then move the purple frame down. Remove the zoomed display and the frames.","Display a white dot shifted to the upper left. Firstly, display a purple rectangle around the dot and word ""Frame"" around that dot. The display a small red-framed inset springing up below, showing a close-up of whatever the purpose box encloses. Show ""Zoomed camera"" under this red-framed inset. The inset operates as a maginifier to the earlier purple rectangle. The inset briefly doubles in size for emphasis before the purple box drifts downward, shifting the zoom focus. Finally, fold the inset back into the purple rectangle gently erasing both frames, leaving only the original dot.","from manim import *

class MovingZoomedSceneAround(ZoomedScene):
# contributed by TheoremofBeethoven, www.youtube.com/c/TheoremofBeethoven
    def __init__(self, **kwargs):
        ZoomedScene.__init__(
            self,
            zoom_factor=0.3,
            zoomed_display_height=1,
            zoomed_display_width=6,
            image_frame_stroke_width=20,
            zoomed_camera_config={
                ""default_frame_stroke_width"": 3,
                },
            **kwargs
        )

    def construct(self):
        dot = Dot().shift(UL * 2)
        image = ImageMobject(np.uint8([[0, 100, 30, 200],
                                       [255, 0, 5, 33]]))
        image.height = 7
        frame_text = Text(""Frame"", color=PURPLE, font_size=67)
        zoomed_camera_text = Text(""Zoomed camera"", color=RED, font_size=67)

        self.add(image, dot)
        zoomed_camera = self.zoomed_camera
        zoomed_display = self.zoomed_display
        frame = zoomed_camera.frame
        zoomed_display_frame = zoomed_display.display_frame

        frame.move_to(dot)
        frame.set_color(PURPLE)
        zoomed_display_frame.set_color(RED)
        zoomed_display.shift(DOWN)

        zd_rect = BackgroundRectangle(zoomed_display, fill_opacity=0, buff=MED_SMALL_BUFF)
        self.add_foreground_mobject(zd_rect)

        unfold_camera = UpdateFromFunc(zd_rect, lambda rect: rect.replace(zoomed_display))

        frame_text.next_to(frame, DOWN)

        self.play(Create(frame), FadeIn(frame_text, shift=UP))
        self.activate_zooming()

        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera)
        zoomed_camera_text.next_to(zoomed_display_frame, DOWN)
        self.play(FadeIn(zoomed_camera_text, shift=UP))
        # Scale in        x   y  z
        scale_factor = [0.5, 1.5, 0]
        self.play(
            frame.animate.scale(scale_factor),
            zoomed_display.animate.scale(scale_factor),
            FadeOut(zoomed_camera_text),
            FadeOut(frame_text)
        )
        self.wait()
        self.play(ScaleInPlace(zoomed_display, 2))
        self.wait()
        self.play(frame.animate.shift(2.5 * DOWN))
        self.wait()
        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera, rate_func=lambda t: smooth(1 - t))
        self.play(Uncreate(zoomed_display_frame), FadeOut(frame))
        self.wait()",Intermediate,test
,"Display a row of evenly spaced dots extending horizontally across the screen. Below it, a second row appears, which is an inverted version of the first—meaning the order of the dots is reversed. Both rows are written onto the screen simultaneously.","from manim import *

class InvertSumobjectsExample(Scene):
    def construct(self):
        s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])
        s2 = s.copy()
        s2.invert()
        s2.shift(DOWN)
        self.play(Write(s), Write(s2))",Basic,test
,"Display a coordinate grid ranging from 0 to 1 on both axes, with tick marks every 0.05 units and labeled every 0.1 units. The x- and y-axes are labeled ""x"" and ""y"" respectively. A series of white graphs are plotted: one set for \( y = x^n \) and another for \( y = x^{1/n} \), where \( n \) ranges from 1 to 20 in steps of 0.5. At the point (1, 1), a yellow dot is placed, with blue horizontal and vertical lines intersecting at that point, and a label ""(1,1)"" appears nearby. A title above the scene describes the plotted functions.","from manim import *

class CoordSysExample(Scene):
    def construct(self):
        # the location of the ticks depends on the x_range and y_range.
        grid = Axes(
            x_range=[0, 1, 0.05],  # step size determines num_decimal_places.
            y_range=[0, 1, 0.05],
            x_length=9,
            y_length=5.5,
            axis_config={
                ""numbers_to_include"": np.arange(0, 1 + 0.1, 0.1),
                ""font_size"": 24,
            },
            tips=False,
        )

        # Labels for the x-axis and y-axis.
        y_label = grid.get_y_axis_label(""y"", edge=LEFT, direction=LEFT, buff=0.4)
        x_label = grid.get_x_axis_label(""x"")
        grid_labels = VGroup(x_label, y_label)

        graphs = VGroup()
        for n in np.arange(1, 20 + 0.5, 0.5):
            graphs += grid.plot(lambda x: x ** n, color=WHITE)
            graphs += grid.plot(
                lambda x: x ** (1 / n), color=WHITE, use_smoothing=False
            )

        # Extra lines and labels for point (1,1)
        graphs += grid.get_horizontal_line(grid @ (1, 1, 0), color=BLUE)
        graphs += grid.get_vertical_line(grid @ (1, 1, 0), color=BLUE)
        graphs += Dot(point=grid @ (1, 1, 0), color=YELLOW)
        graphs += Tex(""(1,1)"").scale(0.75).next_to(grid @ (1, 1, 0))
        title = Title(
            # spaces between braces to prevent SyntaxError
            r""Graphs of $y=x^{ {1}\over{n} }$ and $y=x^n (n=1,2,3,...,20)$"",
            include_underline=False,
            font_size=40,
        )

        self.add(title, graphs, grid, grid_labels)",Advanced,test
,"Display three dots arranged horizontally across the screen: a small dot on the left, a default-sized dot in the center, and another default-sized dot on the right.","from manim import *

class DotExample(Scene):
    def construct(self):
        dot1 = Dot(point=LEFT, radius=0.08)
        dot2 = Dot(point=ORIGIN)
        dot3 = Dot(point=RIGHT)
        self.add(dot1,dot2,dot3)",Basic,test
,"Display a set of coordinate axes ranging from 0 to 8 on the x-axis and 0 to 5 on the y-axis. A label reading “\( x \)-values” is placed below the x-axis, centered and slightly offset downward to clearly indicate the axis it describes.","from manim import *

class GetXAxisLabelExample(Scene):
    def construct(self):
        ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)
        x_label = ax.get_x_axis_label(
            Tex(""$x$-values"").scale(0.65), edge=DOWN, direction=DOWN, buff=0.5
        )
        self.add(ax, x_label)",Basic,test
,"Display a filled purple Reuleaux triangle with thick blue edges, formed by three curved arcs connecting three points in an equilateral triangle layout. The arcs have no visible stroke, and the shape fades into view at the center of the screen.","from manim import *

class ArcPolygonExample(Scene):
    def construct(self):
        arc_conf = {""stroke_width"": 0}
        poly_conf = {""stroke_width"": 10, ""stroke_color"": BLUE,
              ""fill_opacity"": 1, ""color"": PURPLE}
        a = [-1, 0, 0]
        b = [1, 0, 0]
        c = [0, np.sqrt(3), 0]
        arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)
        arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)
        arc2 = ArcBetweenPoints(c, a, radius=2, **arc_conf)
        reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)
        self.play(FadeIn(reuleaux_tri))
        self.wait(2)",Intermediate,test
,"Display a graph with seven labeled nodes arranged using a custom grid-like layout. The nodes are positioned in a staggered 4-column format, centered both horizontally and vertically. Edges connect the nodes to form a branching structure with additional horizontal connections, creating a visually structured and symmetric network.","from manim import *

class CustomLayoutExample(Scene):
    def construct(self):
        import numpy as np
        import networkx as nx

        # create custom layout
        def custom_layout(
            graph: nx.Graph,
            scale: float | tuple[float, float, float] = 2,
            n: int | None = None,
            *args: Any,
            **kwargs: Any,
        ):
            nodes = sorted(list(graph))
            height = len(nodes) // n
            return {
                node: (scale * np.array([
                    (i % n) - (n-1)/2,
                    -(i // n) + height/2,
                    0
                ])) for i, node in enumerate(graph)
            }

        # draw graph
        n = 4
        graph = Graph(
            [i for i in range(4 * 2 - 1)],
            [(0, 1), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (4, 5), (5, 6)],
            labels=True,
            layout=custom_layout,
            layout_config={'n': n}
        )
        self.add(graph)",Intermediate,test
,"Display two vertically arranged groups side by side: on the left, a red label ""CounterclockwiseTransform"" with the numbers 3.141 and 1.618 stacked above it; on the right, a blue label ""Transform"" with the numbers 1.618 and 3.141 stacked above it. First, the top number in the left group transforms into the bottom number using a counterclockwise spinning motion. Then, the top number in the right group transforms into the bottom number with a direct, straight morphing animation.","from manim import *

class CounterclockwiseTransform_vs_Transform(Scene):
    def construct(self):
        # set up the numbers
        c_transform = VGroup(DecimalNumber(number=3.141, num_decimal_places=3), DecimalNumber(number=1.618, num_decimal_places=3))
        text_1 = Text(""CounterclockwiseTransform"", color=RED)
        c_transform.add(text_1)

        transform = VGroup(DecimalNumber(number=1.618, num_decimal_places=3), DecimalNumber(number=3.141, num_decimal_places=3))
        text_2 = Text(""Transform"", color=BLUE)
        transform.add(text_2)

        ints = VGroup(c_transform, transform)
        texts = VGroup(text_1, text_2).scale(0.75)
        c_transform.arrange(direction=UP, buff=1)
        transform.arrange(direction=UP, buff=1)

        ints.arrange(buff=2)
        self.add(ints, texts)

        # The mobs move in clockwise direction for ClockwiseTransform()
        self.play(CounterclockwiseTransform(c_transform[0], c_transform[1]))

        # The mobs move straight up for Transform()
        self.play(Transform(transform[0], transform[1]))",Advanced,test
,"Display a set of coordinate axes with two curves:

- A red curve representing the function \( f(x) = \frac{x^2 - 2}{3} \).
- A blue curve representing the antiderivative of that function, automatically computed and plotted based on the red curve.

This scene visually demonstrates the relationship between a function and its antiderivative.","from manim import *

class AntiderivativeExample(Scene):
    def construct(self):
        ax = Axes()
        graph1 = ax.plot(
            lambda x: (x ** 2 - 2) / 3,
            color=RED,
        )
        graph2 = ax.plot_antiderivative_graph(graph1, color=BLUE)
        self.add(ax, graph1, graph2)",Intermediate,test
,"Display a set of coordinate axes with labeled ticks, then plot the curve \( y = 2\sin(x) \) in dark blue. Highlight the area under the curve between \( x = \frac{\pi}{2} \) and \( x = \frac{3\pi}{2} \) using a solid green fill to visually represent the integral over that interval.","from manim import *

class GetAreaExample(Scene):
    def construct(self):
        ax = Axes().add_coordinates()
        curve = ax.plot(lambda x: 2 * np.sin(x), color=DARK_BLUE)
        area = ax.get_area(
            curve,
            x_range=(PI / 2, 3 * PI / 2),
            color=(GREEN_B, GREEN_D),
            opacity=1,
        )

        self.add(ax, curve, area)",Intermediate,test
,"Display a white line from the origin to the left. Show a yellow line from the origin to the left that rotates around the origin. After 2 seconds, reverse the rotation direction of the yellow line for another 2 seconds. ","from manim import *

class RotationUpdater(Scene):
    def construct(self):
        def updater_forth(mobj, dt):
            mobj.rotate_about_origin(dt)
        def updater_back(mobj, dt):
            mobj.rotate_about_origin(-dt)
        line_reference = Line(ORIGIN, LEFT).set_color(WHITE)
        line_moving = Line(ORIGIN, LEFT).set_color(YELLOW)
        line_moving.add_updater(updater_forth)
        self.add(line_reference, line_moving)
        self.wait(2)
        line_moving.remove_updater(updater_forth)
        line_moving.add_updater(updater_back)
        self.wait(2)
        line_moving.remove_updater(updater_back)
        self.wait(0.5)",Intermediate,test
,"Display a red circle with partial transparency at the center of the screen. After a brief pause, the circle smoothly morphs into the shape of a blue square with lower opacity, matching the square’s points as closely as possible during the transformation.","from manim import *

class MatchPointsScene(Scene):
    def construct(self):
        circ = Circle(fill_color=RED, fill_opacity=0.8)
        square = Square(fill_color=BLUE, fill_opacity=0.2)
        self.add(circ)
        self.wait(0.5)
        self.play(circ.animate.match_points(square))
        self.wait(0.5)",Basic,test
,"Display eight versions of the same graph, each with eight nodes and a set of edges, arranged in three rows. Each graph uses a different automatic layout algorithm: spring, circular, kamada_kawai, planar, random, shell, spectral, and spiral. The graphs are scaled down and positioned side by side in rows to visually compare how each layout arranges the same graph structure.","from manim import *

class GraphAutoPosition(Scene):
    def construct(self):
        vertices = [1, 2, 3, 4, 5, 6, 7, 8]
        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),
                 (2, 8), (3, 4), (6, 1), (6, 2),
                 (6, 3), (7, 2), (7, 4)]
        autolayouts = [""spring"", ""circular"", ""kamada_kawai"",
                       ""planar"", ""random"", ""shell"",
                       ""spectral"", ""spiral""]
        graphs = [Graph(vertices, edges, layout=lt).scale(0.5)
                  for lt in autolayouts]
        r1 = VGroup(*graphs[:3]).arrange()
        r2 = VGroup(*graphs[3:6]).arrange()
        r3 = VGroup(*graphs[6:]).arrange()
        self.add(VGroup(r1, r2, r3).arrange(direction=DOWN))",Basic,test
,"Display a scene with two main sections arranged vertically:

1. At the top, a title reading “A Quote from Newton” is shown. Below it, a blue-colored quote is displayed:  
   *“If I have seen further than others, it is by standing upon the shoulders of giants.”*  
   This quote is enclosed in a yellow rectangular border with extra padding.

2. Below the quote, a large “Hello World” message is shown in LaTeX style, surrounded by a rounded rectangle.

Both sections are centered and neatly spaced for clarity.","from manim import *

class SurroundingRectExample(Scene):
    def construct(self):
        title = Title(""A Quote from Newton"")
        quote = Text(
            ""If I have seen further than others, \n""
            ""it is by standing upon the shoulders of giants."",
            color=BLUE,
        ).scale(0.75)
        box = SurroundingRectangle(quote, color=YELLOW, buff=MED_LARGE_BUFF)

        t2 = Tex(r""Hello World"").scale(1.5)
        box2 = SurroundingRectangle(t2, corner_radius=0.2)
        mobjects = VGroup(VGroup(box, quote), VGroup(t2, box2)).arrange(DOWN)
        self.add(title, mobjects)",Intermediate,test
,"Display five lines of styled text arranged vertically:

1. The first line shows ""foo"" in bold, ""bar"" in italics, and ""foobar"" in bold italics.
2. The second line shows ""foo"" with a strikethrough, ""bar"" underlined, ""big"" in larger font, and ""small"" in smaller font.
3. The third line displays chemical formulas: ""H₂O"" with the ""2"" as a subscript, and ""H₃O⁺"" with the ""3"" as a subscript and ""+"" as a superscript.
4. The fourth line reads ""type help for help"" with ""help"" in monospaced font.
5. The fifth line shows ""foo"" with a double underline and ""bar"" with a red squiggly underline indicating an error.

All lines are centered and stacked vertically on the screen.","from manim import *

class BasicMarkupExample(Scene):
    def construct(self):
        text1 = MarkupText(""<b>foo</b> <i>bar</i> <b><i>foobar</i></b>"")
        text2 = MarkupText(""<s>foo</s> <u>bar</u> <big>big</big> <small>small</small>"")
        text3 = MarkupText(""H<sub>2</sub>O and H<sub>3</sub>O<sup>+</sup>"")
        text4 = MarkupText(""type <tt>help</tt> for help"")
        text5 = MarkupText(
            '<span underline=""double"">foo</span> <span underline=""error"">bar</span>'
        )
        group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)
        self.add(group)",Intermediate,test
"Display a styled code window containing Python code that defines a simple Manim scene. The code shows a square fading in, scaling up by a factor of two, and then pausing. The code is rendered with syntax highlighting and a maroon-colored window frame.","Display a styled code window containing Python code that defines a simple Manim scene. The code shows a square fading in, scaling up by a factor of two, and then pausing. The code is rendered with syntax highlighting and a maroon-colored window frame. It is a screenshot of a code editor with macOS-style window containing Manim code.","from manim import *

class CodeFromString(Scene):
    def construct(self):
        code = '''from manim import Scene, Square

class FadeInSquare(Scene):
    def construct(self):
        s = Square()
        self.play(FadeIn(s))
        self.play(s.animate.scale(2))
        self.wait()'''

        rendered_code = Code(
            code_string=code,
            language=""python"",
            background=""window"",
            background_config={""stroke_color"": ""maroon""},
        )
        self.add(rendered_code)",Intermediate,test
"Display a square at the center of the screen, then animate it with a smooth transformation: first, the top and bottom edges ripple slightly in a sine wave pattern, and then the entire square continues to undulate with a traveling wave effect across its shape, creating a dynamic, wavy distortion over time.","Display a square at the center of the screen, then animate it with a smooth transformation: first, the top and bottom edges ripple slightly in a sine wave pattern, and then the entire square continues to undulate with a traveling wave effect across its shape, creating a dynamic, wavy distortion over time, almost like how a flag would wave at wind.","from manim import *

class HomotopyExample(Scene):
    def construct(self):
        square = Square()

        def homotopy(x, y, z, t):
            if t <= 0.25:
                progress = t / 0.25
                return (x, y + progress * 0.2 * np.sin(x), z)
            else:
                wave_progress = (t - 0.25) / 0.75
                return (x, y + 0.2 * np.sin(x + 10 * wave_progress), z)

        self.play(Homotopy(homotopy, square, rate_func= linear, run_time=2))",Intermediate,test
,"Display a set of coordinate axes, then show a small circle positioned at \((-4, -1.5)\). Two sets of dashed lines extend from the axes to specific points on the circle: one set in green connects to the circle’s rightmost point, and another set in blue connects to its bottom-left corner, visually indicating their coordinates relative to the axes.","from manim import *

class GetLinesToPointExample(Scene):
    def construct(self):
        ax = Axes()
        circ = Circle(radius=0.5).move_to([-4, -1.5, 0])

        lines_1 = ax.get_lines_to_point(circ.get_right(), color=GREEN_B)
        lines_2 = ax.get_lines_to_point(circ.get_corner(DL), color=BLUE_B)
        self.add(ax, lines_1, lines_2, circ)",Intermediate,test
,"Display a circle centered on the screen, wait for one second, then remove the circle from the screen and wait for another second.","from manim import *

class CreatingMobjects(Scene):
    def construct(self):
        circle = Circle()
        self.add(circle)
        self.wait(1)
        self.remove(circle)
        self.wait(1)",Basic,test
,"Display six identical squares arranged in a grid with two rows and three columns, with a small space between each square, all centered on the screen.","from manim import *

class ExampleBoxes(Scene):
    def construct(self):
        boxes=VGroup(*[Square() for s in range(0,6)])
        boxes.arrange_in_grid(rows=2, buff=0.1)
        self.add(boxes)",Basic,test
,"Display the text ""RED COLOR"" in red at the center of the screen.","from manim import *

class SimpleColor(Scene):
    def construct(self):
        col = Text(""RED COLOR"", color=RED)
        self.add(col)",Basic,test
,"Display two versions of the text ""Hello\nWorld"" side by side with a large gap between them. The first version has normal line spacing between ""Hello"" and ""World"", while the second version has much wider line spacing.","from manim import *

class LineSpacing(Scene):
    def construct(self):
        a = Text(""Hello\nWorld"", line_spacing=1)
        b = Text(""Hello\nWorld"", line_spacing=4)
        self.add(Group(a,b).arrange(LEFT, buff=5))",Basic,test
,"Display a vertical list of eight horizontal arrows, each with a different tip style, aligned from top to bottom. Each arrow points from left to right and is accompanied by a smaller, scaled-down version to its right. To the left of each large arrow is a blue label in monospaced font indicating the name of the tip style. The top arrow is yellow with the label ""Default (YELLOW)"", while the rest use default coloring and various tip shapes such as triangle, square, circle, and stealth.","from manim import *

class ArrowTipsShowcase(Scene):
    def construct(self):
        tip_names = [
            'Default (YELLOW)', 'ArrowTriangleTip', 'Default', 'ArrowSquareTip',
            'ArrowSquareFilledTip', 'ArrowCircleTip', 'ArrowCircleFilledTip', 'StealthTip'
        ]

        big_arrows = [
            Arrow(start=[-4, 3.5, 0], end=[2, 3.5, 0], color=YELLOW),
            Arrow(start=[-4, 2.5, 0], end=[2, 2.5, 0], tip_shape=ArrowTriangleTip),
            Arrow(start=[-4, 1.5, 0], end=[2, 1.5, 0]),
            Arrow(start=[-4, 0.5, 0], end=[2, 0.5, 0], tip_shape=ArrowSquareTip),

            Arrow([-4, -0.5, 0], [2, -0.5, 0], tip_shape=ArrowSquareFilledTip),
            Arrow([-4, -1.5, 0], [2, -1.5, 0], tip_shape=ArrowCircleTip),
            Arrow([-4, -2.5, 0], [2, -2.5, 0], tip_shape=ArrowCircleFilledTip),
            Arrow([-4, -3.5, 0], [2, -3.5, 0], tip_shape=StealthTip)
        ]

        small_arrows = (
            arrow.copy().scale(0.5, scale_tips=True).next_to(arrow, RIGHT) for arrow in big_arrows
        )

        labels = (
            Text(tip_names[i], font='monospace', font_size=20, color=BLUE).next_to(big_arrows[i], LEFT) for i in range(len(big_arrows))
        )

        self.add(*big_arrows, *small_arrows, *labels)",Intermediate,test
,"Display two triangles arranged horizontally:

1. A standard triangle on the left.
2. A larger triangle on the right, scaled up by a factor of 2 and rotated 60 degrees, creating a dynamic contrast in size and orientation.","from manim import *

class TriangleExample(Scene):
    def construct(self):
        triangle_1 = Triangle()
        triangle_2 = Triangle().scale(2).rotate(60*DEGREES)
        tri_group = Group(triangle_1, triangle_2).arrange(buff=1)
        self.add(tri_group)",Basic,test
,"Display a red dot starting on the right side of the screen. As it moves left in two curved arcs, it leaves behind a fading trail. The trail gradually disappears over time, creating a dissipating path effect with a short persistence of 0.5 seconds.","from manim import *

class DissipatingPathExample(Scene):
    def construct(self):
        a = Dot(RIGHT * 2)
        b = TracedPath(a.get_center, dissipating_time=0.5, stroke_opacity=[0, 1])
        self.add(a, b)
        self.play(a.animate(path_arc=PI / 4).shift(LEFT * 2))
        self.play(a.animate(path_arc=-PI / 4).shift(LEFT * 2))
        self.wait()",Basic,test
,"Display a solid red square on the left and a solid blue circle overlapping it slightly from the top right. On the right side of the screen, show a green shape representing the difference—where the overlapping part of the circle has been subtracted from the square.","from manim import *

class DifferenceExample(Scene):
    def construct(self):
        sq = Square(color=RED, fill_opacity=1)
        sq.move_to([-2, 0, 0])
        cr = Circle(color=BLUE, fill_opacity=1)
        cr.move_to([-1.3, 0.7, 0])
        un = Difference(sq, cr, color=GREEN, fill_opacity=1)
        un.move_to([1.5, 0, 0])
        self.add(sq, cr, un)",Basic,test
,"Display two annuli centered vertically on screen: a larger black ring shifted upward, and a smaller red ring positioned just below it.","from manim import *

class AnnulusExample(Scene):
    def construct(self):
        annulus_1 = Annulus(inner_radius=0.5, outer_radius=1).shift(UP)
        annulus_2 = Annulus(inner_radius=0.3, outer_radius=0.6, color=RED).next_to(annulus_1, DOWN)
        self.add(annulus_1, annulus_2)",Basic,test
,"Display a square with three horizontal double-headed arrows passing through it from left to right. Each arrow has no spacing from the square’s edges and differs in tip size and color:

1. The first arrow is standard.
2. The second arrow is yellow with shorter tips.
3. The third arrow is blue with longer tips.

The arrows are stacked vertically below the square.","from manim import *

class DoubleArrowExample2(Scene):
    def construct(self):
        box = Square()
        p1 = box.get_left()
        p2 = box.get_right()
        d1 = DoubleArrow(p1, p2, buff=0)
        d2 = DoubleArrow(p1, p2, buff=0, tip_length=0.2, color=YELLOW)
        d3 = DoubleArrow(p1, p2, buff=0, tip_length=0.4, color=BLUE)
        Group(d1, d2, d3).arrange(DOWN)
        self.add(box, d1, d2, d3)",Basic,test
,"Display a layered neural network graph with four layers of nodes arranged in a partite layout. The layers contain 2, 3, 3, and 2 nodes respectively. Each node in one layer is connected to every node in the next layer, forming a fully connected feedforward structure. The nodes are evenly spaced and styled as small circles, visually representing a simple artificial neural network architecture.","from manim import *

class LinearNN(Scene):
    def construct(self):
        edges = []
        partitions = []
        c = 0
        layers = [2, 3, 3, 2]  # the number of neurons in each layer

        for i in layers:
            partitions.append(list(range(c + 1, c + i + 1)))
            c += i
        for i, v in enumerate(layers[1:]):
                last = sum(layers[:i+1])
                for j in range(v):
                    for k in range(last - layers[i], last):
                        edges.append((k + 1, j + last + 1))

        vertices = np.arange(1, sum(layers) + 1)

        graph = Graph(
            vertices,
            edges,
            layout='partite',
            partitions=partitions,
            layout_scale=3,
            vertex_config={'radius': 0.20},
        )
        self.add(graph)",Advanced,test
,"Display a set of axes with labeled coordinates, then show a small circle positioned in the upper right quadrant. A matrix label appears to the right of the circle, showing the circle’s coordinates relative to the axes. A dot marks the rightmost point of the circle.","from manim import *

class PointToCoordsExample(Scene):
    def construct(self):
        ax = Axes(x_range=[0, 10, 2]).add_coordinates()
        circ = Circle(radius=0.5).shift(UR * 2)

        # get the coordinates of the circle with respect to the axes
        coords = np.around(ax.point_to_coords(circ.get_right()), decimals=2)

        label = (
            Matrix([[coords[0]], [coords[1]]]).scale(0.75).next_to(circ, RIGHT)
        )

        self.add(ax, circ, label, Dot(circ.get_right()))",Intermediate,test
,"Display a series of thick green V-shaped lines, each demonstrating a different line joint style (such as miter, bevel, or round) at the corner where the two segments meet. The lines are arranged horizontally with equal spacing, and each one is labeled below with the name of its corresponding joint type, allowing for easy visual comparison of the joint styles.","from manim import *

class LineJointVariants(Scene):
    def construct(self):
        mob = VMobject(stroke_width=20, color=GREEN).set_points_as_corners([
            np.array([-2, 0, 0]),
            np.array([0, 0, 0]),
            np.array([-2, 1, 0]),
        ])
        lines = VGroup(*[mob.copy() for _ in range(len(LineJointType))])
        for line, joint_type in zip(lines, LineJointType):
            line.joint_type = joint_type

        lines.arrange(RIGHT, buff=1)
        self.add(lines)
        for line in lines:
            label = Text(line.joint_type.name).next_to(line, DOWN)
            self.add(label)",Basic,test
,"Display a 2×2 matrix composed of graphical objects:

- A small circle in the top-left,
- A small square in the top-right,
- A large \( \pi \) symbol in the bottom-left,
- A small star in the bottom-right.

The matrix appears on screen without animation.","from manim import *

class MobjectMatrixExample(Scene):
    def construct(self):
        a = Circle().scale(0.3)
        b = Square().scale(0.3)
        c = MathTex(""\\pi"").scale(2)
        d = Star().scale(0.3)
        m0 = MobjectMatrix([[a, b], [c, d]])
        self.add(m0)",Basic,test
,"Display a large white square in the center of the screen. Below it, three circles are arranged horizontally:

- The first circle is green with 80% opacity.
- The second circle is yellow with full opacity (default).
- The third circle is a light red color (`#FF2135`) with 20% opacity.

This demonstrates different fill colors and opacities applied to shapes.","from manim import *

class SetFill(Scene):
    def construct(self):
        square = Square().scale(2).set_fill(WHITE,1)
        circle1 = Circle().set_fill(GREEN,0.8)
        circle2 = Circle().set_fill(YELLOW) # No fill_opacity
        circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)
        group = Group(circle1,circle2,circle3).arrange()
        self.add(square)
        self.add(group)",Basic,test
,"Display a graph with four nodes manually positioned to form an asymmetric shape: node 1 at the center-left, node 2 at the upper right, node 3 at the lower right, and node 4 at the far left. The nodes are connected in a loop, forming a closed quadrilateral with edges linking them in sequence.","from manim import *

class GraphManualPosition(Scene):
    def construct(self):
        vertices = [1, 2, 3, 4]
        edges = [(1, 2), (2, 3), (3, 4), (4, 1)]
        lt = {1: [0, 0, 0], 2: [1, 1, 0], 3: [1, -1, 0], 4: [-1, 0, 0]}
        G = Graph(vertices, edges, layout=lt)
        self.add(G)",Basic,test
,"Display a group of three point cloud dots arranged horizontally. The left dot is large and blue, the center dot is default-sized, and the right dot is the largest with a pink outline. All three are shown together as a single grouped object centered on the screen.","from manim import *

class PgroupExample(Scene):
    def construct(self):

        p1 = PointCloudDot(radius=1, density=20, color=BLUE)
        p1.move_to(4.5 * LEFT)
        p2 = PointCloudDot()
        p3 = PointCloudDot(radius=1.5, stroke_width=2.5, color=PINK)
        p3.move_to(4.5 * RIGHT)
        pList = PGroup(p1, p2, p3)

        self.add(pList)",Basic,test
